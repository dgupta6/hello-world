GAMS 24.5.6  r55090 Released Nov 27, 2015 WEX-WEI x86 64bit/MS Windows 07/18/16 14:57:01 Page 1
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
C o m p i l a t i o n


   3  SCALAR re_freq                    /1/;
   4  PARAMETER demand_cycletime        /7/;
   5  PARAMETER demand_variation        /0/;
   6  PARAMETER demand_magnitude        /8/;
   7  PARAMETER lambda_Demand           /0.00/;
   8  SCALAR surprise                   /0.00/;
   9  SCALAR optcr_value                /0/;
  10  PARAMETER SEED_VALUE              /1716/;
INCLUDE    C:\Users\dhruv\Box Sync\Work\Codes\GAMS_Code\ConfigurationFile.gms
GAMS 24.5.6  r55090 Released Nov 27, 2015 WEX-WEI x86 64bit/MS Windows 07/18/16 14:57:01 Page 2
CONFIGURATION_FILE
C o m p i l a t i o n


  23   
  24  *$SETGLOBAL OPTIMIZATION_DIRECTION  maximizing
  25  *$SETGLOBAL MODEL_NAME MAX_PROFIT
  26  *$SETGLOBAL InitialInventoryFlag 1
  27   
  28  *$SETGLOBAL OPTIMIZATION_DIRECTION  minimizing
  29  *$SETGLOBAL MODEL_NAME MIN_COST
  30  *$SETGLOBAL InitialInventoryFlag 0
  31  *******HORIZON********
  32  *$SETGLOBAL H 192
  34  *$SETGLOBAL MH 20
  35  *SCALAR re_freq /1/;
  36  *Used in chopping off initial transient in closed loop cost evaluation
  37  *$SETGLOBAL Transient_H 48
  38  *$SETGLOBAL Transient_H 0
  39  *We do Closed_Loop_Upper # of calc and record closed loop solution only ti
      ll there
  40  *$SETGLOBAL Closed_Loop_Upper 168
  41  *$SETGLOBAL Closed_Loop_Upper 192
  42  *******HORIZON********
  43   
  44  *******NETWORK AND MODEL********
  45  *$SETGLOBAL NetworkNumber 1
  48  *******NETWORK AND MODEL********
  49   
  50  *******DEMAND LOAD********
  51  *PARAMETER demand_cycletime /12/;
  52  *PARAMETER demand_variation /3/;
  53  *PARAMETER demand_magnitude NOMINAL LOAD /25/;
  54  *******DEMAND LOAD********
  55   
  56  ******DISTURBANCES********************
  57  *$SETGLOBAL Demand_Disturbance_flag 0
  61  *Parameters for demand uncertainty
  62  *What fraction ahead of rolling Horizon does demand forecast changes'
  63  *SCALAR surprise /0.34/;
  64  *Magnitude of Uncertainties
  65  *PARAMETER lambda_Demand /0.2/;
  66  *Yet to replace these names in ModelSolution9 file
  67  *and these values are hardcoded right now (look into code again)
  68  PARAMETER lambda_TaskDelay /0.2/;
  69  PARAMETER default_delay_length /1/;
  70  PARAMETER lambda_UnitBreakdown /0.2/;
  71  PARAMETER time_to_bring_unit_back_online /2/;
  72  PARAMETER lambda_Handling /0.2/;
  73  ******DISTURBANCES********************
  74   
  75  *******OPTIMIZATION OPTIONS****
  76  *SCALAR   optcr_value /0/;
  77  SCALAR   timelimit /600/;
  78  *******OPTIMIZATION OPTIONS****
  79   
  80  *******EVALUATION********
  81  *$SETGLOBAL N_runs 1
  82  *******EVALUATION********
  83   
  84  *******REPORTING********
  87  *$SETGLOBAL Results_FileName Config_Results
  88  *******REPORTING********
  89   
  90  *Run the closed loop and generate results
INCLUDE    C:\Users\dhruv\Box Sync\Work\Codes\GAMS_Code\MasterFile.gms
  92  *Change this to name of the instance
GAMS 24.5.6  r55090 Released Nov 27, 2015 WEX-WEI x86 64bit/MS Windows 07/18/16 14:57:01 Page 3
MasterFile
C o m p i l a t i o n


  98  *$OFFLISTING
  99   
 100  execseed=SEED_VALUE;
 101  *parameter cc /0/;
 102   
 104  SCALAR KillLength /2/;
 105   
 106  SET run /run1*run1/;
 107   
INCLUDE    C:\Users\dhruv\Box Sync\Work\Codes\GAMS_Code\NetworkN4.gms
 109  Sets     i tasks  /T1*T3/
 110           s states /M1*M4/
 111           j units  /U1*U2/
 112           u utilities /manpower/
 113   
 114  *         Ki(j,i) set of equipments(units) suitable for task i
 115  *         /(Reactor1).(TA,TB),Heater.Heating/
 116           Ij(i,j) set of equipments(units) suitable for task i
 117           /T1.U1,(T2,T3).U2/
 118   
 119           FIS(s) States with Finite Intermediate Storage /M2/
 120           product_states(s) Product States/M3*M4/
 121           feed_states(s) Feed States/M1/
 122   
 123           UtilInt Intervals for utility /Int1/
 124           UnitInt Intervals for unit-unavailability /Int1/
 125   
 126           Attributes/magnitude, starttime, price/
 127  ;
 128   
 129  Table UtilData(UtilInt,u,Attributes)
 130               manpower.starttime            manpower.magnitude      manpowe
      r.price
 131  Int1                    0                         10                     0
 132  ;
 133   
 134  *Availability of unit  0=available, 1=not available
 135  Table UnitData(UnitInt,j,Attributes)
 136                U1.magnitude         U1.starttime
 137  Int1              0                     0
 138  ;
 139   
 140  Parameters rho(i,s) proportion of input of task i from states s
 141             /T1.M1 1,(T2,T3).M2 1/
 142             rhobar(i,s) proportion of ouput of task i to state s
 143             /T1.M2 1, T2.(M3 0.8,M2 0.2), T3.M4 1/
 144  *           /T1.M2 1, T2.M3 1, T3.M4 1/
 145   
 146             pis(i,s) processing time for output of task i into state s
 147             /T1.M2 2,T2.M3 2,T2.M2 2, T3.M4 3/
 148             pi(i) maximum processing time in task i for any stage produced 
      by it
 149   
 150             alpha(u,i) fixed utility demand by task i throughout its run
 151             /manpower.(T1*T2) 0/
 152             beta(u,i) "variable utility demand by task i throughout its run
      (te/hr)"
 153             /manpower.(T1*T2) 0/
 154   
 155             vmaxij(i,j)  Maximum capacity of unit j when used for task i
 156             /T1.U1 20, (T2,T3).U2 10/
 157             vminij(i,j)  Minimum capacity of unit j when used for task i
 158             /T1.U1 10, (T2,T3).U2 5/
 159             Cs(s) maximum storage capacity for stage s  /(M1*M4) 99999/
 160             Cst(s) unit price of s/M1 1, M2 5, M3 10, M4 10/
 161  ;
 162  *pis(i,s)=5;
 163  pi(i)=smax(s,pis(i,s));
 164   
      ******DEMAND INFORMATION*****************************
      *Each order for all products
      set         o orders /o1*o%H%/;
      parameter deliveries_time(o);
      deliveries_time(o)=demand_cycletime*ord(o);
      deliveries_time(o)=deliveries_time(o)+UniformInt(-demand_variation,demand_
      variation);
      parameter deliveries(o,s);
      deliveries(o,s)$(product_states(s))=demand_magnitude;
      ******DEMAND INFORMATION*****************************
 176   
 177  *END OF INSTANCE FILE
 178   
 179   
 180   
 181   
 182   
 183   
 184   
 185   
 186   
 187   
 188   
 189   
 190   
 191   
 192   
 193   
      Table deliveries(o,s)
              SA      SB
      o1      5       5
      o2      5       5
      o3      5       5
      o4      5       5
      o5      5       5
      o6      5       5
      o7      5       5
      o8      5       5;
 206   
 207   
      For debugging/testing utility formulas
      Table UtilData(UtilInt,u,Attributes)
                   manpower.starttime            manpower.magnitude      manpowe
      r.price
      Int1                    0                         1                     1
      Int2                    1.5                       0                     0
      Int3                    3.5                       1                     1
      Int4                    6.1                       0                     0;
INCLUDE    C:\Users\dhruv\Box Sync\Work\Codes\GAMS_Code\Model9.gms
GAMS 24.5.6  r55090 Released Nov 27, 2015 WEX-WEI x86 64bit/MS Windows 07/18/16 14:57:01 Page 4
State_Space_Model
C o m p i l a t i o n


 219   
 220  PARAMETER Small_number /1E-2/;
 221  *used for rounding W,B in recordstates in modelsolution file
 222   
 223  *Now generating time grid using delta
 226  *$EvalGlobal calculations (%horizon%-%window%)
 230   
 231  set h time(multiples of delta) /h0*h216/
 232      n time window   /n0*n16/
 233      calc #of windows /calc0*calc6/
 234   
 235      closed_loop(h) horizon points for which we calculate closed loop cost
 236   
 237      Sbari(s,i)  materials produced by task i
 238      Si(s,i)     materials consumed by task i
 239      Tbars(i,s)    Tasks producing material s
 240      Ts(i,s) Tasks consuming material s;
 241   
 242  Sbari(s,i)=1$(rhobar(i,s) gt 0);
 243  Si(s,i)=1$(rho(i,s) gt 0);
 244  *Ij(i,j)=Ki(j,i);
 245  Tbars(i,s)=Sbari(s,i);
 246  Ts(i,s)=Si(s,i);
 247   
 248  closed_loop(h)=0;
 249  closed_loop(h)$(ord(h)-1 ge 0 and ord(h)-1 le 6)=1;
 250   
 251   
 252  alias(i,ip)
 253  alias(j,jp)
 254  alias(s,sp)
 255  alias(n,np)
 256  alias(h,hbar);
 257   
 258  set     UnitUnavailable_full(j,h)
 259  UnitUnavailable(j,n);
 260   
 261  parameter Uutmax_full(u,h),Cut_full(u,h) utility price;
 262   
 263  parameters Dst(s,n),Uutmax(u,n),Cut(u,n);
 264   
 265   
 266  parameter pis_new(i,s),pi_new(i);
 267  *tau_new(j,k,kp);
 268  pis_new(i,s)=ceil(pis(i,s)/1);
 269  pi_new(i)=ceil(pi(i)/1);
 270   
 271  parameter alpha_new(u,i),beta_new(u,i),Cst_new(s);
 272   
 273  alpha_new(u,i)=alpha(u,i);
 274   
 275  beta_new(u,i)=beta(u,i);
 276   
 277  Cst_new(s)=Cst(s);
 278   
 279   
 280   
 281   
 282  *UTILITY CALCULATIONS NEED TO BE CORRECTED
 283  *RIGHT NOW THERE IS BUG THAT IF THERE IS MORE THAN ONE CHANGE
 284  *WITHIN AN INTERVAL THEN THE CODE TAKES FIRST CHANGE ONLY
 285  *AND IGNORES THE SECOND CHANGE
 286  loop(UtilInt,
 287  *Maximum available utility
 288  Uutmax_full(u,h)$(ord(UtilInt) eq 1 and
 289                   ord(h) ge 1 and
 290                   ord(h)-1 lt (floor(UtilData(UtilInt+1,u,"starttime")/1)$(
      UtilData(UtilInt,u,"magnitude") gt UtilData(UtilInt+1,u,"magnitude"))+
 291                                ceil(UtilData(UtilInt+1,u,"starttime")/1)$(U
      tilData(UtilInt,u,"magnitude") le UtilData(UtilInt+1,u,"magnitude")) ))
 292                  =  UtilData(UtilInt,u,"magnitude");
 293   
 294   
 295   
 296   
 297  Uutmax_full(u,h)$((ord(UtilInt) gt 1 and ord(UtilInt) lt card(UtilInt)) an
      d
 298                   ord(h)-1 ge (floor(UtilData(UtilInt,u,"starttime")/1)$(Ut
      ilData(UtilInt-1,u,"magnitude") gt UtilData(UtilInt,u,"magnitude"))+
 299                                ceil(UtilData(UtilInt,u,"starttime")/1)$(Uti
      lData(UtilInt-1,u,"magnitude") le UtilData(UtilInt,u,"magnitude")) ) and
 300                   ord(h)-1 lt (floor(UtilData(UtilInt+1,u,"starttime")/1)$(
      UtilData(UtilInt,u,"magnitude") gt UtilData(UtilInt+1,u,"magnitude"))+
 301                                ceil(UtilData(UtilInt+1,u,"starttime")/1)$(U
      tilData(UtilInt,u,"magnitude") le UtilData(UtilInt+1,u,"magnitude")) ))
 302                  =  UtilData(UtilInt,u,"magnitude");
 303   
 304   
 305   
 306  Uutmax_full(u,h)$(ord(UtilInt) eq card(UtilInt) and
 307                   ord(h)-1 ge (floor(UtilData(UtilInt,u,"starttime")/1)$(Ut
      ilData(UtilInt-1,u,"magnitude") gt UtilData(UtilInt,u,"magnitude"))+
 308                                ceil(UtilData(UtilInt,u,"starttime")/1)$(Uti
      lData(UtilInt-1,u,"magnitude") le UtilData(UtilInt,u,"magnitude")) ) and
 309                   ord(h) le card(h))
 310                  =  UtilData(UtilInt,u,"magnitude");
 311   
 312   
 313  *Utility Price
 314  Cut_full(u,h)$(ord(UtilInt) eq 1 and
 315            ord(h)-1 lt (floor(UtilData(UtilInt+1,u,"starttime")/1))   )
 316            =  UtilData(UtilInt,u,"price");
 317   
 318  Cut_full(u,h)$(ord(UtilInt) gt 1 and ord(UtilInt) lt card(UtilInt) and
 319            ord(h)-1 gt (floor(UtilData(UtilInt,u,"starttime")/1)) and
 320            ord(h)-1 lt (floor(UtilData(UtilInt+1,u,"starttime")/1))   )
 321            =  UtilData(UtilInt,u,"price");
 322   
 323  Cut_full(u,h)$(ord(UtilInt) eq card(UtilInt) and
 324            ord(h)-1 gt floor(UtilData(UtilInt,u,"starttime")/1) and
 325            ord(h) le card(h)   )
 326            =  UtilData(UtilInt,u,"price");
 327   
 328  Cut_full(u,h)$(ord(UtilInt) gt 1 and
 329           ord(h)-1 eq floor(UtilData(UtilInt,u,"starttime")/1))
 330           =(   UtilData(UtilInt-1,u,"price")*(UtilData(UtilInt,u,"starttime
      ")-(ord(h)-1)* 1 )
 331                +UtilData(UtilInt,u,"price")*(ord(h)*1-UtilData(UtilInt,u,"s
      tarttime"))   )/1;
 332  *Bug in cost calculation: what if there are 3 cost levels within one time 
      grid?
 333  )
 334   
 335   
 336  *UnitUnavailabality(note the difference in inequalities as opposed to Util
      ity....1=>unit not available so more magnitude is bad)
 337  loop(UnitInt,
 338  Unitunavailable_full(j,h)$(ord(UnitInt) eq 1 and
 339                   ord(h)-1 ge 0 and
 340                   ord(h)-1 lt (floor(UnitData(UnitInt+1,j,"starttime")/1)$(
      UnitData(UnitInt,j,"magnitude") lt UnitData(UnitInt+1,j,"magnitude"))+
 341                                ceil(UnitData(UnitInt+1,j,"starttime")/1)$(U
      nitData(UnitInt,j,"magnitude") ge UnitData(UnitInt+1,j,"magnitude")) ))
 342                  =  UnitData(UnitInt,j,"magnitude");
 343   
 344   
 345   
 346   
 347  Unitunavailable_full(j,h)$((ord(UnitInt) gt 1 and ord(UnitInt) lt card(Uni
      tInt)) and
 348                   ord(h)-1 ge (floor(UnitData(UnitInt,j,"starttime")/1)$(Un
      itData(UnitInt-1,j,"magnitude") lt UnitData(UnitInt,j,"magnitude"))+
 349                                ceil(UnitData(UnitInt,j,"starttime")/1)$(Uni
      tData(UnitInt-1,j,"magnitude") ge UnitData(UnitInt,j,"magnitude")) ) and
 350                   ord(h)-1 lt (floor(UnitData(UnitInt+1,j,"starttime")/1)$(
      UnitData(UnitInt,j,"magnitude") lt UnitData(UnitInt+1,j,"magnitude"))+
 351                                ceil(UnitData(UnitInt+1,j,"starttime")/1)$(U
      nitData(UnitInt,j,"magnitude") ge UnitData(UnitInt+1,j,"magnitude")) ))
 352                  =  UnitData(UnitInt,j,"magnitude");
 353   
 354   
 355   
 356  Unitunavailable_full(j,h)$(ord(UnitInt) eq card(UnitInt) and
 357                   ord(h)-1 ge (floor(UnitData(UnitInt,j,"starttime")/1)$(Un
      itData(UnitInt-1,j,"magnitude") lt UnitData(UnitInt,j,"magnitude"))+
 358                                ceil(UnitData(UnitInt,j,"starttime")/1)$(Uni
      tData(UnitInt-1,j,"magnitude") ge UnitData(UnitInt,j,"magnitude")) ) and
 359                   ord(h) le card(h))
 360                  =  UnitData(UnitInt,j,"magnitude");
 361  )
 362   
 363   
 364   
 365  *display UnitUnavailable_full,Uutmax_full,Cut_full,Sbari,Si,rhobar,rho,Tba
      rs,Ts,calc;
 366   
 367  *Ijk,tauChangeMax
 368   
 369   
 370   
 371  *Disturbance parameter for loading/unloading of materials
 372  parameters betaHatProd(i,j,s,n),betaHatCons(i,j,s,n);
 373  betaHatProd(i,j,s,n)=0;
 374  betaHatCons(i,j,s,n)=0;
 375   
 376   
 377  *Disturbance parameter for task delays
 378  parameters
 379  Yhat(i,j,n,hbar)
 380  Delay(calc,i,j,hbar)
 381  Zhat(i,j,n,hbar)
 382  Breakdown(calc,i,j,hbar)
 383  Duration_breakdown(calc,j)
 384  UnitBroken(j,n)
 385  WbarInfo(i,j,n,hbar)
 386  BbarInfo(i,j,n,hbar)
 387  KillDuration(i,j)
 388  KillDurationCountdown(i,j)
 389  KillOccupy(j,n)
 390  KillCountdown(j);
 391   
 392  *Initializing parameters
 393  Yhat(i,j,n,hbar)=0;
 394  Delay(calc,i,j,hbar)=0;
 395  Zhat(i,j,n,hbar)=0;
 396  Breakdown(calc,i,j,hbar)=0;
 397  Duration_breakdown(calc,j)=0;
 398  UnitBroken(j,n)=0;
 399  WbarInfo(i,j,n,hbar)=0;
 400  BbarInfo(i,j,n,hbar)=0;
 401  KillDuration(i,j)=0;
 402  KillDurationCountdown(i,j)=0;
 403  KillOccupy(j,n)=0;
 404  KillCountdown(j)=0;
 405   
 406  *hbar are the time points for lifting of variables
 407  *binary variables W(i,j,n),Wbar(i,j,n,hbar),T(i,j,hbar) Kill_Variable;
 408  binary variables Wbar(i,j,n,hbar),T(i,j,hbar) Kill_Variable;
 409  positive variable Bbar(i,j,n,hbar),Sst(s,n),Backlog(s,n),Ship(s,n),Ship_sa
      les(s,n),Uut(u,n),Rst(s,n),SstTerminal(s),BacklogTerminal(s);
 410  variables obj_variable;
 411  integer variable NB(i,j) number of batches;
 412  *Assigning values to variables that might not participate in optimization
 413  Uut.l(u,n)=0;
 414  Ship_sales.l(s,n)=0;
 415   
 416  Equations
 417  numberOfBatches,
 418  Allocation,
 419  UnitCapacityMax,UnitCapacityMin,
 420  InventoryLimit,
 421  InventoryBalance,
 422  EndingInventory,
 423  BacklogBalance,
 424  EndingBacklog,
 425  UtilityLimit,
 426  UtilityBalance,
 427  objective_MIN_COST,
 428  objective_MAX_PROFIT,
 429  objective_MAX_PROFIT_Greedy
 430  UnitUnavailabality,
 431  *CorrectHolding(i,j,n),
 432  LiftingW,
 433  *LiftingW0,
 434  LiftingB,
 435  *LiftingB0,
 436  Carryover_W,Carryover_B,
 437  InventoryBalance_MAX_PROFIT,
 438  EndingInventory_MAX_PROFIT
 439  Ship_constraint(s,n)
 440  NoShip(s,n)
 441  NoTaskStart;
 442  *SHIPMENT;
 443  *NoTaskRunningAtEndOfHorizon;
 444   
 445  numberOfBatches(i,j)$Ij(i,j).. NB(i,j)=E=sum((n,hbar)$(ord(hbar)-1 eq 0),W
      bar(i,j,n,hbar));
 446   
 447  *scalar ord_calc /0/;
 448  SCALAR fixed_decisions /0/;
 449  SCALAR reschedule_flag /0/;
 450  *re_freq-1-mod(ord_calc-1+re_freq-1,re_freq)  is zero for calc0
 451  Carryover_W(i,j,n,hbar)$(ord(n)-1 le fixed_decisions and ord(hbar)-1 ge 1 
      and ord(hbar)-1 le pi(i) and Ij(i,j))..Wbar(i,j,n,hbar)=E=WbarInfo(i,j,n,h
      bar)*(1-T(i,j,hbar))*(1-Zhat(i,j,n,hbar));
 452  Carryover_B(i,j,n,hbar)$(ord(n)-1 le fixed_decisions and ord(hbar)-1 ge 1 
      and ord(hbar)-1 le pi(i) and Ij(i,j))..Bbar(i,j,n,hbar)=E=BbarInfo(i,j,n,h
      bar)*(1-T(i,j,hbar))*(1-Zhat(i,j,n,hbar));
 453   
 454  *LiftingW(i,j,n,hbar)$((ord(hbar)-1 ge 1) and (ord(hbar)-1 le pi(i)) and (
      ord(n) lt card(n)) and Ij(i,j))..
 455  *         Wbar(i,j,n+1,hbar)=E=Wbar(i,j,n,hbar-1)+Yhat(i,j,n,hbar)-Yhat(i,
      j,n,hbar-1)-Zhat(i,j,n,hbar-1);
 456  *LiftingB(i,j,n,hbar)$((ord(hbar)-1 ge 1) and (ord(hbar)-1 le pi(i)) and (
      ord(n) lt card(n)) and Ij(i,j))..
 457  *         Bbar(i,j,n+1,hbar)=E=Bbar(i,j,n,hbar-1)+Bbar(i,j,n,hbar)*Yhat(i,
      j,n,hbar)-Bbar(i,j,n,hbar-1)*Yhat(i,j,n,hbar-1)
 458   
 459  LiftingW(i,j,n,hbar)$((ord(hbar)-1 ge 1) and (ord(hbar)-1 le pi(i)) and (o
      rd(n) lt card(n)) and Ij(i,j))..
 460           Wbar(i,j,n+1,hbar)=E=Wbar(i,j,n,hbar-1)+Yhat(i,j,n,hbar)-Yhat(i,j
      ,n,hbar-1);
 461   
 462  LiftingB(i,j,n,hbar)$((ord(hbar)-1 ge 1) and (ord(hbar)-1 le pi(i)) and (o
      rd(n) lt card(n)) and Ij(i,j))..
 463           Bbar(i,j,n+1,hbar)=E=Bbar(i,j,n,hbar-1)+Bbar(i,j,n,hbar)*Yhat(i,j
      ,n,hbar)-Bbar(i,j,n,hbar-1)*Yhat(i,j,n,hbar-1);
 464  Allocation(j,n).. sum((i,hbar)$(Ij(i,j) and (ord(hbar) -1 le (pi_new(i)-1)
      ) ), Wbar(i,j,n,hbar))=L=1-sum((i,hbar)$(Ij(i,j) and (ord(hbar) -1 eq pi_n
      ew(i)) ) , Yhat(i,j,n,hbar))-UnitBroken(j,n)
 465                        -sum((i,hbar)$(Ij(i,j) and ord(hbar)-1 ge 1 and ord(
      hbar)-1 le pi(i)),T(i,j,hbar)$(ord(n)-1 lt KillDuration(i,j)))-KillOccupy(
      j,n);
 466  *ord(np)-1=0 => Wbar0 which is also included in the above sum, so we dont 
      have to explicitly sum over W now since W0 is also there
 467   
 468  UnitCapacityMax(i,j,n,hbar)$(Ij(i,j) and ord(hbar)-1 eq 0).. Bbar(i,j,n,hb
      ar)=L=Wbar(i,j,n,hbar)*vmaxij(i,j);
 469   
 470  UnitCapacityMin(i,j,n,hbar)$(Ij(i,j) and ord(hbar)-1 eq 0).. Bbar(i,j,n,hb
      ar)=G=Wbar(i,j,n,hbar)*vminij(i,j);
 471   
 472  InventoryLimit(s,n)$(FIS(s)).. Sst(s,n)=L=Cs(s);
 473   
 474  *Watch out for brackets in betahatCons and betaHatProd. One has multiplica
      tion with rho other does not
 475  InventoryBalance(s,n)$(ord(n) lt card(n)).. Sst(s,n+1)=E=Sst(s,n)+sum((i,j
      ,hbar)$(Tbars(i,s) and Ij(i,j) and (ord(hbar) -1 eq pis_new(i,s))),rhobar(
      i,s)*(Bbar(i,j,n,hbar)*(1-Yhat(i,j,n,hbar)-Zhat(i,j,n,hbar))+betaHatProd(i
      ,j,s,n)))
 476                           -sum((i,j,hbar)$(Ts(i,s) and Ij(i,j) and ord(hbar
      ) eq 1),rho(i,s)*Bbar(i,j,n,hbar)+betaHatCons(i,j,s,n)) -Ship(s,n)$(produc
      t_states(s))+Rst(s,n)$(feed_states(s));
 477  EndingInventory(s,n)$(ord(n) eq card(n)).. SstTerminal(s)=E=Sst(s,n)+sum((
      i,j,hbar)$(Tbars(i,s) and Ij(i,j) and (ord(hbar) -1 eq pis_new(i,s))),rhob
      ar(i,s)*(Bbar(i,j,n,hbar)*(1-Yhat(i,j,n,hbar)-Zhat(i,j,n,hbar))+betaHatPro
      d(i,j,s,n)))
 478                           -sum((i,j,hbar)$(Ts(i,s) and Ij(i,j)and ord(hbar)
       eq 1),rho(i,s)*Bbar(i,j,n,hbar)+betaHatCons(i,j,s,n)) -Ship(s,n)$(product
      _states(s))+Rst(s,n)$(feed_states(s));
 479   
 480  ********
 481  *Inventory at point 2 means, inventory level infinitesimal time just befor
      e point 2, ie 2-, need to define extra ending inventory variable SstTermin
      al(s)
 482  *Deliveries are point functions like B, W while inventory is interval func
      tion
 483  *Kondili has convention that inventory at point 2 is 2+, so has to define 
      extra initial inventory parameter Sst0(s)
 484   
 485   
 486  ***********Backlogs******
 487  BacklogBalance(s,n)$(product_states(s) and ord(n) lt card(n)).. Backlog(s,
      n+1)=E=Backlog(s,n)-Ship(s,n)+Dst(s,n);
 488  EndingBacklog(s,n)$(product_states(s) and ord(n) eq card(n)).. BacklogTerm
      inal(s)=E=Backlog(s,n)-Ship(s,n)+Dst(s,n);
 489   
 490  ***********UtilityBalance******
 491  UtilityLimit(u,n).. Uut(u,n)=L=Uutmax(u,n);
 492  UtilityBalance(u,n).. Uut(u,n)=E=sum((i,j,hbar)$(Ij(i,j) and (ord(hbar)-1 
      le pi_new(i)-1)),alpha_new(u,i)*Wbar(i,j,n,hbar)+beta_new(u,i)*Bbar(i,j,n,
      hbar)  );
 493   
 494  UnitUnavailabality(i,j,n)$(UnitUnavailable(j,n) and Ij(i,j)).. sum((hbar)$
      (ord(hbar)-1 le pi_new(i)-1),Wbar(i,j,n,hbar))=E=0;
 495   
 496  *Utility cost: sum((u,n),Cut(u,n)*Uut(u,n))
 497  *objective_MIN_COST.. obj_variable  =E= 1E1*sum(s,Cst_new(s)*SstTerminal(s
      )) +1E1*sum((s,n),Cst_new(s)*Sst(s,n))
 498  *                                 +1E2*sum((s,n)$(product_states(s)),Cst_n
      ew(s)*Backlog(s,n))+1E2*sum(s$(product_states(s)),Cst_new(s)*BacklogTermin
      al(s))
 499  *                                 +sum((i,j,hbar)$Ij(i,j),T(i,j,hbar));
 500  objective_MIN_COST.. obj_variable  =E= 1E1*sum(s,Cst_new(s)*SstTerminal(s)
      ) + 1E1*sum((s,n),Cst_new(s)*Sst(s,n))
 501                                   +1E2*sum((s,n)$(product_states(s)),Cst_ne
      w(s)*Backlog(s,n))
 502                                   +1E2*sum(s$(product_states(s)),Cst_new(s)
      *BacklogTerminal(s))
 503                                   +sum((i,j,n,hbar)$(Ij(i,j) AND ord(hbar)-
      1 eq 0),Wbar(i,j,n,hbar));
 504   
 505   
 506  *objective_MAX_PROFIT.. obj_variable =E= 1E1*sum(s$(product_states(s)),Cst
      _new(s)*SstTerminal(s))+1E1*sum((s,n)$(product_states(s)),Cst_new(s)*Ship(
      s,n))
 507  *                                       -1E2*sum((s,n)$(product_states(s))
      ,Cst_new(s)*Backlog(s,n))-1E2*sum(s$(product_states(s)),Cst_new(s)*Backlog
      Terminal(s) );
 508   
 509  *objective_MAX_PROFIT.. obj_variable =E= 1E1*sum((s,n)$(product_states(s))
      ,Cst_new(s)*Sst(s,n))+1E1*sum(s$(product_states(s)),Cst_new(s)*SstTerminal
      (s))
 510  *                                       -1E2*sum((s,n)$(product_states(s))
      ,Cst_new(s)*Backlog(s,n))-1E2*sum(s$(product_states(s)),Cst_new(s)*Backlog
      Terminal(s))
 511  *                                       +1E1*sum((s,n)$(product_states(s))
      ,Cst_new(s)*Ship(s,n));
 512   
 513  *objective_MAX_PROFIT.. obj_variable =E= sum((s,n)$(product_states(s)),rou
      nd(2-ord(n)/card(n),2)*Cst_new(s)*Ship(s,n))-sum((i,j,n,hbar)$(Ij(i,j) AND
       ord(hbar)-1 eq 0),Wbar(i,j,n,hbar));
 514   
 515  *objective_MAX_PROFIT.. obj_variable =E= sum((s,n)$(product_states(s)),Cst
      _new(s)*(Ship_sales(s,n)))
 516  *objective_MAX_PROFIT.. obj_variable =E= sum((s,n)$(product_states(s)),Cst
      _new(s)*(Ship_sales(s,n)+Ship(s,n)))
 517  objective_MAX_PROFIT.. obj_variable =E= sum((s,n)$(product_states(s)),Cst_
      new(s)*(Ship_sales(s,n)))
 518                                           -sum((i,j,n,hbar)$(Ij(i,j) AND or
      d(hbar)-1 eq 0),Wbar(i,j,n,hbar))
 519                                           -1E2*sum((s,n)$(product_states(s)
      ),Cst_new(s)*Backlog(s,n))
 520                                           -1E2*sum(s$(product_states(s)),Cs
      t_new(s)*BacklogTerminal(s));
 521   
 522  objective_MAX_PROFIT_Greedy.. obj_variable =E= sum((s,n)$(product_states(s
      )),round(2-(ord(n)/card(n)),2)*Cst_new(s)*(Ship(s,n)+Ship_sales(s,n)))
 523                                           -sum((i,j,n,hbar)$(Ij(i,j) AND or
      d(hbar)-1 eq 0),Wbar(i,j,n,hbar))
 524                                           -1E2*sum((s,n)$(product_states(s)
      ),Cst_new(s)*Backlog(s,n))
 525                                           -1E2*sum(s$(product_states(s)),Cs
      t_new(s)*BacklogTerminal(s));
 526  *Objective_makespan_min.. obj_variable =E= sum(ord(n)*W)
 527   
 528  *objective_MAX_PROFIT.. obj_variable =E= sum((s,n)$(product_states(s)),rou
      nd(2-ord(n)/card(n),2)*Cst_new(s)*Ship(s,n));
 529   
 530  *SHIPMENT(s,n).. Ship(s,n)=L=Dst(s,n)  ;
 531  InventoryBalance_MAX_PROFIT(s,n)$(ord(n) lt card(n)).. Sst(s,n+1)=E=Sst(s,
      n)
 532                           +sum((i,j,hbar)$(Tbars(i,s) and Ij(i,j) and (ord(
      hbar) -1 eq pis_new(i,s))),rhobar(i,s)*Bbar(i,j,n,hbar))
 533                           -sum((i,j,hbar)$(Ts(i,s) and Ij(i,j) and ord(hbar
      ) eq 1),rho(i,s)*Bbar(i,j,n,hbar))
 534                           -Ship_sales(s,n)$(product_states(s))-Ship(s,n)$(p
      roduct_states(s))+Rst(s,n)$(feed_states(s));
 535   
 536  EndingInventory_MAX_PROFIT(s,n)$(ord(n) eq card(n)).. SstTerminal(s)=E=Sst
      (s,n)
 537                           +sum((i,j,hbar)$(Tbars(i,s) and Ij(i,j) and (ord(
      hbar) -1 eq pis_new(i,s))),rhobar(i,s)*Bbar(i,j,n,hbar))
 538                           -sum((i,j,hbar)$(Ts(i,s) and Ij(i,j)and ord(hbar)
       eq 1),rho(i,s)*Bbar(i,j,n,hbar))
 539                           -Ship(s,n)$(product_states(s))-Ship_sales(s,n)$(p
      roduct_states(s))+Rst(s,n)$(feed_states(s));
 540   
 541  *Ship_constraint(s,n)$(ord(n) gt 1 AND ord(n) lt card(n) ).. Ship(s,n)=E=0
      ;
 542  *Ship_constraint(s,n)$(Dst(s,n) eq 0).. Ship_sales(s,n)=E=0;
 543  Ship_constraint(s,n)$(NOT Dst(s,n) gt 0).. Ship_sales(s,n)=E=0;
 544   
 545  *NoTaskRunningAtEndOfHorizon(i,j,n)$(ord(n) eq card(n) and Ij(i,j))..   su
      m(hbar$(ord(hbar)-1 le pi_new(i)-1),Wbar(i,j,n,hbar))=E=0;
 546  NoShip(s,n)$(ord(n) lt card(n)/2 and sameas(s,'M4')).. Ship_sales(s,n)=E=0
      ;
 547  *NoShip(s,n)$(ord(n) lt card(n)/2).. Ship_sales(s,n)=E=0;
 548   
 549  NoTaskStart(i,j,n,hbar)$(ord(n)-1 eq 0 AND ord(hbar)-1 eq 0).. Wbar(i,j,n,
      hbar)=E=0;
 550   
 551  *****************
 552  *DISTURBANCE VARIABLES
 553  *Build feature rich instances and do rigorous testing
 554  *****************
 555   
 556  SET attributes_states /W,B/;
 557  PARAMETERS
 558  record_states_raw(run,calc,attributes_states,i,j,n,hbar),
 559  record_states(run,calc,attributes_states,i,j,n,hbar),
 560  record_objective(run,calc),
 561  record_utility(run,calc,u,n),
 562  record_inventory(run,calc,s,n),
 563  record_inventory_raw(run,calc,s,n),
 564  record_backlog(run,calc,s,n),
 565  record_backlog_raw(run,calc,s,n),
 566  record_inventoryTerminal(run,calc,s),
 567  record_backlogTerminal(run,calc,s)
 568  record_T(run,calc,i,j,hbar)
 569  record_shipment(run,calc,s,n)
 570  record_shipment_sales(run,calc,s,n)
 571  record_shipment_sales_raw(run,calc,s,n)
 572  record_Rst(run,calc,s,n)
 573  record_shipment_raw(run,calc,s,n)
 574  record_Rst_raw(run,calc,s,n)
 575  record_yieldloss(run,calc,i,j,s,n)
 576  record_demands(run,calc,s,n)
 577  record_WbarInfo(run,calc,i,j,n,hbar)
 578  record_BbarInfo(run,calc,i,j,n,hbar)
 579  record_Demands_realization(run,s,h)
 580  record_fixed_decision(calc)
 581  record_reschedule_flag(calc,run)
 582  record_relaxed_objective(run,calc) Objective from solving RMIP
 583  record_relaxed_states(run,calc,attributes_states,i,j,n,hbar) states from s
      olving RMIP
 584  record_relaxed_shipment(run,calc,s,n)
 585  record_relaxed_shipment_sales(run,calc,s,n)
 586  record_relaxed_backlog(run,calc,s,n);
 587   
 588  record_states_raw(run,calc,attributes_states,i,j,n,hbar)=0;
 589  record_states(run,calc,'B',i,j,n,hbar)=0;
 590  record_states(run,calc,'W',i,j,n,hbar)=0;
 591  record_inventory(run,calc,s,n)=0;
 592  record_inventory_raw(run,calc,s,n)=0;
 593  record_backlog(run,calc,s,n)=0;
 594  record_backlog_raw(run,calc,s,n)=0;
 595  record_T(run,calc,i,j,hbar)=0;
 596  record_shipment(run,calc,s,n)=0 ;
 597  record_Rst(run,calc,s,n)=0;
 598  record_shipment_raw(run,calc,s,n)=0;
 599  record_shipment_sales_raw(run,calc,s,n)=0;
 600  record_shipment_sales(run,calc,s,n)=0;
 601  record_Rst_raw(run,calc,s,n)=0;
 602  record_yieldloss(run,calc,i,j,s,n)=0;
 603  record_demands(run,calc,s,n)=0;
 604  record_WbarInfo(run,calc,i,j,n,hbar)=0;
 605  record_BbarInfo(run,calc,i,j,n,hbar)=0;
 606  record_Demands_realization(run,s,h)=0;
 607  record_fixed_decision(calc)=0;
 608  record_reschedule_flag(calc,run)=0;
 609  record_relaxed_objective(run,calc)=0;
 610  record_relaxed_states(run,calc,attributes_states,i,j,n,hbar)=0;
 611  record_relaxed_shipment(run,calc,s,n)=0;
 612  record_relaxed_shipment_sales(run,calc,s,n)=0;
 613  record_relaxed_backlog(run,calc,s,n)=0;
 614   
 615  *Initial conditions for first optimization horizon
 616  PARAMETERS InitialBbar(i,j,n,hbar),InitialWbar(i,j,n,hbar),InitialInventor
      y(s),InitialBacklog(s);
 617  InitialBbar(i,j,n,hbar)=0;
 618  InitialWbar(i,j,n,hbar)=0;
 619  InitialInventory(s)=0;
 620  InitialBacklog(s)=0;
 621   
 622  *if (%InitialInventoryFlag% eq 1,
 623  *Start with half day of inventory
 624  *InitialInventory(s)$product_states(s)=12*demand_magnitude/demand_cycletim
      e;
 625  *);
 626  InitialInventory(s)$product_states(s)=0*demand_magnitude/demand_cycletime;
 627   
 628   
 629  *MODEL P1 /all/;
 630  MODEL MIN_COST /
 631  numberOfBatches,
 632  Allocation,
 633  UnitCapacityMax,
 634  UnitCapacityMin,
 635  *InventoryLimit,
 636  InventoryBalance,
 637  EndingInventory,
 638  BacklogBalance,
 639  EndingBacklog,
 640  *UtilityLimit,
 641  *UtilityBalance,
 642  *UnitUnavailabality,
 643  LiftingW,
 644  LiftingB,
 645  Carryover_W,
 646  Carryover_B,
 647  objective_MIN_COST/;
 648   
 649  MODEL MAX_PROFIT_1 /
 650  numberOfBatches,
 651  Allocation,
 652  UnitCapacityMax,
 653  UnitCapacityMin,
 654  Carryover_B
 655  InventoryBalance_MAX_PROFIT,
 656  LiftingW,
 657  BacklogBalance
 658  LiftingB,
 659  Carryover_W,
 660  objective_MAX_PROFIT
 661  Ship_constraint
 662  EndingInventory_MAX_PROFIT,
 663  EndingBacklog/;
 664   
 665  MODEL MAX_PROFIT_2 /
 666  numberOfBatches,
 667  Allocation,
 668  UnitCapacityMax,
 669  UnitCapacityMin,
 670  InventoryBalance_MAX_PROFIT,
 671  EndingInventory_MAX_PROFIT,
 672  BacklogBalance,
 673  EndingBacklog,
 674  LiftingW,
 675  LiftingB,
 676  Carryover_W,
 677  Carryover_B,
 678  objective_MAX_PROFIT
 679  Ship_constraint/;
 680   
 681  MODEL MAX_PROFIT_SellAnytime /
 682  numberOfBatches,
 683  Allocation,
 684  UnitCapacityMax,
 685  UnitCapacityMin,
 686  InventoryBalance_MAX_PROFIT,
 687  EndingInventory_MAX_PROFIT,
 688  BacklogBalance,
 689  EndingBacklog,
 690  LiftingW,
 691  LiftingB,
 692  Carryover_B,
 693  Carryover_W,
 694  objective_MAX_PROFIT
 695  NoTaskStart/;
 696  MODEL MAX_PROFIT_SellAnytime_Greedy /
 697  numberOfBatches,
 698  Allocation,
 699  UnitCapacityMax,
 700  UnitCapacityMin,
 701  InventoryBalance_MAX_PROFIT,
 702  EndingInventory_MAX_PROFIT,
 703  BacklogBalance,
 704  EndingBacklog,
 705  LiftingW,
 706  LiftingB,
 707  Carryover_B,
 708  Carryover_W,
 709  objective_MAX_PROFIT_Greedy /;
 710   
 711  MODEL MAX_PROFIT_GREEDY /
 712  numberOfBatches,
 713  Allocation,
 714  UnitCapacityMax,
 715  UnitCapacityMin,
 716  InventoryBalance_MAX_PROFIT,
 717  EndingInventory_MAX_PROFIT,
 718  BacklogBalance,
 719  EndingBacklog,
 720  LiftingW,
 721  LiftingB,
 722  Carryover_W,
 723  Carryover_B,
 724  *objective_MAX_PROFIT
 725  objective_MAX_PROFIT_Greedy
 726  Ship_constraint/;
 727  *NoShip/;
 728   
 729  MODEL MAX_PROFIT_NOSHIP /
 730  numberOfBatches,
 731  Allocation,
 732  UnitCapacityMax,
 733  UnitCapacityMin,
 734  InventoryBalance_MAX_PROFIT,
 735  EndingInventory_MAX_PROFIT,
 736  BacklogBalance,
 737  EndingBacklog,
 738  LiftingW,
 739  LiftingB,
 740  Carryover_W,
 741  Carryover_B,
 742  objective_MAX_PROFIT
 743  *objective_MAX_PROFIT_Greedy
 744  Ship_constraint
 745  NoShip/;
 746   
 747  MODEL MAX_PROFIT_GREEDY_NOSHIP /
 748  numberOfBatches,
 749  Allocation,
 750  UnitCapacityMax,
 751  UnitCapacityMin,
 752  InventoryBalance_MAX_PROFIT,
 753  EndingInventory_MAX_PROFIT,
 754  BacklogBalance,
 755  EndingBacklog,
 756  LiftingW,
 757  LiftingB,
 758  Carryover_W,
 759  Carryover_B,
 760  *objective_MAX_PROFIT
 761  objective_MAX_PROFIT_Greedy
 762  Ship_constraint
 763  NoShip/;
 764   
 765  *SHIPMENT/;
 766   
 767   
 768  T.l(i,j,hbar)=0;
 769  *Parameters for Gantt Charting in Excel
 770  *END OF MODEL FILE
 771   
 772   
 773   
 774   
 775  PARAMETER runcost(run) cost of implemented closed loop
 776           runcost_Inv(run) Inventory cost,runcost_BO(run) Backlog cost, run
      cost_W(run) start_cost_of_tasks
 777           runprofit(run) closed loop profit in MAX_profit
 778           sales_profit(run);
 779   
 780           runcost_Inv(run)=0;runcost_BO(run)=0; runcost_W(run)=0;runcost(ru
      n)=0; runprofit(run)=0;sales_profit(run)=0;
 781   
 782  PARAMETER modelStat(calc,run)     Should be 1 for successful optimization
 783            BOStat_OL(calc,run)     If 1 means open loop had non zero back o
      rder
 784            BOStat_CL(calc,run)     If 1 means closed loop had non zero back
       order
 785            IntegralityGap(calc,run)
 786            Est_modelGap1(calc,run)  Estimated optimality gap by CPLEX (obj.
      val in denominator)
 787            Est_modelGap2(calc,run)  Estimated optimality gap by CPLEX (obj.
      Est in denominator)
 788            True_modelGap(calc,run) True optimality gap obtained by solving 
      to optcr=0
 789            ETSolve(calc,run)
 790            ETSolver(calc,run)
 791            iterUsd(calc,run)
 792            nodUsd(calc,run)
 793            resUsd(calc,run)
 794            numDVar(calc,run)
 795            numEqu(calc,run)
 796            numInfes(calc,run)
 797            numNZ(calc,run)
 798            numVar(calc,run)
 799            solveStat(calc,run)
 800            Suboptimal_objective /0/
 801            Optimal_Objective /0/
 802            TimeToSolveOptimal(calc,run);
 803   
      ********************DEMAND SAMPLING TO KEEP IT STANDARDIZED FOR ALL APPROA
      CHES(NOMINAL, ROBUST, STOCHASTIC)************************
      ******DEMAND INFORMATION*****************************
      *Each order for all products
      SET         o orders /o1*o%H%/;
      PARAMETER deliveries_time(o,run);
      deliveries_time(o,run)=demand_cycletime*ord(o);
      PARAMETER deliveries(o,s);
      deliveries(o,s)$(product_states(s))=demand_magnitude;
      ******DEMAND INFORMATION*****************************
       
      PARAMETER Dst_full(s,h);
      Dst_full(s,h)=sum(o,deliveries(o,s)$(ord(h)-1 eq floor(deliveries_time(o)/
      %delta%)));
       
      PARAMETER Dst_full_realization(s,h,run);
      Dst_full_realization(s,h,run)=Dst_full(s,h);
       
      *IF(%Demand_Disturbance_flag% eq 1,
               LOOP(run,
                  deliveries_time(o,run)=deliveries_time(o,run)+UniformInt(-dema
      nd_variation,demand_variation);
                  Dst_full_realization(s,h,run)=(Dst_full(s,h)+Dst_full(s,h)*uni
      formInt(-lambda_Demand,lambda_Demand)  )$(Dst_full(s,h) gt 0);
               );
      *);
      ********************DEMAND SAMPLING TO KEEP IT STANDARDIZED FOR ALL APPROA
      CHES(NOMINAL, ROBUST, STOCHASTIC)************************
 829  ********************DEMAND SAMPLING TO KEEP IT STANDARDIZED FOR ALL APPROA
      CHES(NOMINAL, ROBUST, STOCHASTIC)************************
 830  ******DEMAND INFORMATION*****************************
 831  *Each order for all products
 832  SET         o orders /o1*o216/;
 833  PARAMETER deliveries_time(o,run);
 834  deliveries_time(o,run)=demand_cycletime*ord(o);
 835  PARAMETER deliveries(o,s);
 836  deliveries(o,s)$(product_states(s))=demand_magnitude;
 837  ******DEMAND INFORMATION*****************************
 838   
 839  PARAMETER Dst_full_realization(s,h,run),Dst_full(s,h);
 840   
 841  *IF(%Demand_Disturbance_flag% eq 1,
 842  LOOP(run,
 843    deliveries_time(o,run)=deliveries_time(o,run)+UniformInt(-demand_variati
      on,demand_variation);
 844    Dst_full_realization(s,h,run)=sum(o,deliveries(o,s)$(ord(h)-1 eq floor(d
      eliveries_time(o,run)/1)));
 845    Dst_full_realization(s,h,run)=(Dst_full_realization(s,h,run)+Dst_full_re
      alization(s,h,run)/100*uniformInt(-lambda_Demand*100,lambda_Demand*100)  )
      $(Dst_full_realization(s,h,run) gt 0);
 846  );
 847  Dst_full_realization(s,h,run)$(ord(h)-1 gt 10)=0;
 848  *);
 849  ********************DEMAND SAMPLING TO KEEP IT STANDARDIZED FOR ALL APPROA
      CHES(NOMINAL, ROBUST, STOCHASTIC)************************
 850   
 851   
 852  PARAMETER ClosedLoopINV(run,s,h),ClosedLoopBO(run,s,h),ClosedLoopShip(run,
      s,h),ClosedLoopShip_sales(run,s,h),
 853            ClosedLoopStart(run,h),Cost_EndInventory(run),ClosedLoopExecutio
      ns(run,i);
 854  ClosedLoopINV(run,s,h)=0;
 855  ClosedLoopBO(run,s,h)=0;
 856  ClosedLoopShip(run,s,h)=0;
 857  ClosedLoopShip_sales(run,s,h)=0;
 858  ClosedLoopStart(run,h)=0;
 859  Cost_EndInventory(run)=0;
 860  ClosedLoopExecutions(run,i)=0;
 861  *This parameter switches to 1 at end of this file
 862  *indicating a succesful run(sweep of code) throughout
 863  PARAMETER SUCCESS /0/;
 864   
 865   
 866  PARAMETER timeLeft /0/;
 867  PARAMETER endingSeed /0/;
 868  *PARAMETER sample /0/;
 869   
 870  ********************STOPPING CRITERION*************
      PARAMETER mean_runcost(run), std_dev_runcost(run), delta_std_dev_runcost(r
      un), max_delta_std_dev_runcost(run), N_run count of runs;
      mean_runcost(run)=0;
      std_dev_runcost(run)=0;
      delta_std_dev_runcost(run)=0;
      max_delta_std_dev_runcost(run)=0;
      N_run=0;
      ALIAS(run,run_p);
      ********************STOPPING CRITERION*************
 881   
 882  ********************[Start] Evaluations Runs *****************************
      **********
 883  loop(run,
      put screen;
      put 'I am on run ' run.tl;
      putclose;
      put log;
      put 'I am on run ' run.tl;
      putclose;
 892   
 893  *We need to reset Dst_full(s,h) with each run to nominal values
 894  *and then as MH goes forward, Dst_full slowly takes the value of Dst_full_
      realization
 895  *for that particular run, after which here we need to refresh it to nomina
      l values
 896  Dst_full(s,h)=sum(o,deliveries(o,s)$(ord(h)-1 eq floor(deliveries_time(o,r
      un)/1)));
 897   
 898  if(0 eq 1,
 899  abort$1 "Look into robust case demand generation in MasterFile and make su
      re its correct";
 900           Dst_full(s,h)=Dst_full(s,h)*(1+ lambda_Demand);
 901  );
 902  *this time sample is equal to 1, so we are in evaluation mode
 903   
 904  ********CLOSED-LOOP SOLUTION*********
INCLUDE    C:\Users\dhruv\Box Sync\Work\Codes\GAMS_Code\ModelSolution9.gms
 906  OPTIONS limrow = 0, limcol = 0, solprint = off;
 907  *OPTIONS limrow = 1000, limcol = 1000, solprint = on;
 908  *No upper limit on inventory (equation not enforced)
 909   
 910  loop(calc,
 911  *Caution: Watch out W equations in case changeovers are involved with rega
      rds to lifting(pi(i)+tauC)
 912  *fixed_decisions=re_freq-1-mod(ord(calc)-1+re_freq-1,re_freq);
 913  *abort$1 "stopped for debugging";
 914  *abort$(ord(calc)-1 eq 1) "stopped for debugging";
 915   
      IF(ord(calc)-1 eq 4,
      rhobar('T2','M3')=0.79;
      rhobar('T2','M2')=0.21;
      *T2.(M3 0.8,M2 0.2)
      );
 923   
 924  *********VARIABLE RESCHEDULING FREQUENCY********
 925  *resetting old parameter values
 926  WbarInfo(i,j,n,hbar)=0;
 927  BbarInfo(i,j,n,hbar)=0;
 928   
 929  *DEMAND SAMPLING
 930  *Picking realized demand upto surprise factor within MH from demand_sample
       generated for this run
 931          Dst_full(s,h)$(ord(h)-1 le (ord(calc)-1 + ceil(card(n)*(1-surprise
      ))) ) = Dst_full_realization(s,h,run);
 932  *Now allocating demands to the rolling horizon calculation
 933          Dst(s,n)=sum(h$((ord(h)-1) eq (ord(n)-1+ord(calc)-1)),Dst_full(s,h
      ));
 934   
 935   
      * EVENT BASED RESCHEDULING (HAS BUG: when moving horizon is shorter than r
      escheduling freq, more decisions
      *are wrongly fixed)
      if (re_freq=0,
      *Reschedule flag is 1 for first optimization
              reschedule_flag=0;
      *Now see if we should reschedule or not depending on whether new demand ca
      me or not
              reschedule_flag=1$(sum((s,n)$(ord(n) eq card(n)),Dst(s,n)) > 0);
      *Also do find schedule for the very first optimization
              reschedule_flag$(ord(calc)-1 eq 0)=1;
      *Now decide the fixed decisions (W,B) depending on rescheduling_flag
              if (reschedule_flag=1,
      *Complete freedom to start new tasks (subject to old tasks not already run
      ning)
                      fixed_decisions=0;
              else
      *Forced to follow previous fixed (planned) decisions
                      fixed_decisions=card(n)-1;
              );
      else
 956          fixed_decisions=re_freq-1 - mod(ord(calc)-1+(re_freq-1),re_freq);
 957          reschedule_flag=0;
 958          reschedule_flag$(fixed_decisions=0)=1;
 959  *);
 960  record_fixed_decision(calc)=fixed_decisions;
 961  record_reschedule_flag(calc,run)=reschedule_flag;
 962   
 963  *Unfix fixed variables
 964  Ship.lo(s,n)=0;Ship.up(s,n)=Inf;
 965  Rst.lo(s,n)=0;Rst.up(s,n)=Inf;
 966  Ship_sales.lo(s,n)=0;Ship_sales.up(s,n)=Inf;
 967  *Uut.lo(u,n)=0; Uut.up(u,n)=Inf;
 968  *Fix Input states
 969  WbarInfo(i,j,n,hbar)$(ord(n)-1 le fixed_decisions and ord(hbar)-1 le pi(i)
       and Ij(i,j))=record_states(run,calc-1,'W',i,j,n,hbar-1)+InitialWbar(i,j,n
      ,hbar)$(ord(calc)-1 eq 0)+Yhat(i,j,n,hbar)-Yhat(i,j,n,hbar-1);
 970  BbarInfo(i,j,n,hbar)$(ord(n)-1 le fixed_decisions and ord(hbar)-1 le pi(i)
       and Ij(i,j))=record_states(run,calc-1,'B',i,j,n,hbar-1)+InitialBbar(i,j,n
      ,hbar)$(ord(calc)-1 eq 0)+record_states(run,calc-1,'B',i,j,n,hbar)*Yhat(i,
      j,n,hbar)-record_states(run,calc-1,'B',i,j,n,hbar-1)*Yhat(i,j,n,hbar-1);
 971  Ship.fx(s,n)$(ord(n)-1 le fixed_decisions-1)=record_shipment(run,calc-1,s,
      n+1);
 972  Rst.fx(s,n)$(ord(n)-1 le fixed_decisions-1)=record_Rst(run,calc-1,s,n+1);
 973  Ship_sales.fx(s,n)$(ord(n)-1 le fixed_decisions-1)=record_shipment_sales(r
      un,calc-1,s,n+1);
 974  T.fx(i,j,hbar)=0;
 975  *********VARIABLE RESCHEDULING FREQUENCY********
 976  *(Variable rescheduling frequency does not extend to disturbances other th
      an demand)
 977   
 978  *Since inventory and backlog depend on the inputs, as long as we have corr
      ectly carried over the inventory we are good
 979  Sst.fx(s,n)$(ord(n)-1 le 0)=record_inventory(run,calc-1,s,n+1)+InitialInve
      ntory(s)$(ord(calc)-1 eq 0);
 980  Backlog.fx(s,n)$(ord(n)-1 le 0)=record_backlog(run,calc-1,s,n+1)+InitialBa
      cklog(s)$(ord(calc)-1 eq 0);
 981  *Uut.fx(u,n)$(ord(n)-1 le 0)=record_utility(run,calc-1,u,n+1);
 982   
 983   
 984  *Fix backlogs to zero if corresponding flag is 0
 985  if(1 eq 0,
 986  Backlog.fx(s,n)=0;
 987  BacklogTerminal.fx(s)=0;
 988  );
 989  *Dst(s,n)$(product_states(s) AND ord(n) eq 1) = 1;
 990  *Ship_sales.fx(s,n)$(ord(n)-1 eq 0 AND sameas(s,'M4')) = 8.05;
 991  *Ship_sales.fx(s,n)$(ord(n) lt card(n)) = 0;
 992   
 993  *cc=execseed;
 994  ***************SAMPLING DISTURBANCES/UNCERTAINTIES************************
      ******
 995  *Introducing disturbance in demand by modifying Dst_full(s,h) only if Dist
      urbance flag is 1(on)
 996  *if(%Demand_Disturbance_Flag% eq 1,
 997  *);
 998   
 999  **UNCOMMENT HERE TO HERE  (commented for event based rescheduling)
1000  **        Dst_full(s,h)$(ord(h)-1 le (ord(calc)-1 + ceil(card(n)*(1-surpri
      se))) )=Dst_full_realization(s,h,run);
1001  *Now allocating demands to the rolling horizon calculation
1002  *        Dst(s,n)=sum(h$((ord(h)-1) eq (ord(n)-1+ord(calc)-1)),Dst_full(s,
      h));
1003  **UNCOMMENT HERE TO HERE
1004  *Display Dst_full;
1005   
1006   
1007  *UnitBreakdown disturbance
1008  *First breakdown unit for whole horizon and then sample after 1 time step
1009  *when it is coming back
1010  UnitBroken(j,n)=0;
1011  Zhat(i,j,n,hbar)=0;
1012  if(0 eq 1 and ord(calc)-1 ge 2,
1013           Breakdown(calc,i,j,hbar)$(Ij(i,j) and ord(hbar)-1 le pi(i) and De
      lay(calc-1,i,j,hbar-1) eq 0)=1$(uniform(0,1) le lambda_UnitBreakdown and D
      uration_breakdown(calc-1,j) eq 0 and (sum(n$(ord(n)-1 eq 0),record_states(
      run,calc-1,'W',i,j,n,hbar-1)) gt 0));
1014   
1015  *If there is a delay ongoing then sample this breakdown
1016           Breakdown(calc,i,j,hbar)$(Ij(i,j) and ord(hbar)-1 le pi(i) and De
      lay(calc-1,i,j,hbar) gt 0)=1$(uniform(0,1) le lambda_UnitBreakdown and Dur
      ation_breakdown(calc-1,j) eq 0 and (sum(n$(ord(n)-1 eq 0),record_states(ru
      n,calc-1,'W',i,j,n,hbar)) gt 0));
1017   
1018  *Assume on breakdown that the unit by default is not available the whole r
      emaining horizon and then
1019  *resample after one time step when it is due to come back[here half of rol
      ling horizon length]
1020   
1021  *         Duration_breakdown(calc,j)=floor(uniform(0,card(n)/2))$(sum((hba
      r,i)$(Ij(i,j) and ord(hbar)-1 le pi(i)),Breakdown(calc-1,i,j,hbar)) eq 1 a
      nd Duration_breakdown(calc-1,j) eq (card(h)))
1022  *                                         +(Duration_breakdown(calc-1,j)-1
      )$(Duration_breakdown(calc-1,j) gt 0 and Duration_breakdown(calc-1,j) lt c
      ard(h))
1023  *                                         +card(h)$(sum((hbar,i)$(Ij(i,j) 
      and ord(hbar)-1 le pi(i)),Breakdown(calc,i,j,hbar)) eq 1);
1024           Duration_breakdown(calc,j)=time_to_bring_unit_back_online$(sum((h
      bar,i)$(Ij(i,j) and ord(hbar)-1 le pi(i)),Breakdown(calc-1,i,j,hbar)) eq 1
       and Duration_breakdown(calc-1,j) eq (card(h)))
1025                                           +(Duration_breakdown(calc-1,j)-1)
      $(Duration_breakdown(calc-1,j) gt 0 and Duration_breakdown(calc-1,j) lt ca
      rd(h))
1026                                           +(card(h))$(sum((hbar,i)$(Ij(i,j)
       and ord(hbar)-1 le pi(i)),Breakdown(calc,i,j,hbar)) eq 1);
1027  *display Breakdown,duration_breakdown;
1028   
1029           UnitBroken(j,n)=0;
1030           UnitBroken(j,n)$(ord(n)-1 lt Duration_breakdown(calc,j))=1;
1031   
1032           Zhat(i,j,n,hbar)=0;
1033           Zhat(i,j,n,hbar)$(ord(n)-1 eq 0 and Breakdown(calc,i,j,hbar) eq 1
      )=1;
1034   
1035  );
1036   
1037   
1038   
1039  *Disturbance associated with delay in tasks, hbar indicates the running st
      atus of the task
1040  *Due to nature of lifting, there is already a 1 time unit lag, hence we li
      mit hbar from 0 to pi(i)
1041  *so that recordstates is accessed only upto pi(i)-1. Record state being pi
      (i) means that the task
1042  *was already over in the last horizon
1043  if(0 eq 1,
1044  *          Delay(calc,i,j,hbar)$(Ij(i,j) and ord(hbar)-1 le pi(i))=(Delay(
      calc-1,i,j,hbar)-1)$(Delay(calc-1,i,j,hbar) ge 1)
1045  *                                                            +2$(uniform(0
      ,1) ge 0 and (sum(n$(ord(n)-1 eq 0),record_states(calc-1,'W',i,j,n,hbar-1)
      ) gt 0) and Delay(calc-1,i,j,hbar-1) eq 0);
1046            Delay(calc,i,j,hbar)$(Ij(i,j) and ord(hbar)-1 le pi(i))=(Delay(c
      alc-1,i,j,hbar)-1)$(Delay(calc-1,i,j,hbar) ge 1);
1047            Delay(calc,i,j,hbar)$(Ij(i,j) and ord(hbar)-1 le pi(i) and Delay
      (calc-1,i,j,hbar) eq 0)=default_delay_length$(uniform(0,1) ge 0.6 and (sum
      (n$(ord(n)-1 eq 0),record_states(run,calc-1,'W',i,j,n,hbar-1)) gt 0 and De
      lay(calc-1,i,j,hbar-1) eq 0));
1048  *          Delay(calc,i,j,hbar)$(Ij(i,j) and ord(n)-1 eq 0)=(Delay(calc-1,
      i,j,hbar)-1)$(Delay(calc-1,i,j,hbar) gt 0)
1049  *          Yhat(i,j,n,hbar)$(Ij(i,j) and ord(n)-1 eq 0)=1$(uniform(0,1) gt
       0 and record_states(calc-1,'W',i,j,n,hbar-1) gt 0);
1050   
1051  *display Delay;
1052  *Wipes out previous Yhats
1053            Yhat(i,j,n,hbar)=0;
1054  *Over-rides Delays with Unit breakdown. ie if unit breakdown occurs then t
      here cannot be a delay
1055            Delay(calc,i,j,hbar)=Delay(calc,i,j,hbar)$(sum(n$(ord(n)-1 eq 0)
      ,Zhat(i,j,n,hbar)+Zhat(i,j,n,hbar+1)) eq 0);
1056  *          Yhat(i,j,n,hbar)$(Ij(i,j) and ord(n)-1 eq 0)=1$(Delay(calc,i,j,
      hbar) gt 0);
1057            Yhat(i,j,n,hbar)$(Ij(i,j) and ord(n)-1 lt Delay(calc,i,j,hbar))=
      1$(Delay(calc,i,j,hbar) gt 0);
1058   
1059  *          Yhat(i,j,n,hbar)$(Ij(i,j) and ord(n)-1 eq 0 and ord(hbar)-1 le 
      pi(i))=1$(uniform(0,1) ge 0 and record_states(calc-1,'W',i,j,n,hbar) gt 0)
      ;
1060  *          WbarInfo(i,j,n,hbar)$Yhat(i,j,n,hbar)=1;
1061  *          BbarInfo(i,j,n,hbar)$Yhat(i,j,n,hbar)=record_states(calc-1,'W',
      i,j,n,hbar);
1062  );
1063   
1064  *display Yhat;
1065  *display WbarInfo;
1066  *display BbarInfo;
1067   
1068   
1069  *Introducing disturbance in material handling(loading/unloading)
1070  *Here we implement only production disturbance because its more likely tha
      n consumption disturbance
1071  *Consumption disturbance has the tricky part that if loading was 5 units, 
      and we had just 5 units, the task is already started and we cant
1072  *then add a disturbance on top of it saying 5.5 units was actually consume
      d because the task has already started.
1073  if(1 eq 1,
1074  *the last two multiplication of (1-z(h+1))(1-z(h)) are when there are only
       unit breakdown, and when there is unit breakdown in middle of delay respe
      ctively
1075  *betaHatProd(i,j,s,n)$(Tbars(i,s) and Ij(i,j) and ord(n)-1 eq 0 and produc
      t_states(s))=uniform(-0.1,0)*sum(hbar$(ord(hbar) -1 eq pis_new(i,s)-1),rec
      ord_states(calc-1,'B',i,j,n,hbar)*(1-Yhat(i,j,n,hbar+1))*(1-Zhat(i,j,n,hba
      r+1))*(1-Zhat(i,j,n,hbar)));
1076  *wipes out previous parameter values
1077  betaHatProd(i,j,s,n)=0;
1078   
1079  *betaHatProd(i,j,s,n)$(Tbars(i,s) and Ij(i,j) and ord(n)-1 eq 0)=uniform(-
      0.1,0)*sum(hbar$(ord(hbar) -1 eq pis_new(i,s)),BbarInfo(i,j,n,hbar)*(1-Yha
      t(i,j,n,hbar))*(1-Zhat(i,j,n,hbar))*(1-Zhat(i,j,n,hbar-1)));
1080   
1081  betaHatProd(i,j,s,n)$(sameas(i,'T2') and Tbars(i,s) and Ij(i,j) and ord(n)
      -1 eq 0)=-0.01*sum(hbar$(ord(hbar) -1 eq pis_new(i,s)),BbarInfo(i,j,n,hbar
      )*(1-Yhat(i,j,n,hbar))*(1-Zhat(i,j,n,hbar))*(1-Zhat(i,j,n,hbar-1)));
1082  *betaHatProd(i,j,s,n)$(Tbars(i,s) and Ij(i,j) and ord(n)-1 eq 0)=uniform(-
      0.1,0)*sum(hbar$(ord(hbar) -1 eq pis_new(i,s)-1),record_states(calc-1,'B',
      i,j,n,hbar)*(1-Yhat(i,j,n,hbar+1))*(1-Zhat(i,j,n,hbar)));
1083  *betaHatProd(i,j,s,n)$(Tbars(i,s) and Ij(i,j) and ord(n)-1 eq 0)=uniform(-
      0.1,0)*sum(hbar$(ord(hbar) -1 eq pis_new(i,s)-1),record_states(calc-1,'B',
      i,j,n,hbar));
1084  );
1085  *Display betaHatProd;
1086   
1087   
1088  *Correct allocation constraint
1089  *KillDurationCountdown(i,j)$Ij(i,j)=%KillSwitch%$(sum(hbar,T.l(i,j,hbar)) 
      gt 0);
1090  KillOccupy(j,n)=0;
1091  KillDuration(i,j)$Ij(i,j)=KillLength$(0);
1092  *KillDuration(i,j)$Ij(i,j)=(%KillSwitch%+1)$(sum(hbar,T.l(i,j,hbar)) gt 0 
      and KillDuration(i,j) eq 0);
1093  *KillDuration(i,j)$(Ij(i,j) and KillDuration(i,j) <> 0)=KillDuration(i,j)-
      1;
1094  KillCountdown(j)=sum((i,hbar)$Ij(i,j),T.l(i,j,hbar)*KillDuration(i,j))  +(
      KillCountdown(j)-1)$(KillCountdown(j) gt 0);
1095  KillOccupy(j,n)$(ord(n)-1 lt KillCountdown(j)-1)=1;
1096  if(0 eq 0,
1097     T.fx(i,j,hbar)=0;
1098  );
1099  *Display Breakdown,Duration_breakdown,UnitBroken,Zhat,KillOccupy;
1100  ***************SAMPLING DISTURBANCES/UNCERTAINTIES************************
      ******
1101   
1102  ***************UTILITIES**************************************************
      ******
1103  Uutmax(u,n)=sum(h$((ord(h)-1) eq (ord(n)-1+ord(calc)-1)),Uutmax_full(u,h))
      ;
1104  Unitunavailable(j,n)=sum(h$((ord(h)-1) eq (ord(n)-1+ord(calc)-1)),Unitunav
      ailable_full(j,h));
1105  Cut(u,n)=sum(h$((ord(h)-1) eq (ord(n)-1+ord(calc)-1)),Cut_full(u,h));
1106  *Correct Cutfull calculation, all the relation of taking hours to time poi
      nts
1107  *This correction is needed in model file
1108  ***************UTILITIES**************************************************
      ******
1109  *Display Dst;
1110   
1111  *abort$(sameas(calc,"calc25")) "stopped for debugging";
1112  *Solve optimization horizon
1113   
1114  Option IntVarUp=0;
1115  *******************FIND OPEN LOOP SCHEDULE********************************
      ******
1116  MIN_COST.optcr = optcr_value$(reschedule_flag)+1$(NOT reschedule_flag);
1117  MIN_COST.reslim = timelimit;
1118  MIN_COST.holdFixed=1;
1119  solve MIN_COST using MIP MINIMIZING obj_variable;
1120   
1121  modelStat(calc,run)=MIN_COST.ModelStat;
1122  *Watch out what should be denominator, Relaxed or Best found solution
1123  *Cplex uses division by best found integer solution
1124  Est_modelGap1(calc,run)=abs((MIN_COST.objEst-MIN_COST.objVal)/(MIN_COST.ob
      jVal+1E-10));
1125  Est_modelGap2(calc,run)=abs((MIN_COST.objEst-MIN_COST.objVal)/(MIN_COST.ob
      jEst+1E-10));
1126  Suboptimal_objective=MIN_COST.objVal;
1127   
1128  ETSolve(calc,run)=MIN_COST.etSolve;
1129  ETSolver(calc,run)=MIN_COST.etSolver;
1130  iterUsd(calc,run)=MIN_COST.iterUsd;
1131  nodUsd(calc,run)=MIN_COST.nodUsd;
1132  resUsd(calc,run)=MIN_COST.resUsd;
1133  numDVar(calc,run)=MIN_COST.numDVar;
1134  numEqu(calc,run)=MIN_COST.numEqu;
1135  numInfes(calc,run)=MIN_COST.numInfes;
1136  numNZ(calc,run)=MIN_COST.numNZ;
1137  numVar(calc,run)=MIN_COST.numVar;
1138  solveStat(calc,run)=MIN_COST.solveStat;
1139   
1140  *Recording optimized variables for each optimization horizon
1141  record_states_raw(run,calc,'B',i,j,n,hbar)$(ord(hbar)-1 le pi(i) and Ij(i,
      j))= Bbar.l(i,j,n,hbar);
1142  record_states_raw(run,calc,'W',i,j,n,hbar)$(ord(hbar)-1 le pi(i) and Ij(i,
      j))= Wbar.l(i,j,n,hbar);
1143  record_states(run,calc,'B',i,j,n,hbar)$(ord(hbar)-1 le pi(i) and Ij(i,j))=
       round(Bbar.l(i,j,n,hbar),2)$(Bbar.l(i,j,n,hbar) ge vminij(i,j)+Small_numb
      er and Bbar.l(i,j,n,hbar) le vmaxij(i,j)-Small_number) + round(Bbar.l(i,j,
      n,hbar))$(NOT (Bbar.l(i,j,n,hbar) ge vminij(i,j)+Small_number and Bbar.l(i
      ,j,n,hbar) le vmaxij(i,j)-Small_number));
1144  record_states(run,calc,'W',i,j,n,hbar)$(ord(hbar)-1 le pi(i) and Ij(i,j))=
       round(Wbar.l(i,j,n,hbar));
1145  record_T(run,calc,i,j,hbar)$(ord(hbar)-1 le pi(i) and Ij(i,j))= T.l(i,j,hb
      ar);
1146  record_inventory(run,calc,s,n)=round(Sst.l(s,n),3);
1147  record_backlog(run,calc,s,n)=round(Backlog.l(s,n),3);
1148  record_inventory_raw(run,calc,s,n)=Sst.l(s,n);
1149  record_backlog_raw(run,calc,s,n)=Backlog.l(s,n);
1150  record_yieldloss(run,calc,i,j,s,n)=betaHatProd(i,j,s,n);
1151  record_objective(run,calc)=obj_variable.l;
1152  record_utility(run,calc,u,n)=Uut.l(u,n);
1153  record_inventoryTerminal(run,calc,s)=SstTerminal.l(s);
1154  record_backlogTerminal(run,calc,s)=BacklogTerminal.l(s);
1155  record_shipment_raw(run,calc,s,n)=Ship.l(s,n);
1156  record_shipment(run,calc,s,n)=round(Ship.l(s,n),2);
1157  record_shipment_sales_raw(run,calc,s,n)=Ship_sales.l(s,n);
1158  record_shipment_sales(run,calc,s,n)=round(Ship_sales.l(s,n),2);
1159  record_Rst_raw(run,calc,s,n)=Rst.l(s,n);
1160  record_Rst(run,calc,s,n)=round(Rst.l(s,n),2);
1161  record_demands(run,calc,s,n)=Dst(s,n);
1162  record_Demands_realization(run,s,h)=Dst_Full_Realization(s,h,run);
1163   
1164  record_WbarInfo(run,calc,i,j,n,hbar)=WbarInfo(i,j,n,hbar);
1165  record_BbarInfo(run,calc,i,j,n,hbar)=BbarInfo(i,j,n,hbar);
1166   
1167  BOStat_OL(calc,run) =  1$(sum((s,n),record_backlog(run,calc,s,n)+record_ba
      cklogTerminal(run,calc,s)) > 0);
1168  BOStat_CL(calc,run) =  1$(sum((s,n)$(ord(n)-1 eq 0),record_backlog(run,cal
      c,s,n)) > 0);
1169   
1170  *display ship.l;
1171  Optimal_Objective=Suboptimal_Objective;
1172  ***********************FIND OPTIMAL OBJECTIVE IF OPTCR <>0****************
      *
1173  IF(MIN_COST.optcr <> 0 AND reschedule_flag eq 1,
      put screen;
      put 'Now solving optimal open loop';
      putclose;
1179  MIN_COST.optcr=0;
1180  solve MIN_COST using MIP MINIMIZING obj_variable;
1181  Optimal_Objective=MIN_COST.objVal;
1182  True_modelGap(calc,run)=(Suboptimal_objective-Optimal_Objective)/(Optimal_
      objective+1E-10);
1183  TimeToSolveOptimal(calc,run)=MIN_COST.resUsd;
1184  );
1185   
1186  ***********************FIND OPTIMAL OBJECTIVE IF OPTCR <>0****************
      *
1187   
1188  ******WARNING: ALL VARIABLE LEVEL VALUES ARE THOSE OF OPTCR=0 NOW*********
      *
1189   
1190  IF (reschedule_flag eq 1,
1191  ***********************SOLVE RMIP TO GET INTEGRALITY GAP*****************
1192  solve MIN_COST using RMIP MINIMIZING obj_variable;
1193  record_relaxed_objective(run,calc)=obj_variable.l;
1194  IntegralityGap(calc,run)=record_relaxed_objective(run,calc)/(Optimal_Objec
      tive+1E-10);
1195  record_relaxed_states(run,calc,'B',i,j,n,hbar)$(ord(hbar)-1 le pi(i) and I
      j(i,j))= Bbar.l(i,j,n,hbar);
1196  record_relaxed_states(run,calc,'W',i,j,n,hbar)$(ord(hbar)-1 le pi(i) and I
      j(i,j))= Wbar.l(i,j,n,hbar);
1197  record_relaxed_shipment(run,calc,s,n)=Ship.l(s,n);
1198  record_relaxed_shipment_sales(run,calc,s,n)=Ship_sales.l(s,n);
1199  record_relaxed_backlog(run,calc,s,n)=Backlog.l(s,n);
1200  );
1201  ***********************SOLVE RMIP TO GET INTEGRALITY GAP*****************
1202   
1203  ******WARNING: ALL VARIABLE LEVEL VALUES ARE THOSE OF RMIP NOW**********
1204   
1205  );
1206  **END OF CALC LOOP HERE
1207   
1208  *END OF SOLUTION FILE
1209   
1210   
1211   
1212  ********STORING CL-SOLUTION IN RECOGNIZABLE PARAMETERS FOR EASY ACCESS AND
       ANALAYSIS*******
1213  loop((n,calc)$(ord(n)-1 eq 0),
1214           ClosedLoopINV(run,s,h)$(ord(h) eq ord(calc))=record_inventory(run
      ,calc,s,n);
1215           ClosedLoopBO(run,s,h)$(ord(h) eq ord(calc))=record_backlog(run,ca
      lc,s,n);
1216           ClosedLoopShip(run,s,h)$(ord(h) eq ord(calc))=record_shipment(run
      ,calc,s,n);
1217           ClosedLoopShip_sales(run,s,h)$(ord(h) eq ord(calc))=record_shipme
      nt_sales(run,calc,s,n);
1218           ClosedLoopStart(run,h)$(ord(calc) eq ord(h))=sum((i,j,hbar)$(Ij(i
      ,j) AND ord(hbar)-1 eq 0),record_states(run,calc,'W',i,j,n,hbar));
1219  *         ClosedLoopStart(run,h)$(ord(calc) eq ord(h))=0;
1220  );
1221           ClosedLoopExecutions(run,i)=sum((calc,j,n,hbar)$(Ij(i,j) AND ord(
      hbar)-1 eq 0
1222                                           AND ord(n)-1 eq 0 AND ord(calc)-1
       le 6-1),
1223                                           record_states(run,calc,'W',i,j,n,
      hbar));
1224   
1225  *         runcost_Inv(run)=1E1*sum((s,h)$closed_loop(h),Cst_new(s)*Sinv(s,
      h));
1226  *         runcost_BO(run)=1E2*sum((s,h)$closed_loop(h),Cst_new(s)*BO(s,h))
      ;
1227           runcost_Inv(run)=1E1*sum((s,h)$closed_loop(h),Cst_new(s)*ClosedLo
      opINV(run,s,h));
1228           runcost_BO(run)=1E2*sum((s,h)$closed_loop(h),Cst_new(s)*ClosedLoo
      pBO(run,s,h));
1229           runcost_W(run)=sum((h)$closed_loop(h),ClosedLoopStart(run,h));
1230  *total profit from all shipments (demand+sales)
1231   
1232           runcost(run)=runcost_Inv(run)+runcost_BO(run)+runcost_W(run);
1233   
1234  *         sales_profit(run)=sum( (s,h)$(product_states(s) and closed_loop(
      h) and (ord(h)-1 ne %Closed_Loop_Upper_delta%) ),
1235  *                                 Cst_new(s)*(ClosedLoopShip(run,s,h)+Clos
      edLoopShip_sales(run,s,h) ));
1236           sales_profit(run)=sum( (s,h)$(product_states(s) and closed_loop(h
      ) and (ord(h)-1 ne 6) ),
1237                                   Cst_new(s)*(ClosedLoopShip_sales(run,s,h)
       ));
1238  *         sales_profit(run)=sum( (s,h)$(product_states(s) and closed_loop(
      h) and (ord(h)-1 ne %Closed_Loop_Upper_delta%) ),Cst_new(s)*ClosedLoopShip
      _sales(run,s,h));
1239           Cost_EndInventory(run)=sum((s,h)$(product_states(s) and ord(h)-1 
      eq 6),Cst_new(s)*ClosedLoopINV(run,s,h));
1240  *         runcost_W(run)=0;
1241  *         runprofit(run)=sum((s,h)$(product_states(s) and closed_loop(h)),
      Cst_new(s)*ClosedLoopShip(run,s,h))+runcost_W(run);
1242  *Runprofit includes subtraction of BO even at last point because BO are wr
      itten like inventory
1243  *BO at 168 means just before 168th point. Ship at 168 means at 168 not bef
      ore or after.
1244  *Our runprofit is only for 167 points of closed loop and 168th point as co
      rrection. So we are essentially wasting the last decision
1245  *that is the open loop that was computed at 168.
1246           runprofit(run)=sales_profit(run)+Cost_EndInventory(run)
1247                           -(runcost_W(run)-sum((h)$(ord(h)-1 eq 6),ClosedLo
      opStart(run,h)))
1248                           -runcost_BO(run);
1249   
1250  *         runprofit(run)=runcost_Inv(run)-runcost_BO(run)
1251  *                        +1E1*sum((s,h)$(product_states(s) and closed_loop
      (h)),Cst_new(s)*ClosedLoopShip(run,s,h));
1252   
1253  *Does not include cost of Terminal BO and inventory but thats okay because
       they are irrelevant when some extra horizon is allowed for getting comple
      te closed loop rolling horizon solution
1254  ************[Start]Information to get very crude estimate for running time
       left**************
1255  timeLeft=MIN_COST.etSolve*(card(run)-ord(run))*card(calc);
      put screen;
      put 'Time for run ' P1.etSolve;
      put ' Estimated Time Left ' timeLeft;
      putclose;
1262  *************[End]Information to get very crude estimate for running time 
      left***************
1263   
      *************Stopping Criterion**************
      N_run=ord(run);
      mean_runcost(run)=sum(run_p$(ord(run_p) le N_run),runcost(run_p))/N_run;
      std_dev_runcost(run)$(ord(run) gt 1)= sqrt(       sum(run_p$(ord(run_p) le
       N_run),     ( abs(  runcost(run_p)-mean_runcost(run) )**2)) /(N_run-1)   
       );
      delta_std_dev_runcost(run)$(ord(run) gt 2)=std_dev_runcost(run)/std_dev_ru
      ncost(run-1)  - 1;
      max_delta_std_dev_runcost(run)= sqrt( 1 + (1.96**2-1)/N_run ) -1;
      *icdfnorm(0.95,0,1);
      *************Stopping Criterion**************
1274  );
1275  ********************[End] runs loop **************************************
      *
1276   
1277  *******************GANTT CHART PARAMETERS*********************************
      ****
1278  PARAMETERS BS(i,j,h),start(i,j,h),Sinv(s,h),end(i,j,h),BO(s,h);
1279  IF (1 eq 0,
1280           loop((run,calc)$(ord(run) eq 1),
1281             BS(i,j,h)$(ord(h) eq ord(calc))=sum((hbar,n)$(ord(hbar)-1 eq 0 
      and ord(n)-1 eq 0),record_states(run,calc,'B',i,j,n,hbar));
1282  *start(i,j,h)$(ord(h)eq ord(calc))=round(sum((hbar,n)$(ord(hbar)-1 eq 0 an
      d ord(n)-1 eq 0),record_states(calc,'W',i,j,n,hbar)));
1283             start(i,j,h)$(ord(h)eq ord(calc))=sum((hbar,n)$(ord(hbar)-1 eq 
      0 and ord(n)-1 eq 0),record_states(run,calc,'W',i,j,n,hbar));
1284             Sinv(s,h)$(ord(h) eq ord(calc))=sum(n$(ord(n)-1 eq 0),record_in
      ventory(run,calc,s,n));
1285             BO(s,h)$(ord(h) eq ord(calc))=sum(n$(ord(n)-1 eq 0),record_back
      log(run,calc,s,n));
1286           );
1287  ELSE
1288  *Write OPEN loop static gantt chart %GanttChart_OPENLOOP% eq 1
1289           loop((run,calc)$(ord(run) eq 1 and ord(calc)-1 eq 4),
1290             BS(i,j,h)$(Ij(i,j))=sum((hbar,n)$(ord(hbar)-1 eq 0 and (ord(n) 
      eq ord(h))),record_states(run,calc,'B',i,j,n,hbar));
1291             start(i,j,h)$(Ij(i,j))=sum((hbar,n)$(ord(hbar)-1 eq 0 and (ord(
      n) eq ord(h))),record_states(run,calc,'W',i,j,n,hbar));
1292             Sinv(s,h)=sum(n$(ord(n) eq ord(h)),record_inventory(run,calc,s,
      n));
1293             BO(s,h)=sum(n$(ord(n) eq ord(h)),record_backlog(run,calc,s,n));
1294           );
1295  );
1296  *Have ending account for task delays
1297  end(i,j,h) = start(i,j,h-pi_new(i))$(BS(i,j,h-pi_new(i))>0);
1298  *******************GANTT CHART PARAMETERS*********************************
      ****
1299   
1300  *******************EXPORT ALL RESULTS IN GDX FILE*************************
      ****
1301  SUCCESS=1;
1302  EXECUTE_UNLOAD 'Z_N4_MH12_Sensitive_rho.gdx';
1303  *******************EXPORT ALL RESULTS IN GDX FILE*************************
      ****
1304   
1305  *********Generate EXCEL SHEEL FOR GANTT CHARTING (Requires windows)*******
      ****
1306  IF(1 eq 1,
1307  ************************************************
1308  ********Closed-Loop GanttChartGeneration********
1309  ************************************************
1310  *Name of the excel file where the data will be exported
1311  *$setglobal file %Results_FileName%_Gantt
1312  *i = set of tasks
1313  *j = set of units
1314  *h = set of time points
1315  *BS = batch size of task i starting in unit j at time t (must be indexed i
      jt)
1316  *start = binary variable that is 1 if task i starts in unit j at time t (m
      ust be indexed ijt)
1317  *Sinv = inventory level of material s at time t (must be indexed st)
1318  *BO= backorder of state s at time t
1319  *end =  binary variable that is 1 if task i ends in unit j at time t (must
       be indexed ijt)
1320   
1321  *EXECUTE_UNLOAD '%Results_FileName%_Gantt.gdx' BS i j h  Sinv start end;
1322   
1323  *The first word of each line gives the type: set = set, var = variable, pa
      r = parameter. This may need to be changed depending on your model
1324  *The location of the output or the sheet names must not be changed
1334   
1335  *display BS,start,end,Sinv,BO;
1336           IF (1 eq 0,
1337                    EXECUTE 'gdxxrw Input=Z_N4_MH12_Sensitive_rho.gdx Output
      =Z_N4_MH12_Sensitive_rho_Gantt_CL @GANTT_write.txt'
1338           ELSE
1339                    EXECUTE 'gdxxrw Input=Z_N4_MH12_Sensitive_rho.gdx Output
      =Z_N4_MH12_Sensitive_rho_Gantt_OL_4 @GANTT_write.txt'
1340           );
1341  );
1342  *********Generate EXCEL SHEEL FOR GANTT CHARTING (Requires windows)*******
      ****
1343   
1344  *END OF MASTER FILE
1345   
1346   
1347   
1348   
1349   
1350   
1351  *Watch out for overflow of solution for rolling horizon...ie the spilling 
      over of
1352  *rolling horizon beyond real horizon to get last implemented closed loop s
      olution
1353   
1354   
1355  *$set console
1356  *$if %system.filesys% == UNIX  $set console /dev/tty
1357  *$if %system.filesys% == DOS $set console con
1358  *$if %system.filesys% == MS95  $set console con
1359  *$if %system.filesys% == MSNT  $set console con
1360  *$if "%console%." == "." abort "filesys not recognized";
1361  *file screen / '%console%' /;
1362  *file log /''/
1363   
1364   
1365   
1366   
1367   
1368   
1369   
1370   
GAMS 24.5.6  r55090 Released Nov 27, 2015 WEX-WEI x86 64bit/MS Windows 07/18/16 14:57:01 Page 5
State_Space_Model
Include File Summary


   SEQ   GLOBAL TYPE      PARENT   LOCAL  FILENAME

     1        1 INPUT          0       0  C:\Users\dhruv\Box Sync\Work\Codes\GAM
                                          S_Code\Z_N4_MH12_Sensitive_rho.gms
     2       21 INCLUDE        1      21  .C:\Users\dhruv\Box Sync\Work\Codes\GA
                                           MS_Code\ConfigurationFile.gms
     3       91 INCLUDE        2      70  ..C:\Users\dhruv\Box Sync\Work\Codes\G
                                            AMS_Code\MasterFile.gms
     4      108 INCLUDE        3      17  ...C:\Users\dhruv\Box Sync\Work\Codes\
                                             GAMS_Code\NetworkN4.gms
     5      217 INCLUDE        3      18  ...C:\Users\dhruv\Box Sync\Work\Codes\
                                             GAMS_Code\Model9.gms
     6      905 INCLUDE        3     152  ...C:\Users\dhruv\Box Sync\Work\Codes\
                                             GAMS_Code\ModelSolution9.gms


COMPILATION TIME     =        0.000 SECONDS      3 MB  24.5.6 r55090 WEX-WEI
GAMS 24.5.6  r55090 Released Nov 27, 2015 WEX-WEI x86 64bit/MS Windows 07/18/16 14:57:01 Page 6
State_Space_Model
Model Statistics    SOLVE MIN_COST Using MIP From line 1119


LOOPS                                  run   run1
                                      calc   calc0


MODEL STATISTICS

BLOCKS OF EQUATIONS          13     SINGLE EQUATIONS          480
BLOCKS OF VARIABLES          10     SINGLE VARIABLES          497
NON ZERO ELEMENTS         1,395     DISCRETE VARIABLES        173


GENERATION TIME      =        0.047 SECONDS      4 MB  24.5.6 r55090 WEX-WEI


EXECUTION TIME       =        0.078 SECONDS      4 MB  24.5.6 r55090 WEX-WEI
               L O O P S                run run1
                                       calc calc0

GAMS 24.5.6  r55090 Released Nov 27, 2015 WEX-WEI x86 64bit/MS Windows 07/18/16 14:57:01 Page 7
State_Space_Model
Solution Report     SOLVE MIN_COST Using MIP From line 1119


               S O L V E      S U M M A R Y

     MODEL   MIN_COST            OBJECTIVE  obj_variable
     TYPE    MIP                 DIRECTION  MINIMIZE
     SOLVER  CPLEX               FROM LINE  1119

**** SOLVER STATUS     1 Normal Completion         
**** MODEL STATUS      1 Optimal                   
**** OBJECTIVE VALUE             3003.0000

 RESOURCE USAGE, LIMIT          0.078       600.000
 ITERATION COUNT, LIMIT       203    2000000000

IBM ILOG CPLEX   24.5.6 r55090 Released Nov 27, 2015 WEI x86 64bit/MS Windows 
--- GAMS/Cplex licensed for continuous and discrete problems.
Cplex 12.6.2.0

Space for names approximately 0.03 Mb
Use option 'names no' to turn use of names off
MIP status(101): integer optimal solution
Cplex Time: 0.08sec (det. 12.65 ticks)
Fixing integer variables, and solving final LP...
Fixed MIP status(1): optimal
Cplex Time: 0.00sec (det. 0.40 ticks)
Proven optimal solution.

MIP Solution:         3003.000000    (198 iterations, 33 nodes)
Final Solve:          3003.000000    (5 iterations)

Best possible:        3003.000000
Absolute gap:            0.000000
Relative gap:            0.000000



**** REPORT SUMMARY :        0     NONOPT
                             0 INFEASIBLE
                             0  UNBOUNDED
GAMS 24.5.6  r55090 Released Nov 27, 2015 WEX-WEI x86 64bit/MS Windows 07/18/16 14:57:01 Page 8
State_Space_Model
Model Statistics    SOLVE MIN_COST Using RMIP From line 1192


LOOPS                                  run   run1
                                      calc   calc0


MODEL STATISTICS

BLOCKS OF EQUATIONS          13     SINGLE EQUATIONS          480
BLOCKS OF VARIABLES          10     SINGLE VARIABLES          497
NON ZERO ELEMENTS         1,395     DISCRETE VARIABLES        173


GENERATION TIME      =        0.032 SECONDS      3 MB  24.5.6 r55090 WEX-WEI


EXECUTION TIME       =        0.032 SECONDS      3 MB  24.5.6 r55090 WEX-WEI
               L O O P S                run run1
                                       calc calc0

GAMS 24.5.6  r55090 Released Nov 27, 2015 WEX-WEI x86 64bit/MS Windows 07/18/16 14:57:01 Page 9
State_Space_Model
Solution Report     SOLVE MIN_COST Using RMIP From line 1192


               S O L V E      S U M M A R Y

     MODEL   MIN_COST            OBJECTIVE  obj_variable
     TYPE    RMIP                DIRECTION  MINIMIZE
     SOLVER  CPLEX               FROM LINE  1192

**** SOLVER STATUS     1 Normal Completion         
**** MODEL STATUS      1 Optimal                   
**** OBJECTIVE VALUE             1902.6600

 RESOURCE USAGE, LIMIT          0.047       600.000
 ITERATION COUNT, LIMIT        95    2000000000

IBM ILOG CPLEX   24.5.6 r55090 Released Nov 27, 2015 WEI x86 64bit/MS Windows 
--- GAMS/Cplex licensed for continuous and discrete problems.
Cplex 12.6.2.0

Space for names approximately 0.03 Mb
Use option 'names no' to turn use of names off
LP status(1): optimal
Cplex Time: 0.03sec (det. 1.25 ticks)
Optimal solution found.
Objective :        1902.660000



**** REPORT SUMMARY :        0     NONOPT
                             0 INFEASIBLE
                             0  UNBOUNDED
GAMS 24.5.6  r55090 Released Nov 27, 2015 WEX-WEI x86 64bit/MS Windows 07/18/16 14:57:01 Page 10
State_Space_Model
Model Statistics    SOLVE MIN_COST Using MIP From line 1119


LOOPS                                  run   run1
                                      calc   calc1


MODEL STATISTICS

BLOCKS OF EQUATIONS          13     SINGLE EQUATIONS          480
BLOCKS OF VARIABLES          10     SINGLE VARIABLES          497
NON ZERO ELEMENTS         1,395     DISCRETE VARIABLES        173


GENERATION TIME      =        0.032 SECONDS      3 MB  24.5.6 r55090 WEX-WEI


EXECUTION TIME       =        0.047 SECONDS      3 MB  24.5.6 r55090 WEX-WEI
               L O O P S                run run1
                                       calc calc1

GAMS 24.5.6  r55090 Released Nov 27, 2015 WEX-WEI x86 64bit/MS Windows 07/18/16 14:57:01 Page 11
State_Space_Model
Solution Report     SOLVE MIN_COST Using MIP From line 1119


               S O L V E      S U M M A R Y

     MODEL   MIN_COST            OBJECTIVE  obj_variable
     TYPE    MIP                 DIRECTION  MINIMIZE
     SOLVER  CPLEX               FROM LINE  1119

**** SOLVER STATUS     1 Normal Completion         
**** MODEL STATUS      1 Optimal                   
**** OBJECTIVE VALUE             3002.0000

 RESOURCE USAGE, LIMIT          0.015       600.000
 ITERATION COUNT, LIMIT        41    2000000000

IBM ILOG CPLEX   24.5.6 r55090 Released Nov 27, 2015 WEI x86 64bit/MS Windows 
--- GAMS/Cplex licensed for continuous and discrete problems.
Cplex 12.6.2.0

Space for names approximately 0.03 Mb
Use option 'names no' to turn use of names off
MIP status(101): integer optimal solution
Cplex Time: 0.01sec (det. 2.90 ticks)
Fixing integer variables, and solving final LP...
Fixed MIP status(1): optimal
Cplex Time: 0.00sec (det. 0.39 ticks)
Proven optimal solution.

MIP Solution:         3002.000000    (38 iterations, 0 nodes)
Final Solve:          3002.000000    (3 iterations)

Best possible:        3002.000000
Absolute gap:            0.000000
Relative gap:            0.000000



**** REPORT SUMMARY :        0     NONOPT
                             0 INFEASIBLE
                             0  UNBOUNDED
GAMS 24.5.6  r55090 Released Nov 27, 2015 WEX-WEI x86 64bit/MS Windows 07/18/16 14:57:01 Page 12
State_Space_Model
Model Statistics    SOLVE MIN_COST Using RMIP From line 1192


LOOPS                                  run   run1
                                      calc   calc1


MODEL STATISTICS

BLOCKS OF EQUATIONS          13     SINGLE EQUATIONS          480
BLOCKS OF VARIABLES          10     SINGLE VARIABLES          497
NON ZERO ELEMENTS         1,395     DISCRETE VARIABLES        173


GENERATION TIME      =        0.031 SECONDS      3 MB  24.5.6 r55090 WEX-WEI


EXECUTION TIME       =        0.031 SECONDS      3 MB  24.5.6 r55090 WEX-WEI
               L O O P S                run run1
                                       calc calc1

GAMS 24.5.6  r55090 Released Nov 27, 2015 WEX-WEI x86 64bit/MS Windows 07/18/16 14:57:01 Page 13
State_Space_Model
Solution Report     SOLVE MIN_COST Using RMIP From line 1192


               S O L V E      S U M M A R Y

     MODEL   MIN_COST            OBJECTIVE  obj_variable
     TYPE    RMIP                DIRECTION  MINIMIZE
     SOLVER  CPLEX               FROM LINE  1192

**** SOLVER STATUS     1 Normal Completion         
**** MODEL STATUS      1 Optimal                   
**** OBJECTIVE VALUE             2881.8600

 RESOURCE USAGE, LIMIT          0.031       600.000
 ITERATION COUNT, LIMIT        98    2000000000

IBM ILOG CPLEX   24.5.6 r55090 Released Nov 27, 2015 WEI x86 64bit/MS Windows 
--- GAMS/Cplex licensed for continuous and discrete problems.
Cplex 12.6.2.0

Space for names approximately 0.03 Mb
Use option 'names no' to turn use of names off
LP status(1): optimal
Cplex Time: 0.03sec (det. 1.24 ticks)
Optimal solution found.
Objective :        2881.860000



**** REPORT SUMMARY :        0     NONOPT
                             0 INFEASIBLE
                             0  UNBOUNDED
GAMS 24.5.6  r55090 Released Nov 27, 2015 WEX-WEI x86 64bit/MS Windows 07/18/16 14:57:01 Page 14
State_Space_Model
Model Statistics    SOLVE MIN_COST Using MIP From line 1119


LOOPS                                  run   run1
                                      calc   calc2


MODEL STATISTICS

BLOCKS OF EQUATIONS          13     SINGLE EQUATIONS          480
BLOCKS OF VARIABLES          10     SINGLE VARIABLES          497
NON ZERO ELEMENTS         1,395     DISCRETE VARIABLES        173


GENERATION TIME      =        0.031 SECONDS      3 MB  24.5.6 r55090 WEX-WEI


EXECUTION TIME       =        0.031 SECONDS      3 MB  24.5.6 r55090 WEX-WEI
               L O O P S                run run1
                                       calc calc2

GAMS 24.5.6  r55090 Released Nov 27, 2015 WEX-WEI x86 64bit/MS Windows 07/18/16 14:57:01 Page 15
State_Space_Model
Solution Report     SOLVE MIN_COST Using MIP From line 1119


               S O L V E      S U M M A R Y

     MODEL   MIN_COST            OBJECTIVE  obj_variable
     TYPE    MIP                 DIRECTION  MINIMIZE
     SOLVER  CPLEX               FROM LINE  1119

**** SOLVER STATUS     1 Normal Completion         
**** MODEL STATUS      1 Optimal                   
**** OBJECTIVE VALUE             3002.0000

 RESOURCE USAGE, LIMIT          0.047       600.000
 ITERATION COUNT, LIMIT        45    2000000000

IBM ILOG CPLEX   24.5.6 r55090 Released Nov 27, 2015 WEI x86 64bit/MS Windows 
--- GAMS/Cplex licensed for continuous and discrete problems.
Cplex 12.6.2.0

Space for names approximately 0.03 Mb
Use option 'names no' to turn use of names off
MIP status(101): integer optimal solution
Cplex Time: 0.05sec (det. 3.03 ticks)
Fixing integer variables, and solving final LP...
Fixed MIP status(1): optimal
Cplex Time: 0.00sec (det. 0.40 ticks)
Proven optimal solution.

MIP Solution:         3002.000000    (42 iterations, 0 nodes)
Final Solve:          3002.000000    (3 iterations)

Best possible:        3002.000000
Absolute gap:            0.000000
Relative gap:            0.000000



**** REPORT SUMMARY :        0     NONOPT
                             0 INFEASIBLE
                             0  UNBOUNDED
GAMS 24.5.6  r55090 Released Nov 27, 2015 WEX-WEI x86 64bit/MS Windows 07/18/16 14:57:01 Page 16
State_Space_Model
Model Statistics    SOLVE MIN_COST Using RMIP From line 1192


LOOPS                                  run   run1
                                      calc   calc2


MODEL STATISTICS

BLOCKS OF EQUATIONS          13     SINGLE EQUATIONS          480
BLOCKS OF VARIABLES          10     SINGLE VARIABLES          497
NON ZERO ELEMENTS         1,395     DISCRETE VARIABLES        173


GENERATION TIME      =        0.016 SECONDS      3 MB  24.5.6 r55090 WEX-WEI


EXECUTION TIME       =        0.031 SECONDS      3 MB  24.5.6 r55090 WEX-WEI
               L O O P S                run run1
                                       calc calc2

GAMS 24.5.6  r55090 Released Nov 27, 2015 WEX-WEI x86 64bit/MS Windows 07/18/16 14:57:01 Page 17
State_Space_Model
Solution Report     SOLVE MIN_COST Using RMIP From line 1192


               S O L V E      S U M M A R Y

     MODEL   MIN_COST            OBJECTIVE  obj_variable
     TYPE    RMIP                DIRECTION  MINIMIZE
     SOLVER  CPLEX               FROM LINE  1192

**** SOLVER STATUS     1 Normal Completion         
**** MODEL STATUS      1 Optimal                   
**** OBJECTIVE VALUE             2901.8600

 RESOURCE USAGE, LIMIT          0.047       600.000
 ITERATION COUNT, LIMIT       106    2000000000

IBM ILOG CPLEX   24.5.6 r55090 Released Nov 27, 2015 WEI x86 64bit/MS Windows 
--- GAMS/Cplex licensed for continuous and discrete problems.
Cplex 12.6.2.0

Space for names approximately 0.03 Mb
Use option 'names no' to turn use of names off
LP status(1): optimal
Cplex Time: 0.01sec (det. 1.29 ticks)
Optimal solution found.
Objective :        2901.860000



**** REPORT SUMMARY :        0     NONOPT
                             0 INFEASIBLE
                             0  UNBOUNDED
GAMS 24.5.6  r55090 Released Nov 27, 2015 WEX-WEI x86 64bit/MS Windows 07/18/16 14:57:01 Page 18
State_Space_Model
Model Statistics    SOLVE MIN_COST Using MIP From line 1119


LOOPS                                  run   run1
                                      calc   calc3


MODEL STATISTICS

BLOCKS OF EQUATIONS          13     SINGLE EQUATIONS          480
BLOCKS OF VARIABLES          10     SINGLE VARIABLES          497
NON ZERO ELEMENTS         1,395     DISCRETE VARIABLES        173


GENERATION TIME      =        0.032 SECONDS      3 MB  24.5.6 r55090 WEX-WEI


EXECUTION TIME       =        0.032 SECONDS      3 MB  24.5.6 r55090 WEX-WEI
               L O O P S                run run1
                                       calc calc3

GAMS 24.5.6  r55090 Released Nov 27, 2015 WEX-WEI x86 64bit/MS Windows 07/18/16 14:57:01 Page 19
State_Space_Model
Solution Report     SOLVE MIN_COST Using MIP From line 1119


               S O L V E      S U M M A R Y

     MODEL   MIN_COST            OBJECTIVE  obj_variable
     TYPE    MIP                 DIRECTION  MINIMIZE
     SOLVER  CPLEX               FROM LINE  1119

**** SOLVER STATUS     1 Normal Completion         
**** MODEL STATUS      1 Optimal                   
**** OBJECTIVE VALUE             3001.0000

 RESOURCE USAGE, LIMIT          0.047       600.000
 ITERATION COUNT, LIMIT         3    2000000000

IBM ILOG CPLEX   24.5.6 r55090 Released Nov 27, 2015 WEI x86 64bit/MS Windows 
--- GAMS/Cplex licensed for continuous and discrete problems.
Cplex 12.6.2.0

Space for names approximately 0.03 Mb
Use option 'names no' to turn use of names off
MIP status(101): integer optimal solution
Cplex Time: 0.03sec (det. 3.45 ticks)
Fixing integer variables, and solving final LP...
Fixed MIP status(1): optimal
Cplex Time: 0.02sec (det. 0.39 ticks)
Proven optimal solution.

MIP Solution:         3001.000000    (1 iterations, 0 nodes)
Final Solve:          3001.000000    (2 iterations)

Best possible:        3001.000000
Absolute gap:            0.000000
Relative gap:            0.000000



**** REPORT SUMMARY :        0     NONOPT
                             0 INFEASIBLE
                             0  UNBOUNDED
GAMS 24.5.6  r55090 Released Nov 27, 2015 WEX-WEI x86 64bit/MS Windows 07/18/16 14:57:01 Page 20
State_Space_Model
Model Statistics    SOLVE MIN_COST Using RMIP From line 1192


LOOPS                                  run   run1
                                      calc   calc3


MODEL STATISTICS

BLOCKS OF EQUATIONS          13     SINGLE EQUATIONS          480
BLOCKS OF VARIABLES          10     SINGLE VARIABLES          497
NON ZERO ELEMENTS         1,395     DISCRETE VARIABLES        173


GENERATION TIME      =        0.031 SECONDS      3 MB  24.5.6 r55090 WEX-WEI


EXECUTION TIME       =        0.031 SECONDS      3 MB  24.5.6 r55090 WEX-WEI
               L O O P S                run run1
                                       calc calc3

GAMS 24.5.6  r55090 Released Nov 27, 2015 WEX-WEI x86 64bit/MS Windows 07/18/16 14:57:01 Page 21
State_Space_Model
Solution Report     SOLVE MIN_COST Using RMIP From line 1192


               S O L V E      S U M M A R Y

     MODEL   MIN_COST            OBJECTIVE  obj_variable
     TYPE    RMIP                DIRECTION  MINIMIZE
     SOLVER  CPLEX               FROM LINE  1192

**** SOLVER STATUS     1 Normal Completion         
**** MODEL STATUS      1 Optimal                   
**** OBJECTIVE VALUE             3000.8000

 RESOURCE USAGE, LIMIT          0.031       600.000
 ITERATION COUNT, LIMIT        89    2000000000

IBM ILOG CPLEX   24.5.6 r55090 Released Nov 27, 2015 WEI x86 64bit/MS Windows 
--- GAMS/Cplex licensed for continuous and discrete problems.
Cplex 12.6.2.0

Space for names approximately 0.03 Mb
Use option 'names no' to turn use of names off
LP status(1): optimal
Cplex Time: 0.03sec (det. 1.20 ticks)
Optimal solution found.
Objective :        3000.800000



**** REPORT SUMMARY :        0     NONOPT
                             0 INFEASIBLE
                             0  UNBOUNDED
GAMS 24.5.6  r55090 Released Nov 27, 2015 WEX-WEI x86 64bit/MS Windows 07/18/16 14:57:01 Page 22
State_Space_Model
Model Statistics    SOLVE MIN_COST Using MIP From line 1119


LOOPS                                  run   run1
                                      calc   calc4


MODEL STATISTICS

BLOCKS OF EQUATIONS          13     SINGLE EQUATIONS          480
BLOCKS OF VARIABLES          10     SINGLE VARIABLES          497
NON ZERO ELEMENTS         1,395     DISCRETE VARIABLES        173


GENERATION TIME      =        0.032 SECONDS      3 MB  24.5.6 r55090 WEX-WEI


EXECUTION TIME       =        0.032 SECONDS      3 MB  24.5.6 r55090 WEX-WEI
               L O O P S                run run1
                                       calc calc4

GAMS 24.5.6  r55090 Released Nov 27, 2015 WEX-WEI x86 64bit/MS Windows 07/18/16 14:57:01 Page 23
State_Space_Model
Solution Report     SOLVE MIN_COST Using MIP From line 1119


               S O L V E      S U M M A R Y

     MODEL   MIN_COST            OBJECTIVE  obj_variable
     TYPE    MIP                 DIRECTION  MINIMIZE
     SOLVER  CPLEX               FROM LINE  1119

**** SOLVER STATUS     1 Normal Completion         
**** MODEL STATUS      1 Optimal                   
**** OBJECTIVE VALUE             4077.0000

 RESOURCE USAGE, LIMIT          0.062       600.000
 ITERATION COUNT, LIMIT        95    2000000000

IBM ILOG CPLEX   24.5.6 r55090 Released Nov 27, 2015 WEI x86 64bit/MS Windows 
--- GAMS/Cplex licensed for continuous and discrete problems.
Cplex 12.6.2.0

Space for names approximately 0.03 Mb
Use option 'names no' to turn use of names off
MIP status(101): integer optimal solution
Cplex Time: 0.03sec (det. 5.06 ticks)
Fixing integer variables, and solving final LP...
Fixed MIP status(1): optimal
Cplex Time: 0.01sec (det. 0.40 ticks)
Proven optimal solution.

MIP Solution:         4076.999992    (91 iterations, 0 nodes)
Final Solve:          4076.999954    (4 iterations)

Best possible:        4076.999992
Absolute gap:            0.000000
Relative gap:            0.000000



**** REPORT SUMMARY :        0     NONOPT
                             0 INFEASIBLE
                             0  UNBOUNDED
GAMS 24.5.6  r55090 Released Nov 27, 2015 WEX-WEI x86 64bit/MS Windows 07/18/16 14:57:01 Page 24
State_Space_Model
Model Statistics    SOLVE MIN_COST Using RMIP From line 1192


LOOPS                                  run   run1
                                      calc   calc4


MODEL STATISTICS

BLOCKS OF EQUATIONS          13     SINGLE EQUATIONS          480
BLOCKS OF VARIABLES          10     SINGLE VARIABLES          497
NON ZERO ELEMENTS         1,395     DISCRETE VARIABLES        173


GENERATION TIME      =        0.046 SECONDS      3 MB  24.5.6 r55090 WEX-WEI


EXECUTION TIME       =        0.046 SECONDS      3 MB  24.5.6 r55090 WEX-WEI
               L O O P S                run run1
                                       calc calc4

GAMS 24.5.6  r55090 Released Nov 27, 2015 WEX-WEI x86 64bit/MS Windows 07/18/16 14:57:01 Page 25
State_Space_Model
Solution Report     SOLVE MIN_COST Using RMIP From line 1192


               S O L V E      S U M M A R Y

     MODEL   MIN_COST            OBJECTIVE  obj_variable
     TYPE    RMIP                DIRECTION  MINIMIZE
     SOLVER  CPLEX               FROM LINE  1192

**** SOLVER STATUS     1 Normal Completion         
**** MODEL STATUS      1 Optimal                   
**** OBJECTIVE VALUE             2806.8180

 RESOURCE USAGE, LIMIT          0.000       600.000
 ITERATION COUNT, LIMIT       115    2000000000

IBM ILOG CPLEX   24.5.6 r55090 Released Nov 27, 2015 WEI x86 64bit/MS Windows 
--- GAMS/Cplex licensed for continuous and discrete problems.
Cplex 12.6.2.0

Space for names approximately 0.03 Mb
Use option 'names no' to turn use of names off
LP status(1): optimal
Cplex Time: 0.00sec (det. 1.37 ticks)
Optimal solution found.
Objective :        2806.818000



**** REPORT SUMMARY :        0     NONOPT
                             0 INFEASIBLE
                             0  UNBOUNDED
GAMS 24.5.6  r55090 Released Nov 27, 2015 WEX-WEI x86 64bit/MS Windows 07/18/16 14:57:01 Page 26
State_Space_Model
Model Statistics    SOLVE MIN_COST Using MIP From line 1119


LOOPS                                  run   run1
                                      calc   calc5


MODEL STATISTICS

BLOCKS OF EQUATIONS          13     SINGLE EQUATIONS          480
BLOCKS OF VARIABLES          10     SINGLE VARIABLES          497
NON ZERO ELEMENTS         1,395     DISCRETE VARIABLES        173


GENERATION TIME      =        0.046 SECONDS      3 MB  24.5.6 r55090 WEX-WEI


EXECUTION TIME       =        0.109 SECONDS      3 MB  24.5.6 r55090 WEX-WEI
               L O O P S                run run1
                                       calc calc5

GAMS 24.5.6  r55090 Released Nov 27, 2015 WEX-WEI x86 64bit/MS Windows 07/18/16 14:57:01 Page 27
State_Space_Model
Solution Report     SOLVE MIN_COST Using MIP From line 1119


               S O L V E      S U M M A R Y

     MODEL   MIN_COST            OBJECTIVE  obj_variable
     TYPE    MIP                 DIRECTION  MINIMIZE
     SOLVER  CPLEX               FROM LINE  1119

**** SOLVER STATUS     1 Normal Completion         
**** MODEL STATUS      1 Optimal                   
**** OBJECTIVE VALUE             3876.0000

 RESOURCE USAGE, LIMIT          0.047       600.000
 ITERATION COUNT, LIMIT        89    2000000000

IBM ILOG CPLEX   24.5.6 r55090 Released Nov 27, 2015 WEI x86 64bit/MS Windows 
--- GAMS/Cplex licensed for continuous and discrete problems.
Cplex 12.6.2.0

Space for names approximately 0.03 Mb
Use option 'names no' to turn use of names off
MIP status(101): integer optimal solution
Cplex Time: 0.05sec (det. 4.65 ticks)
Fixing integer variables, and solving final LP...
Fixed MIP status(1): optimal
Cplex Time: 0.00sec (det. 0.40 ticks)
Proven optimal solution.

MIP Solution:         3875.999995    (85 iterations, 0 nodes)
Final Solve:          3875.999967    (4 iterations)

Best possible:        3875.999995
Absolute gap:            0.000000
Relative gap:            0.000000



**** REPORT SUMMARY :        0     NONOPT
                             0 INFEASIBLE
                             0  UNBOUNDED
GAMS 24.5.6  r55090 Released Nov 27, 2015 WEX-WEI x86 64bit/MS Windows 07/18/16 14:57:01 Page 28
State_Space_Model
Model Statistics    SOLVE MIN_COST Using RMIP From line 1192


LOOPS                                  run   run1
                                      calc   calc5


MODEL STATISTICS

BLOCKS OF EQUATIONS          13     SINGLE EQUATIONS          480
BLOCKS OF VARIABLES          10     SINGLE VARIABLES          497
NON ZERO ELEMENTS         1,395     DISCRETE VARIABLES        173


GENERATION TIME      =        0.031 SECONDS      3 MB  24.5.6 r55090 WEX-WEI


EXECUTION TIME       =        0.031 SECONDS      3 MB  24.5.6 r55090 WEX-WEI
               L O O P S                run run1
                                       calc calc5

GAMS 24.5.6  r55090 Released Nov 27, 2015 WEX-WEI x86 64bit/MS Windows 07/18/16 14:57:01 Page 29
State_Space_Model
Solution Report     SOLVE MIN_COST Using RMIP From line 1192


               S O L V E      S U M M A R Y

     MODEL   MIN_COST            OBJECTIVE  obj_variable
     TYPE    RMIP                DIRECTION  MINIMIZE
     SOLVER  CPLEX               FROM LINE  1192

**** SOLVER STATUS     1 Normal Completion         
**** MODEL STATUS      1 Optimal                   
**** OBJECTIVE VALUE             2606.0200

 RESOURCE USAGE, LIMIT          0.031       600.000
 ITERATION COUNT, LIMIT        55    2000000000

IBM ILOG CPLEX   24.5.6 r55090 Released Nov 27, 2015 WEI x86 64bit/MS Windows 
--- GAMS/Cplex licensed for continuous and discrete problems.
Cplex 12.6.2.0

Space for names approximately 0.03 Mb
Use option 'names no' to turn use of names off
LP status(1): optimal
Cplex Time: 0.03sec (det. 1.00 ticks)
Optimal solution found.
Objective :        2606.020000



**** REPORT SUMMARY :        0     NONOPT
                             0 INFEASIBLE
                             0  UNBOUNDED
GAMS 24.5.6  r55090 Released Nov 27, 2015 WEX-WEI x86 64bit/MS Windows 07/18/16 14:57:01 Page 30
State_Space_Model
Model Statistics    SOLVE MIN_COST Using MIP From line 1119


LOOPS                                  run   run1
                                      calc   calc6


MODEL STATISTICS

BLOCKS OF EQUATIONS          13     SINGLE EQUATIONS          480
BLOCKS OF VARIABLES          10     SINGLE VARIABLES          497
NON ZERO ELEMENTS         1,395     DISCRETE VARIABLES        173


GENERATION TIME      =        0.031 SECONDS      3 MB  24.5.6 r55090 WEX-WEI


EXECUTION TIME       =        0.031 SECONDS      3 MB  24.5.6 r55090 WEX-WEI
               L O O P S                run run1
                                       calc calc6

GAMS 24.5.6  r55090 Released Nov 27, 2015 WEX-WEI x86 64bit/MS Windows 07/18/16 14:57:01 Page 31
State_Space_Model
Solution Report     SOLVE MIN_COST Using MIP From line 1119


               S O L V E      S U M M A R Y

     MODEL   MIN_COST            OBJECTIVE  obj_variable
     TYPE    MIP                 DIRECTION  MINIMIZE
     SOLVER  CPLEX               FROM LINE  1119

**** SOLVER STATUS     1 Normal Completion         
**** MODEL STATUS      1 Optimal                   
**** OBJECTIVE VALUE             3184.0000

 RESOURCE USAGE, LIMIT          0.063       600.000
 ITERATION COUNT, LIMIT        89    2000000000

IBM ILOG CPLEX   24.5.6 r55090 Released Nov 27, 2015 WEI x86 64bit/MS Windows 
--- GAMS/Cplex licensed for continuous and discrete problems.
Cplex 12.6.2.0

Space for names approximately 0.03 Mb
Use option 'names no' to turn use of names off
MIP status(101): integer optimal solution
Cplex Time: 0.05sec (det. 4.65 ticks)
Fixing integer variables, and solving final LP...
Fixed MIP status(1): optimal
Cplex Time: 0.02sec (det. 0.40 ticks)
Proven optimal solution.

MIP Solution:         3183.999995    (85 iterations, 0 nodes)
Final Solve:          3183.999965    (4 iterations)

Best possible:        3183.999995
Absolute gap:            0.000000
Relative gap:            0.000000



**** REPORT SUMMARY :        0     NONOPT
                             0 INFEASIBLE
                             0  UNBOUNDED
GAMS 24.5.6  r55090 Released Nov 27, 2015 WEX-WEI x86 64bit/MS Windows 07/18/16 14:57:01 Page 32
State_Space_Model
Model Statistics    SOLVE MIN_COST Using RMIP From line 1192


LOOPS                                  run   run1
                                      calc   calc6


MODEL STATISTICS

BLOCKS OF EQUATIONS          13     SINGLE EQUATIONS          480
BLOCKS OF VARIABLES          10     SINGLE VARIABLES          497
NON ZERO ELEMENTS         1,395     DISCRETE VARIABLES        173


GENERATION TIME      =        0.031 SECONDS      3 MB  24.5.6 r55090 WEX-WEI


EXECUTION TIME       =        0.031 SECONDS      3 MB  24.5.6 r55090 WEX-WEI
               L O O P S                run run1
                                       calc calc6

GAMS 24.5.6  r55090 Released Nov 27, 2015 WEX-WEI x86 64bit/MS Windows 07/18/16 14:57:01 Page 33
State_Space_Model
Solution Report     SOLVE MIN_COST Using RMIP From line 1192


               S O L V E      S U M M A R Y

     MODEL   MIN_COST            OBJECTIVE  obj_variable
     TYPE    RMIP                DIRECTION  MINIMIZE
     SOLVER  CPLEX               FROM LINE  1192

**** SOLVER STATUS     1 Normal Completion         
**** MODEL STATUS      1 Optimal                   
**** OBJECTIVE VALUE             1914.0200

 RESOURCE USAGE, LIMIT          0.016       600.000
 ITERATION COUNT, LIMIT        55    2000000000

IBM ILOG CPLEX   24.5.6 r55090 Released Nov 27, 2015 WEI x86 64bit/MS Windows 
--- GAMS/Cplex licensed for continuous and discrete problems.
Cplex 12.6.2.0

Space for names approximately 0.03 Mb
Use option 'names no' to turn use of names off
LP status(1): optimal
Cplex Time: 0.02sec (det. 1.00 ticks)
Optimal solution found.
Objective :        1914.020000



**** REPORT SUMMARY :        0     NONOPT
                             0 INFEASIBLE
                             0  UNBOUNDED
GAMS 24.5.6  r55090 Released Nov 27, 2015 WEX-WEI x86 64bit/MS Windows 07/18/16 14:57:01 Page 34
State_Space_Model
E x e c u t i o n


EXECUTION TIME       =        0.452 SECONDS      3 MB  24.5.6 r55090 WEX-WEI


USER: Department of Chemical & Biological EngineeringG151026:1254AO-GEN
      University of Wisconsin - Madison                          DC4923
      License for teaching and research at degree granting institutions


**** FILE SUMMARY

Input      C:\Users\dhruv\Box Sync\Work\Codes\GAMS_Code\Z_N4_MH12_Sensitive_rho.
           gms
Output     C:\Users\dhruv\Box Sync\Work\Codes\GAMS_Code\Z_N4_MH12_Sensitive_rho.
           lst
