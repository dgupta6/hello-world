GAMS 24.5.6  r55090 Released Nov 27, 2015 WEX-WEI x86 64bit/MS Windows                                                                                                                                                                 03/09/16 09:27:54 Page 1
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
C o m p i l a t i o n


   3  SCALAR re_freq                    /1/;
   4  PARAMETER demand_cycletime        /3/;
   5  PARAMETER demand_variation        /1/;
   6  PARAMETER demand_magnitude        /3.00/;
   7  PARAMETER lambda_Demand           /0.00/;
   8  SCALAR surprise                   /0.00/;
   9  SCALAR optcr_value                /0/;
  10  PARAMETER SEED_VALUE              /1716/;
INCLUDE    C:\Users\dhruv\Box Sync\Work\Codes_OnlineMethods\GAMS_Greedy\ConfigurationFile.gms
GAMS 24.5.6  r55090 Released Nov 27, 2015 WEX-WEI x86 64bit/MS Windows                                                                                                                                                                 03/09/16 09:27:54 Page 2
CONFIGURATION_FILE
C o m p i l a t i o n


  22   
  23  *$SETGLOBAL OPTIMIZATION_DIRECTION  maximizing
  24  *$SETGLOBAL MODEL_NAME MAX_PROFIT
  25  *$SETGLOBAL InitialInventoryFlag 1
  26   
  27  *$SETGLOBAL OPTIMIZATION_DIRECTION  minimizing
  28  *$SETGLOBAL MODEL_NAME MIN_COST
  29  *$SETGLOBAL InitialInventoryFlag 0
  30  *******HORIZON********
  31  *$SETGLOBAL H 192
  33  *$SETGLOBAL MH 20
  34  *SCALAR re_freq /1/;
  35  *Used in chopping off initial transient in closed loop cost evaluation
  36  *$SETGLOBAL Transient_H 48
  37  *$SETGLOBAL Transient_H 0
  38  *We do Closed_Loop_Upper # of calc and record closed loop solution only till there
  39  *$SETGLOBAL Closed_Loop_Upper 168
  40  *$SETGLOBAL Closed_Loop_Upper 192
  41  *******HORIZON********
  42   
  43  *******NETWORK AND MODEL********
  44  *$SETGLOBAL NetworkNumber 1
  47  *******NETWORK AND MODEL********
  48   
  49  *******DEMAND LOAD********
  50  *PARAMETER demand_cycletime /12/;
  51  *PARAMETER demand_variation /3/;
  52  *PARAMETER demand_magnitude NOMINAL LOAD /25/;
  53  *******DEMAND LOAD********
  54   
  55  ******DISTURBANCES********************
  56  *$SETGLOBAL Demand_Disturbance_flag 0
  60  *Parameters for demand uncertainty
  61  *What fraction ahead of rolling Horizon does demand forecast changes'
  62  *SCALAR surprise /0.34/;
  63  *Magnitude of Uncertainties
  64  *PARAMETER lambda_Demand /0.2/;
  65  *Yet to replace these names in ModelSolution9 file
  66  *and these values are hardcoded right now (look into code again)
  67  PARAMETER lambda_TaskDelay /0.2/;
  68  PARAMETER lambda_UnitBreakdown /0.2/;
  69  PARAMETER bringing_unit_back /2/;
  70  PARAMETER lambda_Handling /0.2/;
  71  ******DISTURBANCES********************
  72   
  73  *******OPTIMIZATION OPTIONS****
  74  *SCALAR   optcr_value /0/;
  75  SCALAR   timelimit /10800/;
  76  *******OPTIMIZATION OPTIONS****
  77   
  78  *******EVALUATION********
  79  *$SETGLOBAL N_runs 1
  80  *******EVALUATION********
GAMS 24.5.6  r55090 Released Nov 27, 2015 WEX-WEI x86 64bit/MS Windows                                                                                                                                                                 03/09/16 09:27:54 Page 3
CONFIGURATION_FILE
C o m p i l a t i o n


  81   
  82  *******REPORTING********
  85  *$SETGLOBAL Results_FileName Config_Results
  86  *******REPORTING********
  87   
  88  *Run the closed loop and generate results
INCLUDE    C:\Users\dhruv\Box Sync\Work\Codes_OnlineMethods\GAMS_Greedy\MasterFile.gms
  90  *Change this to name of the instance
GAMS 24.5.6  r55090 Released Nov 27, 2015 WEX-WEI x86 64bit/MS Windows                                                                                                                                                                 03/09/16 09:27:54 Page 4
MasterFile
C o m p i l a t i o n


  96  *$OFFLISTING
  97   
  98  execseed=SEED_VALUE;
  99  *parameter cc /0/;
 100   
 102  SCALAR KillLength /2/;
 103   
 104  SET run /run1*run1/;
 105   
INCLUDE    C:\Users\dhruv\Box Sync\Work\Codes_OnlineMethods\GAMS_Greedy\NetworkN2.gms
 107  Sets     i tasks  /T1*T3/
 108           s states /M1*M4/
 109           j units  /U1*U2/
 110           u utilities /manpower/
 111   
 112  *         Ki(j,i) set of equipments(units) suitable for task i
 113  *         /(Reactor1).(TA,TB),Heater.Heating/
 114           Ij(i,j) set of equipments(units) suitable for task i
 115           /T1.U1,(T2,T3).U2/
 116   
 117           FIS(s) States with Finite Intermediate Storage /M2/
 118           product_states(s) Product States/M3*M4/
 119           feed_states(s) Feed States/M1/
 120   
 121           UtilInt Intervals for utility /Int1/
 122           UnitInt Intervals for unit-unavailability /Int1/
 123   
 124           Attributes/magnitude, starttime, price/
 125  ;
 126   
 127  Table UtilData(UtilInt,u,Attributes)
 128               manpower.starttime            manpower.magnitude      manpower.price
 129  Int1                    0                         10                     0
 130  ;
 131   
 132  *Availability of unit  0=available, 1=not available
 133  Table UnitData(UnitInt,j,Attributes)
 134                U1.magnitude         U1.starttime
 135  Int1              0                     0
 136  ;
 137   
 138  Parameters rho(i,s) proportion of input of task i from states s
 139             /T1.M1 1,(T2,T3).M2 1/
 140             rhobar(i,s) proportion of ouput of task i to state s
 141             /T1.M2 1, T2.M3 1, T3.M4 1/
 142   
 143             pis(i,s) processing time for output of task i into state s
 144             /T1.M2 2,T2.M3 2, T3.M4 3/
 145             pi(i) maximum processing time in task i for any stage produced by it
 146   
 147             alpha(u,i) fixed utility demand by task i throughout its run
 148             /manpower.(T1*T2) 0/
 149             beta(u,i) "variable utility demand by task i throughout its run(te/hr)"
GAMS 24.5.6  r55090 Released Nov 27, 2015 WEX-WEI x86 64bit/MS Windows                                                                                                                                                                 03/09/16 09:27:54 Page 5
MasterFile
C o m p i l a t i o n


 150             /manpower.(T1*T2) 0/
 151   
 152             vmaxij(i,j)  Maximum capacity of unit j when used for task i
 153             /T1.U1 20, (T2,T3).U2 10/
 154             vminij(i,j)  Minimum capacity of unit j when used for task i
 155             /T1.U1 10, (T2,T3).U2 5/
 156             Cs(s) maximum storage capacity for stage s  /(M1*M4) 99999/
 157             Cst(s) unit price of s/M1 1, M2 5, M3 10, M4 10/
 158  ;
 159  *pis(i,s)=5;
 160  pi(i)=smax(s,pis(i,s));
 161   
      ******DEMAND INFORMATION*****************************
      *Each order for all products
      set         o orders /o1*o%H%/;
      parameter deliveries_time(o);
      deliveries_time(o)=demand_cycletime*ord(o);
      deliveries_time(o)=deliveries_time(o)+UniformInt(-demand_variation,demand_variation);
      parameter deliveries(o,s);
      deliveries(o,s)$(product_states(s))=demand_magnitude;
      ******DEMAND INFORMATION*****************************
 173   
 174  *END OF INSTANCE FILE
 175   
 176   
 177   
 178   
 179   
 180   
 181   
 182   
 183   
 184   
 185   
 186   
 187   
 188   
 189   
 190   
      Table deliveries(o,s)
              SA      SB
      o1      5       5
      o2      5       5
      o3      5       5
      o4      5       5
      o5      5       5
      o6      5       5
      o7      5       5
      o8      5       5;
 203   
 204   
      For debugging/testing utility formulas
      Table UtilData(UtilInt,u,Attributes)
GAMS 24.5.6  r55090 Released Nov 27, 2015 WEX-WEI x86 64bit/MS Windows                                                                                                                                                                 03/09/16 09:27:54 Page 6
MasterFile
C o m p i l a t i o n


                   manpower.starttime            manpower.magnitude      manpower.price
      Int1                    0                         1                     1
      Int2                    1.5                       0                     0
      Int3                    3.5                       1                     1
      Int4                    6.1                       0                     0;
INCLUDE    C:\Users\dhruv\Box Sync\Work\Codes_OnlineMethods\GAMS_Greedy\Model9.gms
GAMS 24.5.6  r55090 Released Nov 27, 2015 WEX-WEI x86 64bit/MS Windows                                                                                                                                                                 03/09/16 09:27:54 Page 7
State_Space_Model
C o m p i l a t i o n


 216  OPTIONS limrow = 0, limcol = 0, solprint = off;
 217  *OPTIONS limrow = 1000, limcol = 1000, solprint = on;
 218  *No upper limit on inventory (equation not enforced)
 219   
 220  *used for rounding W,B in recordstates in modelsolution file
 221  PARAMETER Small_number /1E-2/;
 222   
 223  *Now generating time grid using delta
 226  *$EvalGlobal calculations (%horizon%-%window%)
 230   
 231  set h time(multiples of delta) /h0*h216/
 232      n time window   /n0*n180/
 233      calc #of windows /calc0*calc0/
 234   
 235      closed_loop(h) horizon points for which we calculate closed loop cost
 236   
 237      Sbari(s,i)  materials produced by task i
 238      Si(s,i)     materials consumed by task i
 239      Tbars(i,s)    Tasks producing material s
 240      Ts(i,s) Tasks consuming material s;
 241   
 242  Sbari(s,i)=1$(rhobar(i,s) gt 0);
 243  Si(s,i)=1$(rho(i,s) gt 0);
 244  *Ij(i,j)=Ki(j,i);
 245  Tbars(i,s)=Sbari(s,i);
 246  Ts(i,s)=Si(s,i);
 247   
 248  closed_loop(h)=0;
 249  closed_loop(h)$(ord(h)-1 ge 0 and ord(h)-1 le 0)=1;
 250   
 251   
 252  alias(i,ip)
 253  alias(j,jp)
 254  alias(s,sp)
 255  alias(n,np)
 256  alias(h,hbar);
 257   
 258  set     UnitUnavailable_full(j,h)
 259  UnitUnavailable(j,n);
 260   
 261  parameter Uutmax_full(u,h),Cut_full(u,h) utility price;
 262   
 263  parameters Dst(s,n),Uutmax(u,n),Cut(u,n);
 264   
 265   
 266  parameter pis_new(i,s),pi_new(i);
 267  *tau_new(j,k,kp);
 268  pis_new(i,s)=ceil(pis(i,s)/1);
 269  pi_new(i)=ceil(pi(i)/1);
 270   
 271  parameter alpha_new(u,i),beta_new(u,i),Cst_new(s);
 272   
 273  alpha_new(u,i)=alpha(u,i);
GAMS 24.5.6  r55090 Released Nov 27, 2015 WEX-WEI x86 64bit/MS Windows                                                                                                                                                                 03/09/16 09:27:54 Page 8
State_Space_Model
C o m p i l a t i o n


 274   
 275  beta_new(u,i)=beta(u,i);
 276   
 277  Cst_new(s)=Cst(s);
 278   
 279   
 280   
 281   
 282  *UTILITY CALCULATIONS NEED TO BE CORRECTED
 283  *RIGHT NOW THERE IS BUG THAT IF THERE IS MORE THAN ONE CHANGE
 284  *WITHIN AN INTERVAL THEN THE CODE TAKES FIRST CHANGE ONLY
 285  *AND IGNORES THE SECOND CHANGE
 286  loop(UtilInt,
 287  *Maximum available utility
 288  Uutmax_full(u,h)$(ord(UtilInt) eq 1 and
 289                   ord(h) ge 1 and
 290                   ord(h)-1 lt (floor(UtilData(UtilInt+1,u,"starttime")/1)$(UtilData(UtilInt,u,"magnitude") gt UtilData(UtilInt+1,u,"magnitude"))+
 291                                ceil(UtilData(UtilInt+1,u,"starttime")/1)$(UtilData(UtilInt,u,"magnitude") le UtilData(UtilInt+1,u,"magnitude")) ))
 292                  =  UtilData(UtilInt,u,"magnitude");
 293   
 294   
 295   
 296   
 297  Uutmax_full(u,h)$((ord(UtilInt) gt 1 and ord(UtilInt) lt card(UtilInt)) and
 298                   ord(h)-1 ge (floor(UtilData(UtilInt,u,"starttime")/1)$(UtilData(UtilInt-1,u,"magnitude") gt UtilData(UtilInt,u,"magnitude"))+
 299                                ceil(UtilData(UtilInt,u,"starttime")/1)$(UtilData(UtilInt-1,u,"magnitude") le UtilData(UtilInt,u,"magnitude")) ) and
 300                   ord(h)-1 lt (floor(UtilData(UtilInt+1,u,"starttime")/1)$(UtilData(UtilInt,u,"magnitude") gt UtilData(UtilInt+1,u,"magnitude"))+
 301                                ceil(UtilData(UtilInt+1,u,"starttime")/1)$(UtilData(UtilInt,u,"magnitude") le UtilData(UtilInt+1,u,"magnitude")) ))
 302                  =  UtilData(UtilInt,u,"magnitude");
 303   
 304   
 305   
 306  Uutmax_full(u,h)$(ord(UtilInt) eq card(UtilInt) and
 307                   ord(h)-1 ge (floor(UtilData(UtilInt,u,"starttime")/1)$(UtilData(UtilInt-1,u,"magnitude") gt UtilData(UtilInt,u,"magnitude"))+
 308                                ceil(UtilData(UtilInt,u,"starttime")/1)$(UtilData(UtilInt-1,u,"magnitude") le UtilData(UtilInt,u,"magnitude")) ) and
 309                   ord(h) le card(h))
 310                  =  UtilData(UtilInt,u,"magnitude");
 311   
 312   
 313  *Utility Price
 314  Cut_full(u,h)$(ord(UtilInt) eq 1 and
 315            ord(h)-1 lt (floor(UtilData(UtilInt+1,u,"starttime")/1))   )
 316            =  UtilData(UtilInt,u,"price");
 317   
 318  Cut_full(u,h)$(ord(UtilInt) gt 1 and ord(UtilInt) lt card(UtilInt) and
 319            ord(h)-1 gt (floor(UtilData(UtilInt,u,"starttime")/1)) and
 320            ord(h)-1 lt (floor(UtilData(UtilInt+1,u,"starttime")/1))   )
 321            =  UtilData(UtilInt,u,"price");
 322   
 323  Cut_full(u,h)$(ord(UtilInt) eq card(UtilInt) and
 324            ord(h)-1 gt floor(UtilData(UtilInt,u,"starttime")/1) and
 325            ord(h) le card(h)   )
 326            =  UtilData(UtilInt,u,"price");
GAMS 24.5.6  r55090 Released Nov 27, 2015 WEX-WEI x86 64bit/MS Windows                                                                                                                                                                 03/09/16 09:27:54 Page 9
State_Space_Model
C o m p i l a t i o n


 327   
 328  Cut_full(u,h)$(ord(UtilInt) gt 1 and
 329           ord(h)-1 eq floor(UtilData(UtilInt,u,"starttime")/1))
 330           =(   UtilData(UtilInt-1,u,"price")*(UtilData(UtilInt,u,"starttime")-(ord(h)-1)* 1 )
 331                +UtilData(UtilInt,u,"price")*(ord(h)*1-UtilData(UtilInt,u,"starttime"))   )/1;
 332  *Bug in cost calculation: what if there are 3 cost levels within one time grid?
 333  )
 334   
 335   
 336  *UnitUnavailabality(note the difference in inequalities as opposed to Utility....1=>unit not available so more magnitude is bad)
 337  loop(UnitInt,
 338  Unitunavailable_full(j,h)$(ord(UnitInt) eq 1 and
 339                   ord(h)-1 ge 0 and
 340                   ord(h)-1 lt (floor(UnitData(UnitInt+1,j,"starttime")/1)$(UnitData(UnitInt,j,"magnitude") lt UnitData(UnitInt+1,j,"magnitude"))+
 341                                ceil(UnitData(UnitInt+1,j,"starttime")/1)$(UnitData(UnitInt,j,"magnitude") ge UnitData(UnitInt+1,j,"magnitude")) ))
 342                  =  UnitData(UnitInt,j,"magnitude");
 343   
 344   
 345   
 346   
 347  Unitunavailable_full(j,h)$((ord(UnitInt) gt 1 and ord(UnitInt) lt card(UnitInt)) and
 348                   ord(h)-1 ge (floor(UnitData(UnitInt,j,"starttime")/1)$(UnitData(UnitInt-1,j,"magnitude") lt UnitData(UnitInt,j,"magnitude"))+
 349                                ceil(UnitData(UnitInt,j,"starttime")/1)$(UnitData(UnitInt-1,j,"magnitude") ge UnitData(UnitInt,j,"magnitude")) ) and
 350                   ord(h)-1 lt (floor(UnitData(UnitInt+1,j,"starttime")/1)$(UnitData(UnitInt,j,"magnitude") lt UnitData(UnitInt+1,j,"magnitude"))+
 351                                ceil(UnitData(UnitInt+1,j,"starttime")/1)$(UnitData(UnitInt,j,"magnitude") ge UnitData(UnitInt+1,j,"magnitude")) ))
 352                  =  UnitData(UnitInt,j,"magnitude");
 353   
 354   
 355   
 356  Unitunavailable_full(j,h)$(ord(UnitInt) eq card(UnitInt) and
 357                   ord(h)-1 ge (floor(UnitData(UnitInt,j,"starttime")/1)$(UnitData(UnitInt-1,j,"magnitude") lt UnitData(UnitInt,j,"magnitude"))+
 358                                ceil(UnitData(UnitInt,j,"starttime")/1)$(UnitData(UnitInt-1,j,"magnitude") ge UnitData(UnitInt,j,"magnitude")) ) and
 359                   ord(h) le card(h))
 360                  =  UnitData(UnitInt,j,"magnitude");
 361  )
 362   
 363   
 364   
 365  *display UnitUnavailable_full,Uutmax_full,Cut_full,Sbari,Si,rhobar,rho,Tbars,Ts,calc;
 366   
 367  *Ijk,tauChangeMax
 368   
 369   
 370   
 371  *Disturbance parameter for loading/unloading of materials
 372  parameters betaHatProd(i,j,s,n),betaHatCons(i,j,s,n);
 373  betaHatProd(i,j,s,n)=0;
 374  betaHatCons(i,j,s,n)=0;
 375   
 376   
 377  *Disturbance parameter for task delays
 378  parameters
 379  Yhat(i,j,n,hbar)
GAMS 24.5.6  r55090 Released Nov 27, 2015 WEX-WEI x86 64bit/MS Windows                                                                                                                                                                03/09/16 09:27:54 Page 10
State_Space_Model
C o m p i l a t i o n


 380  Delay(calc,i,j,hbar)
 381  Zhat(i,j,n,hbar)
 382  Breakdown(calc,i,j,hbar)
 383  Duration_breakdown(calc,j)
 384  UnitBroken(j,n)
 385  WbarInfo(i,j,n,hbar)
 386  BbarInfo(i,j,n,hbar)
 387  KillDuration(i,j)
 388  KillDurationCountdown(i,j)
 389  KillOccupy(j,n)
 390  KillCountdown(j);
 391   
 392  *Initializing parameters
 393  Yhat(i,j,n,hbar)=0;
 394  Delay(calc,i,j,hbar)=0;
 395  Zhat(i,j,n,hbar)=0;
 396  Breakdown(calc,i,j,hbar)=0;
 397  Duration_breakdown(calc,j)=0;
 398  UnitBroken(j,n)=0;
 399  WbarInfo(i,j,n,hbar)=0;
 400  BbarInfo(i,j,n,hbar)=0;
 401  KillDuration(i,j)=0;
 402  KillDurationCountdown(i,j)=0;
 403  KillOccupy(j,n)=0;
 404  KillCountdown(j)=0;
 405   
 406  *hbar are the time points for lifting of variables
 407  *binary variables W(i,j,n),Wbar(i,j,n,hbar),T(i,j,hbar) Kill_Variable;
 408  binary variables Wbar(i,j,n,hbar),T(i,j,hbar) Kill_Variable;
 409  positive variable Bbar(i,j,n,hbar),Sst(s,n),Backlog(s,n),Ship(s,n),Ship_sales(s,n),Uut(u,n),Rst(s,n),SstTerminal(s),BacklogTerminal(s);
 410  variables obj_variable;
 411  integer variable NB(i,j) number of batches;
 412  *Assigning values to variables that might not participate in optimization
 413  Uut.l(u,n)=0;
 414  Ship_sales.l(s,n)=0;
 415   
 416  Equations
 417  numberOfBatches,
 418  Allocation,
 419  UnitCapacityMax,UnitCapacityMin,
 420  InventoryLimit,
 421  InventoryBalance,
 422  EndingInventory,
 423  BacklogBalance,
 424  EndingBacklog,
 425  UtilityLimit,
 426  UtilityBalance,
 427  objective_MIN_COST,
 428  objective_MAX_PROFIT,
 429  objective_MAX_PROFIT_Greedy
 430  UnitUnavailabality,
 431  *CorrectHolding(i,j,n),
 432  LiftingW,
GAMS 24.5.6  r55090 Released Nov 27, 2015 WEX-WEI x86 64bit/MS Windows                                                                                                                                                                03/09/16 09:27:54 Page 11
State_Space_Model
C o m p i l a t i o n


 433  *LiftingW0,
 434  LiftingB,
 435  *LiftingB0,
 436  Carryover_W,Carryover_B,
 437  InventoryBalance_MAX_PROFIT,
 438  EndingInventory_MAX_PROFIT
 439  Ship_constraint(s,n)
 440  NoShip(s,n);
 441  *SHIPMENT;
 442  *NoTaskRunningAtEndOfHorizon;
 443   
 444  numberOfBatches(i,j)$Ij(i,j).. NB(i,j)=E=sum((n,hbar)$(ord(hbar)-1 eq 0),Wbar(i,j,n,hbar));
 445   
 446  *scalar ord_calc /0/;
 447  SCALAR fixed_decisions /0/;
 448  SCALAR reschedule_flag /0/;
 449  *re_freq-1-mod(ord_calc-1+re_freq-1,re_freq)  is zero for calc0
 450  Carryover_W(i,j,n,hbar)$(ord(n)-1 le fixed_decisions and ord(hbar)-1 ge 1 and ord(hbar)-1 le pi(i) and Ij(i,j))..Wbar(i,j,n,hbar)=E=WbarInfo(i,j,n,hbar)*(1-T(i,j,hbar))*(1-Zhat(i,j,n,hbar));
 451  Carryover_B(i,j,n,hbar)$(ord(n)-1 le fixed_decisions and ord(hbar)-1 ge 1 and ord(hbar)-1 le pi(i) and Ij(i,j))..Bbar(i,j,n,hbar)=E=BbarInfo(i,j,n,hbar)*(1-T(i,j,hbar))*(1-Zhat(i,j,n,hbar));
 452   
 453  *LiftingW(i,j,n,hbar)$((ord(hbar)-1 ge 1) and (ord(hbar)-1 le pi(i)) and (ord(n) lt card(n)) and Ij(i,j))..
 454  *         Wbar(i,j,n+1,hbar)=E=Wbar(i,j,n,hbar-1)+Yhat(i,j,n,hbar)-Yhat(i,j,n,hbar-1)-Zhat(i,j,n,hbar-1);
 455  *LiftingB(i,j,n,hbar)$((ord(hbar)-1 ge 1) and (ord(hbar)-1 le pi(i)) and (ord(n) lt card(n)) and Ij(i,j))..
 456  *         Bbar(i,j,n+1,hbar)=E=Bbar(i,j,n,hbar-1)+Bbar(i,j,n,hbar)*Yhat(i,j,n,hbar)-Bbar(i,j,n,hbar-1)*Yhat(i,j,n,hbar-1)
 457   
 458  LiftingW(i,j,n,hbar)$((ord(hbar)-1 ge 1) and (ord(hbar)-1 le pi(i)) and (ord(n) lt card(n)) and Ij(i,j))..
 459           Wbar(i,j,n+1,hbar)=E=Wbar(i,j,n,hbar-1)+Yhat(i,j,n,hbar)-Yhat(i,j,n,hbar-1);
 460   
 461  LiftingB(i,j,n,hbar)$((ord(hbar)-1 ge 1) and (ord(hbar)-1 le pi(i)) and (ord(n) lt card(n)) and Ij(i,j))..
 462           Bbar(i,j,n+1,hbar)=E=Bbar(i,j,n,hbar-1)+Bbar(i,j,n,hbar)*Yhat(i,j,n,hbar)-Bbar(i,j,n,hbar-1)*Yhat(i,j,n,hbar-1);
 463  Allocation(j,n).. sum((i,hbar)$(Ij(i,j) and (ord(hbar) -1 le (pi_new(i)-1)) ), Wbar(i,j,n,hbar))=L=1-sum((i,hbar)$(Ij(i,j) and (ord(hbar) -1 eq pi_new(i)) ) , Yhat(i,j,n,hbar))-UnitBroken(j,n)
 464                        -sum((i,hbar)$(Ij(i,j) and ord(hbar)-1 ge 1 and ord(hbar)-1 le pi(i)),T(i,j,hbar)$(ord(n)-1 lt KillDuration(i,j)))-KillOccupy(j,n);
 465  *ord(np)-1=0 => Wbar0 which is also included in the above sum, so we dont have to explicitly sum over W now since W0 is also there
 466   
 467  UnitCapacityMax(i,j,n,hbar)$(Ij(i,j) and ord(hbar)-1 eq 0).. Bbar(i,j,n,hbar)=L=Wbar(i,j,n,hbar)*vmaxij(i,j);
 468   
 469  UnitCapacityMin(i,j,n,hbar)$(Ij(i,j) and ord(hbar)-1 eq 0).. Bbar(i,j,n,hbar)=G=Wbar(i,j,n,hbar)*vminij(i,j);
 470   
 471  InventoryLimit(s,n)$(FIS(s)).. Sst(s,n)=L=Cs(s);
 472   
 473  *Watch out for brackets in betahatCons and betaHatProd. One has multiplication with rho other does not
 474  InventoryBalance(s,n)$(ord(n) lt card(n)).. Sst(s,n+1)=E=Sst(s,n)+sum((i,j,hbar)$(Tbars(i,s) and Ij(i,j) and (ord(hbar) -1 eq pis_new(i,s))),rhobar(i,s)*(Bbar(i,j,n,hbar)*(1-Yhat(i,j,n,hbar)-Zhat(i,j,n,hbar))+betaHatProd(i,j,s,n)))
 475                           -sum((i,j,hbar)$(Ts(i,s) and Ij(i,j) and ord(hbar) eq 1),rho(i,s)*Bbar(i,j,n,hbar)+betaHatCons(i,j,s,n)) -Ship(s,n)$(product_states(s))+Rst(s,n)$(feed_states(s));
 476  EndingInventory(s,n)$(ord(n) eq card(n)).. SstTerminal(s)=E=Sst(s,n)+sum((i,j,hbar)$(Tbars(i,s) and Ij(i,j) and (ord(hbar) -1 eq pis_new(i,s))),rhobar(i,s)*(Bbar(i,j,n,hbar)*(1-Yhat(i,j,n,hbar)-Zhat(i,j,n,hbar))+betaHatProd(i,j,s,n)))
 477                           -sum((i,j,hbar)$(Ts(i,s) and Ij(i,j)and ord(hbar) eq 1),rho(i,s)*Bbar(i,j,n,hbar)+betaHatCons(i,j,s,n)) -Ship(s,n)$(product_states(s))+Rst(s,n)$(feed_states(s));
 478   
 479  ********
 480  *Inventory at point 2 means, inventory level infinitesimal time just before point 2, ie 2-, need to define extra ending inventory variable SstTerminal(s)
 481  *Deliveries are point functions like B, W while inventory is interval function
 482  *Kondili has convention that inventory at point 2 is 2+, so has to define extra initial inventory parameter Sst0(s)
 483   
 484   
 485  ***********Backlogs******
GAMS 24.5.6  r55090 Released Nov 27, 2015 WEX-WEI x86 64bit/MS Windows                                                                                                                                                                03/09/16 09:27:54 Page 12
State_Space_Model
C o m p i l a t i o n


 486  BacklogBalance(s,n)$(product_states(s) and ord(n) lt card(n)).. Backlog(s,n+1)=E=Backlog(s,n)-Ship(s,n)+Dst(s,n);
 487  EndingBacklog(s,n)$(product_states(s) and ord(n) eq card(n)).. BacklogTerminal(s)=E=Backlog(s,n)-Ship(s,n)+Dst(s,n);
 488   
 489  ***********UtilityBalance******
 490  UtilityLimit(u,n).. Uut(u,n)=L=Uutmax(u,n);
 491  UtilityBalance(u,n).. Uut(u,n)=E=sum((i,j,hbar)$(Ij(i,j) and (ord(hbar)-1 le pi_new(i)-1)),alpha_new(u,i)*Wbar(i,j,n,hbar)+beta_new(u,i)*Bbar(i,j,n,hbar)  );
 492   
 493  UnitUnavailabality(i,j,n)$(UnitUnavailable(j,n) and Ij(i,j)).. sum((hbar)$(ord(hbar)-1 le pi_new(i)-1),Wbar(i,j,n,hbar))=E=0;
 494   
 495  *Utility cost: sum((u,n),Cut(u,n)*Uut(u,n))
 496  *objective_MIN_COST.. obj_variable  =E= 1E1*sum(s,Cst_new(s)*SstTerminal(s)) +1E1*sum((s,n),Cst_new(s)*Sst(s,n))
 497  *                                 +1E2*sum((s,n)$(product_states(s)),Cst_new(s)*Backlog(s,n))+1E2*sum(s$(product_states(s)),Cst_new(s)*BacklogTerminal(s))
 498  *                                 +sum((i,j,hbar)$Ij(i,j),T(i,j,hbar));
 499  objective_MIN_COST.. obj_variable  =E= 1E1*sum(s,Cst_new(s)*SstTerminal(s)) + 1E1*sum((s,n),Cst_new(s)*Sst(s,n))
 500                                   +1E2*sum((s,n)$(product_states(s)),Cst_new(s)*Backlog(s,n))
 501                                   +1E2*sum(s$(product_states(s)),Cst_new(s)*BacklogTerminal(s))
 502                                   +sum((i,j,n,hbar)$(Ij(i,j) AND ord(hbar)-1 eq 0),Wbar(i,j,n,hbar));
 503   
 504   
 505  *objective_MAX_PROFIT.. obj_variable =E= 1E1*sum(s$(product_states(s)),Cst_new(s)*SstTerminal(s))+1E1*sum((s,n)$(product_states(s)),Cst_new(s)*Ship(s,n))
 506  *                                       -1E2*sum((s,n)$(product_states(s)),Cst_new(s)*Backlog(s,n))-1E2*sum(s$(product_states(s)),Cst_new(s)*BacklogTerminal(s) );
 507   
 508  *objective_MAX_PROFIT.. obj_variable =E= 1E1*sum((s,n)$(product_states(s)),Cst_new(s)*Sst(s,n))+1E1*sum(s$(product_states(s)),Cst_new(s)*SstTerminal(s))
 509  *                                       -1E2*sum((s,n)$(product_states(s)),Cst_new(s)*Backlog(s,n))-1E2*sum(s$(product_states(s)),Cst_new(s)*BacklogTerminal(s))
 510  *                                       +1E1*sum((s,n)$(product_states(s)),Cst_new(s)*Ship(s,n));
 511   
 512  *objective_MAX_PROFIT.. obj_variable =E= sum((s,n)$(product_states(s)),round(2-ord(n)/card(n),2)*Cst_new(s)*Ship(s,n))-sum((i,j,n,hbar)$(Ij(i,j) AND ord(hbar)-1 eq 0),Wbar(i,j,n,hbar));
 513   
 514  *objective_MAX_PROFIT.. obj_variable =E= sum((s,n)$(product_states(s)),Cst_new(s)*(Ship_sales(s,n)))
 515  objective_MAX_PROFIT.. obj_variable =E= sum((s,n)$(product_states(s)),Cst_new(s)*(Ship_sales(s,n)+Ship(s,n)))
 516                                           -sum((i,j,n,hbar)$(Ij(i,j) AND ord(hbar)-1 eq 0),Wbar(i,j,n,hbar))
 517                                           -1E2*sum((s,n)$(product_states(s)),Cst_new(s)*Backlog(s,n))
 518                                           -1E2*sum(s$(product_states(s)),Cst_new(s)*BacklogTerminal(s));
 519   
 520  objective_MAX_PROFIT_Greedy.. obj_variable =E= sum((s,n)$(product_states(s)),round(2-(ord(n)/card(n)),2)*Cst_new(s)*(Ship(s,n)+Ship_sales(s,n)))
 521                                           -sum((i,j,n,hbar)$(Ij(i,j) AND ord(hbar)-1 eq 0),Wbar(i,j,n,hbar))
 522                                           -1E2*sum((s,n)$(product_states(s)),Cst_new(s)*Backlog(s,n))
 523                                           -1E2*sum(s$(product_states(s)),Cst_new(s)*BacklogTerminal(s));
 524   
 525  *objective_MAX_PROFIT.. obj_variable =E= sum((s,n)$(product_states(s)),round(2-ord(n)/card(n),2)*Cst_new(s)*Ship(s,n));
 526   
 527  *SHIPMENT(s,n).. Ship(s,n)=L=Dst(s,n)  ;
 528  InventoryBalance_MAX_PROFIT(s,n)$(ord(n) lt card(n)).. Sst(s,n+1)=E=Sst(s,n)
 529                           +sum((i,j,hbar)$(Tbars(i,s) and Ij(i,j) and (ord(hbar) -1 eq pis_new(i,s))),rhobar(i,s)*Bbar(i,j,n,hbar))
 530                           -sum((i,j,hbar)$(Ts(i,s) and Ij(i,j) and ord(hbar) eq 1),rho(i,s)*Bbar(i,j,n,hbar))
 531                           -Ship_sales(s,n)$(product_states(s))-Ship(s,n)$(product_states(s))+Rst(s,n)$(feed_states(s));
 532   
 533  EndingInventory_MAX_PROFIT(s,n)$(ord(n) eq card(n)).. SstTerminal(s)=E=Sst(s,n)
 534                           +sum((i,j,hbar)$(Tbars(i,s) and Ij(i,j) and (ord(hbar) -1 eq pis_new(i,s))),rhobar(i,s)*Bbar(i,j,n,hbar))
 535                           -sum((i,j,hbar)$(Ts(i,s) and Ij(i,j)and ord(hbar) eq 1),rho(i,s)*Bbar(i,j,n,hbar))
 536                           -Ship(s,n)$(product_states(s))-Ship_sales(s,n)$(product_states(s))+Rst(s,n)$(feed_states(s));
 537   
 538  *Ship_constraint(s,n)$(ord(n) gt 1 AND ord(n) lt card(n) ).. Ship(s,n)=E=0;
GAMS 24.5.6  r55090 Released Nov 27, 2015 WEX-WEI x86 64bit/MS Windows                                                                                                                                                                03/09/16 09:27:54 Page 13
State_Space_Model
C o m p i l a t i o n


 539  *Ship_constraint(s,n)$(Dst(s,n) eq 0).. Ship_sales(s,n)=E=0;
 540  Ship_constraint(s,n)$(NOT Dst(s,n) gt 0).. Ship_sales(s,n)=E=0;
 541   
 542  *NoTaskRunningAtEndOfHorizon(i,j,n)$(ord(n) eq card(n) and Ij(i,j))..   sum(hbar$(ord(hbar)-1 le pi_new(i)-1),Wbar(i,j,n,hbar))=E=0;
 543  NoShip(s,n)$(ord(n) lt card(n)/2 and sameas(s,'M4')).. Ship_sales(s,n)=E=0;
 544  *NoShip(s,n)$(ord(n) lt card(n)/2).. Ship_sales(s,n)=E=0;
 545   
 546  *****************
 547  *DISTURBANCE VARIABLES
 548  *Build feature rich instances and do rigorous testing
 549  *****************
 550   
 551  SET attributes_states /W,B/;
 552  PARAMETERS
 553  record_states_raw(run,calc,attributes_states,i,j,n,hbar),
 554  record_states(run,calc,attributes_states,i,j,n,hbar),
 555  record_objective(run,calc),
 556  record_utility(run,calc,u,n),
 557  record_inventory(run,calc,s,n),
 558  record_inventory_raw(run,calc,s,n),
 559  record_backlog(run,calc,s,n),
 560  record_backlog_raw(run,calc,s,n),
 561  record_inventoryTerminal(run,calc,s),
 562  record_backlogTerminal(run,calc,s)
 563  record_T(run,calc,i,j,hbar)
 564  record_shipment(run,calc,s,n)
 565  record_shipment_sales(run,calc,s,n)
 566  record_shipment_sales_raw(run,calc,s,n)
 567  record_Rst(run,calc,s,n)
 568  record_shipment_raw(run,calc,s,n)
 569  record_Rst_raw(run,calc,s,n)
 570  record_yieldloss(run,calc,i,j,s,n)
 571  record_demands(run,calc,s,n)
 572  record_WbarInfo(run,calc,i,j,n,hbar)
 573  record_BbarInfo(run,calc,i,j,n,hbar)
 574  record_Demands_realization(run,s,h)
 575  record_fixed_decision(calc)
 576  record_reschedule_flag(calc,run)
 577  record_relaxed_objective(run,calc) Objective from solving RMIP
 578  record_relaxed_states(run,calc,attributes_states,i,j,n,hbar) states from solving RMIP
 579  record_relaxed_shipment(run,calc,s,n)
 580  record_relaxed_shipment_sales(run,calc,s,n)
 581  record_relaxed_backlog(run,calc,s,n);
 582   
 583  record_states_raw(run,calc,attributes_states,i,j,n,hbar)=0;
 584  record_states(run,calc,'B',i,j,n,hbar)=0;
 585  record_states(run,calc,'W',i,j,n,hbar)=0;
 586  record_inventory(run,calc,s,n)=0;
 587  record_inventory_raw(run,calc,s,n)=0;
 588  record_backlog(run,calc,s,n)=0;
 589  record_backlog_raw(run,calc,s,n)=0;
 590  record_T(run,calc,i,j,hbar)=0;
 591  record_shipment(run,calc,s,n)=0 ;
GAMS 24.5.6  r55090 Released Nov 27, 2015 WEX-WEI x86 64bit/MS Windows                                                                                                                                                                03/09/16 09:27:54 Page 14
State_Space_Model
C o m p i l a t i o n


 592  record_Rst(run,calc,s,n)=0;
 593  record_shipment_raw(run,calc,s,n)=0;
 594  record_shipment_sales_raw(run,calc,s,n)=0;
 595  record_shipment_sales(run,calc,s,n)=0;
 596  record_Rst_raw(run,calc,s,n)=0;
 597  record_yieldloss(run,calc,i,j,s,n)=0;
 598  record_demands(run,calc,s,n)=0;
 599  record_WbarInfo(run,calc,i,j,n,hbar)=0;
 600  record_BbarInfo(run,calc,i,j,n,hbar)=0;
 601  record_Demands_realization(run,s,h)=0;
 602  record_fixed_decision(calc)=0;
 603  record_reschedule_flag(calc,run)=0;
 604  record_relaxed_objective(run,calc)=0;
 605  record_relaxed_states(run,calc,attributes_states,i,j,n,hbar)=0;
 606  record_relaxed_shipment(run,calc,s,n)=0;
 607  record_relaxed_shipment_sales(run,calc,s,n)=0;
 608  record_relaxed_backlog(run,calc,s,n)=0;
 609   
 610  *Initial conditions for first optimization horizon
 611  PARAMETERS InitialBbar(i,j,n,hbar),InitialWbar(i,j,n,hbar),InitialInventory(s),InitialBacklog(s);
 612  InitialBbar(i,j,n,hbar)=0;
 613  InitialWbar(i,j,n,hbar)=0;
 614  InitialInventory(s)=0;
 615  InitialBacklog(s)=0;
 616   
 617  *if (%InitialInventoryFlag% eq 1,
 618  *Start with half day of inventory
 619  *InitialInventory(s)$product_states(s)=12*demand_magnitude/demand_cycletime;
 620  *);
 621  InitialInventory(s)$product_states(s)=12*demand_magnitude/demand_cycletime;
 622   
 623   
 624  *MODEL P1 /all/;
 625  MODEL MIN_COST /
 626  numberOfBatches,
 627  Allocation,
 628  UnitCapacityMax,
 629  UnitCapacityMin,
 630  *InventoryLimit,
 631  InventoryBalance,
 632  EndingInventory,
 633  BacklogBalance,
 634  EndingBacklog,
 635  *UtilityLimit,
 636  *UtilityBalance,
 637  *UnitUnavailabality,
 638  LiftingW,
 639  LiftingB,
 640  Carryover_W,
 641  Carryover_B,
 642  objective_MIN_COST/;
 643   
 644  MODEL MAX_PROFIT_1 /
GAMS 24.5.6  r55090 Released Nov 27, 2015 WEX-WEI x86 64bit/MS Windows                                                                                                                                                                03/09/16 09:27:54 Page 15
State_Space_Model
C o m p i l a t i o n


 645  numberOfBatches,
 646  Allocation,
 647  UnitCapacityMax,
 648  UnitCapacityMin,
 649  Carryover_B
 650  InventoryBalance_MAX_PROFIT,
 651  LiftingW,
 652  BacklogBalance
 653  LiftingB,
 654  Carryover_W,
 655  objective_MAX_PROFIT
 656  Ship_constraint
 657  EndingInventory_MAX_PROFIT,
 658  EndingBacklog/;
 659   
 660  MODEL MAX_PROFIT_2 /
 661  numberOfBatches,
 662  Allocation,
 663  UnitCapacityMax,
 664  UnitCapacityMin,
 665  InventoryBalance_MAX_PROFIT,
 666  EndingInventory_MAX_PROFIT,
 667  BacklogBalance,
 668  EndingBacklog,
 669  LiftingW,
 670  LiftingB,
 671  Carryover_W,
 672  Carryover_B,
 673  objective_MAX_PROFIT
 674  Ship_constraint/;
 675   
 676  MODEL MAX_PROFIT_GREEDY /
 677  numberOfBatches,
 678  Allocation,
 679  UnitCapacityMax,
 680  UnitCapacityMin,
 681  InventoryBalance_MAX_PROFIT,
 682  EndingInventory_MAX_PROFIT,
 683  BacklogBalance,
 684  EndingBacklog,
 685  LiftingW,
 686  LiftingB,
 687  Carryover_W,
 688  Carryover_B,
 689  *objective_MAX_PROFIT
 690  objective_MAX_PROFIT_Greedy
 691  Ship_constraint/;
 692  *NoShip/;
 693   
 694  MODEL MAX_PROFIT_NOSHIP /
 695  numberOfBatches,
 696  Allocation,
 697  UnitCapacityMax,
GAMS 24.5.6  r55090 Released Nov 27, 2015 WEX-WEI x86 64bit/MS Windows                                                                                                                                                                03/09/16 09:27:54 Page 16
State_Space_Model
C o m p i l a t i o n


 698  UnitCapacityMin,
 699  InventoryBalance_MAX_PROFIT,
 700  EndingInventory_MAX_PROFIT,
 701  BacklogBalance,
 702  EndingBacklog,
 703  LiftingW,
 704  LiftingB,
 705  Carryover_W,
 706  Carryover_B,
 707  objective_MAX_PROFIT
 708  *objective_MAX_PROFIT_Greedy
 709  Ship_constraint
 710  NoShip/;
 711   
 712  MODEL MAX_PROFIT_GREEDY_NOSHIP /
 713  numberOfBatches,
 714  Allocation,
 715  UnitCapacityMax,
 716  UnitCapacityMin,
 717  InventoryBalance_MAX_PROFIT,
 718  EndingInventory_MAX_PROFIT,
 719  BacklogBalance,
 720  EndingBacklog,
 721  LiftingW,
 722  LiftingB,
 723  Carryover_W,
 724  Carryover_B,
 725  *objective_MAX_PROFIT
 726  objective_MAX_PROFIT_Greedy
 727  Ship_constraint
 728  NoShip/;
 729   
 730  *SHIPMENT/;
 731   
 732   
 733  T.l(i,j,hbar)=0;
 734  *Parameters for Gantt Charting in Excel
 735  *END OF MODEL FILE
 736   
 737   
 738   
 739   
 740  PARAMETER runcost(run) cost of implemented closed loop
 741           runcost_Inv(run) Inventory cost,runcost_BO(run) Backlog cost, runcost_W(run) start_cost_of_tasks
 742           runprofit(run) closed loop profit in MAX_profit
 743           sales_profit(run);
 744   
 745           runcost_Inv(run)=0;runcost_BO(run)=0; runcost_W(run)=0;runcost(run)=0; runprofit(run)=0;sales_profit(run)=0;
 746   
 747  PARAMETER modelStat(calc,run)     Should be 1 for successful optimization
 748            BOStat_OL(calc,run)     If 1 means open loop had non zero back order
 749            BOStat_CL(calc,run)     If 1 means closed loop had non zero back order
 750            IntegralityGap(calc,run)
GAMS 24.5.6  r55090 Released Nov 27, 2015 WEX-WEI x86 64bit/MS Windows                                                                                                                                                                03/09/16 09:27:54 Page 17
State_Space_Model
C o m p i l a t i o n


 751            Est_modelGap1(calc,run)  Estimated optimality gap by CPLEX (obj.val in denominator)
 752            Est_modelGap2(calc,run)  Estimated optimality gap by CPLEX (obj.Est in denominator)
 753            True_modelGap(calc,run) True optimality gap obtained by solving to optcr=0
 754            ETSolve(calc,run)
 755            ETSolver(calc,run)
 756            iterUsd(calc,run)
 757            nodUsd(calc,run)
 758            resUsd(calc,run)
 759            numDVar(calc,run)
 760            numEqu(calc,run)
 761            numInfes(calc,run)
 762            numNZ(calc,run)
 763            numVar(calc,run)
 764            solveStat(calc,run)
 765            Suboptimal_objective /0/
 766            Optimal_Objective /0/;
      ********************DEMAND SAMPLING TO KEEP IT STANDARDIZED FOR ALL APPROACHES(NOMINAL, ROBUST, STOCHASTIC)************************
      ******DEMAND INFORMATION*****************************
      *Each order for all products
      SET         o orders /o1*o%H%/;
      PARAMETER deliveries_time(o,run);
      deliveries_time(o,run)=demand_cycletime*ord(o);
      PARAMETER deliveries(o,s);
      deliveries(o,s)$(product_states(s))=demand_magnitude;
      ******DEMAND INFORMATION*****************************
       
      PARAMETER Dst_full(s,h);
      Dst_full(s,h)=sum(o,deliveries(o,s)$(ord(h)-1 eq floor(deliveries_time(o)/%delta%)));
       
      PARAMETER Dst_full_realization(s,h,run);
      Dst_full_realization(s,h,run)=Dst_full(s,h);
       
      *IF(%Demand_Disturbance_flag% eq 1,
               LOOP(run,
                  deliveries_time(o,run)=deliveries_time(o,run)+UniformInt(-demand_variation,demand_variation);
                  Dst_full_realization(s,h,run)=(Dst_full(s,h)+Dst_full(s,h)*uniformInt(-lambda_Demand,lambda_Demand)  )$(Dst_full(s,h) gt 0);
               );
      *);
      ********************DEMAND SAMPLING TO KEEP IT STANDARDIZED FOR ALL APPROACHES(NOMINAL, ROBUST, STOCHASTIC)************************
 792  ********************DEMAND SAMPLING TO KEEP IT STANDARDIZED FOR ALL APPROACHES(NOMINAL, ROBUST, STOCHASTIC)************************
 793  ******DEMAND INFORMATION*****************************
 794  *Each order for all products
 795  SET         o orders /o1*o216/;
 796  PARAMETER deliveries_time(o,run);
 797  deliveries_time(o,run)=demand_cycletime*ord(o);
 798  PARAMETER deliveries(o,s);
 799  deliveries(o,s)$(product_states(s))=demand_magnitude;
 800  ******DEMAND INFORMATION*****************************
 801   
 802  PARAMETER Dst_full_realization(s,h,run),Dst_full(s,h);
 803   
 804  *IF(%Demand_Disturbance_flag% eq 1,
 805  LOOP(run,
GAMS 24.5.6  r55090 Released Nov 27, 2015 WEX-WEI x86 64bit/MS Windows                                                                                                                                                                03/09/16 09:27:54 Page 18
State_Space_Model
C o m p i l a t i o n


 806    deliveries_time(o,run)=deliveries_time(o,run)+UniformInt(-demand_variation,demand_variation);
 807    Dst_full_realization(s,h,run)=sum(o,deliveries(o,s)$(ord(h)-1 eq floor(deliveries_time(o,run)/1)));
 808    Dst_full_realization(s,h,run)=(Dst_full_realization(s,h,run)+Dst_full_realization(s,h,run)/100*uniformInt(-lambda_Demand*100,lambda_Demand*100)  )$(Dst_full_realization(s,h,run) gt 0);
 809  );
 810  *);
 811  ********************DEMAND SAMPLING TO KEEP IT STANDARDIZED FOR ALL APPROACHES(NOMINAL, ROBUST, STOCHASTIC)************************
 812   
 813   
 814  PARAMETER ClosedLoopINV(run,s,h),ClosedLoopBO(run,s,h),ClosedLoopShip(run,s,h),ClosedLoopShip_sales(run,s,h),
 815            ClosedLoopStart(run,h),Cost_EndInventory(run);
 816  ClosedLoopINV(run,s,h)=0;
 817  ClosedLoopBO(run,s,h)=0;
 818  ClosedLoopShip(run,s,h)=0;
 819  ClosedLoopShip_sales(run,s,h)=0;
 820  ClosedLoopStart(run,h)=0;
 821  Cost_EndInventory(run)=0;
 822  *This parameter switches to 1 at end of this file
 823  *indicating a succesful run(sweep of code) throughout
 824  PARAMETER SUCCESS /0/;
 825   
 826   
 827  PARAMETER timeLeft /0/;
 828  PARAMETER endingSeed /0/;
 829  *PARAMETER sample /0/;
 830   
 831  ********************STOPPING CRITERION*************
      PARAMETER mean_runcost(run), std_dev_runcost(run), delta_std_dev_runcost(run), max_delta_std_dev_runcost(run), N_run count of runs;
      mean_runcost(run)=0;
      std_dev_runcost(run)=0;
      delta_std_dev_runcost(run)=0;
      max_delta_std_dev_runcost(run)=0;
      N_run=0;
      ALIAS(run,run_p);
      ********************STOPPING CRITERION*************
 842   
 843  ********************[Start] Evaluations Runs ***************************************
 844  loop(run,
      put screen;
      put 'I am on run ' run.tl;
      putclose;
      put log;
      put 'I am on run ' run.tl;
      putclose;
 853   
 854  *We need to reset Dst_full(s,h) with each run to nominal values
 855  *and then as MH goes forward, Dst_full slowly takes the value of Dst_full_realization
 856  *for that particular run, after which here we need to refresh it to nominal values
 857  Dst_full(s,h)=sum(o,deliveries(o,s)$(ord(h)-1 eq floor(deliveries_time(o,run)/1)));
 858   
 859  if(0 eq 1,
 860  abort$1 "Look into robust case demand generation in MasterFile and make sure its correct";
 861           Dst_full(s,h)=Dst_full(s,h)*(1+ lambda_Demand);
 862  );
GAMS 24.5.6  r55090 Released Nov 27, 2015 WEX-WEI x86 64bit/MS Windows                                                                                                                                                                03/09/16 09:27:54 Page 19
State_Space_Model
C o m p i l a t i o n


 863  *this time sample is equal to 1, so we are in evaluation mode
INCLUDE    C:\Users\dhruv\Box Sync\Work\Codes_OnlineMethods\GAMS_Greedy\ModelSolution9.gms
 865  loop(calc,
 866  *Caution: Watch out W equations in case changeovers are involved with regards to lifting(pi(i)+tauC)
 867  *fixed_decisions=re_freq-1-mod(ord(calc)-1+re_freq-1,re_freq);
 868  *abort$1 "stopped for debugging";
 869  *abort$(ord(calc)-1 eq 1) "stopped for debugging";
 870   
 871  *********VARIABLE RESCHEDULING FREQUENCY********
 872  *resetting old parameter values
 873  WbarInfo(i,j,n,hbar)=0;
 874  BbarInfo(i,j,n,hbar)=0;
 875   
 876  *DEMAND SAMPLING
 877  *Picking realized demand upto surprise factor within MH from demand_sample generated for this run
 878          Dst_full(s,h)$(ord(h)-1 le (ord(calc)-1 + ceil(card(n)*(1-surprise))) )=Dst_full_realization(s,h,run);
 879  *Now allocating demands to the rolling horizon calculation
 880          Dst(s,n)=sum(h$((ord(h)-1) eq (ord(n)-1+ord(calc)-1)),Dst_full(s,h));
 881   
 882   
      * EVENT BASED RESCHEDULING (HAS BUG: when moving horizon is shorter than rescheduling freq, more decisions
      *are wrongly fixed)
      if (re_freq=0,
      *Reschedule flag is 1 for first optimization
              reschedule_flag=0;
      *Now see if we should reschedule or not depending on whether new demand came or not
              reschedule_flag=1$(sum((s,n)$(ord(n) eq card(n)),Dst(s,n)) > 0);
      *Also do find schedule for the very first optimization
              reschedule_flag$(ord(calc)-1 eq 0)=1;
      *Now decide the fixed decisions (W,B) depending on rescheduling_flag
              if (reschedule_flag=1,
      *Complete freedom to start new tasks (subject to old tasks not already running)
                      fixed_decisions=0;
              else
      *Forced to follow previous fixed (planned) decisions
                      fixed_decisions=card(n)-1;
              );
      else
 903          fixed_decisions=re_freq-1 - mod(ord(calc)-1+(re_freq-1),re_freq);
 904          reschedule_flag=0;
 905          reschedule_flag$(fixed_decisions=0)=1;
 906  *);
 907  record_fixed_decision(calc)=fixed_decisions;
 908  record_reschedule_flag(calc,run)=reschedule_flag;
 909   
 910  *Unfix fixed variables
 911  Ship.lo(s,n)=0;Ship.up(s,n)=Inf;
 912  Rst.lo(s,n)=0;Rst.up(s,n)=Inf;
 913  Ship_sales.lo(s,n)=0;Ship_sales.up(s,n)=Inf;
 914  *Uut.lo(u,n)=0; Uut.up(u,n)=Inf;
 915  *Fix Input states
 916  WbarInfo(i,j,n,hbar)$(ord(n)-1 le fixed_decisions and ord(hbar)-1 le pi(i) and Ij(i,j))=record_states(run,calc-1,'W',i,j,n,hbar-1)+InitialWbar(i,j,n,hbar)$(ord(calc)-1 eq 0)+Yhat(i,j,n,hbar)-Yhat(i,j,n,hbar-1);
 917  BbarInfo(i,j,n,hbar)$(ord(n)-1 le fixed_decisions and ord(hbar)-1 le pi(i) and Ij(i,j))=record_states(run,calc-1,'B',i,j,n,hbar-1)+InitialBbar(i,j,n,hbar)$(ord(calc)-1 eq 0)+record_states(run,calc-1,'B',i,j,n,hbar)*Yhat(i,j,n,hbar)-record_states(run
GAMS 24.5.6  r55090 Released Nov 27, 2015 WEX-WEI x86 64bit/MS Windows                                                                                                                                                                03/09/16 09:27:54 Page 20
State_Space_Model
C o m p i l a t i o n


      ,calc-1,'B',i,j,n,hbar-1)*Yhat(i,j,n,hbar-1);
 918  Ship.fx(s,n)$(ord(n)-1 le fixed_decisions-1)=record_shipment(run,calc-1,s,n+1);
 919  Rst.fx(s,n)$(ord(n)-1 le fixed_decisions-1)=record_Rst(run,calc-1,s,n+1);
 920  Ship_sales.fx(s,n)$(ord(n)-1 le fixed_decisions-1)=record_shipment_sales(run,calc-1,s,n+1);
 921  T.fx(i,j,hbar)=0;
 922  *********VARIABLE RESCHEDULING FREQUENCY********
 923   
 924  *Since inventory and backlog depend on the inputs, as long as we have correctly carried over the inventory we are good
 925  Sst.fx(s,n)$(ord(n)-1 le 0)=record_inventory(run,calc-1,s,n+1)+InitialInventory(s)$(ord(calc)-1 eq 0);
 926  Backlog.fx(s,n)$(ord(n)-1 le 0)=record_backlog(run,calc-1,s,n+1)+InitialBacklog(s)$(ord(calc)-1 eq 0);
 927  *Uut.fx(u,n)$(ord(n)-1 le 0)=record_utility(run,calc-1,u,n+1);
 928   
 929   
 930  *Fix backlogs to zero if corresponding flag is 0
 931  if(0 eq 0,
 932  Backlog.fx(s,n)=0;
 933  BacklogTerminal.fx(s)=0;
 934  );
 935  *Dst(s,n)$(product_states(s) AND ord(n) eq 1) = 1;
 936  *Ship_sales.fx(s,n)$(ord(n)-1 eq 0 AND sameas(s,'M4')) = 8.05;
 937  *Ship_sales.fx(s,n)$(ord(n) lt card(n)) = 0;
 938   
 939  *cc=execseed;
 940  ***************SAMPLING DISTURBANCES/UNCERTAINTIES******************************
 941  *Introducing disturbance in demand by modifying Dst_full(s,h) only if Disturbance flag is 1(on)
 942  *if(%Demand_Disturbance_Flag% eq 1,
 943  *);
 944   
 945  **UNCOMMENT HERE TO HERE  (commented for event based rescheduling)
 946  **        Dst_full(s,h)$(ord(h)-1 le (ord(calc)-1 + ceil(card(n)*(1-surprise))) )=Dst_full_realization(s,h,run);
 947  *Now allocating demands to the rolling horizon calculation
 948  *        Dst(s,n)=sum(h$((ord(h)-1) eq (ord(n)-1+ord(calc)-1)),Dst_full(s,h));
 949  **UNCOMMENT HERE TO HERE
 950  *Display Dst_full;
 951   
 952   
 953  *UnitBreakdown disturbance
 954  *First breakdown unit for whole horizon and then sample after 1 time step
 955  *when it is coming back
 956  UnitBroken(j,n)=0;
 957  Zhat(i,j,n,hbar)=0;
 958  if(0 eq 1 and ord(calc)-1 ge 2,
 959           Breakdown(calc,i,j,hbar)$(Ij(i,j) and ord(hbar)-1 le pi(i) and Delay(calc-1,i,j,hbar-1) eq 0)=1$(uniform(0,1) gt 0.9 and Duration_breakdown(calc-1,j) eq 0 and (sum(n$(ord(n)-1 eq 0),record_states(run,calc-1,'W',i,j,n,hbar-1)) gt 0));
 960   
 961  *If there is a delay ongoing then sample this breakdown
 962           Breakdown(calc,i,j,hbar)$(Ij(i,j) and ord(hbar)-1 le pi(i) and Delay(calc-1,i,j,hbar) gt 0)=1$(uniform(0,1) gt 0.9 and Duration_breakdown(calc-1,j) eq 0 and (sum(n$(ord(n)-1 eq 0),record_states(run,calc-1,'W',i,j,n,hbar)) gt 0));
 963   
 964  *Assume on breakdown that the unit by default is not available the whole remaining horizon and then
 965  *resample after one time step when it is due to come back[here half of rolling horizon length]
 966   
 967  *         Duration_breakdown(calc,j)=floor(uniform(0,card(n)/2))$(sum((hbar,i)$(Ij(i,j) and ord(hbar)-1 le pi(i)),Breakdown(calc-1,i,j,hbar)) eq 1 and Duration_breakdown(calc-1,j) eq (card(h)))
 968  *                                         +(Duration_breakdown(calc-1,j)-1)$(Duration_breakdown(calc-1,j) gt 0 and Duration_breakdown(calc-1,j) lt card(h))
 969  *                                         +card(h)$(sum((hbar,i)$(Ij(i,j) and ord(hbar)-1 le pi(i)),Breakdown(calc,i,j,hbar)) eq 1);
GAMS 24.5.6  r55090 Released Nov 27, 2015 WEX-WEI x86 64bit/MS Windows                                                                                                                                                                03/09/16 09:27:54 Page 21
State_Space_Model
C o m p i l a t i o n


 970           Duration_breakdown(calc,j)=2$(sum((hbar,i)$(Ij(i,j) and ord(hbar)-1 le pi(i)),Breakdown(calc-1,i,j,hbar)) eq 1 and Duration_breakdown(calc-1,j) eq (card(h)))
 971                                           +(Duration_breakdown(calc-1,j)-1)$(Duration_breakdown(calc-1,j) gt 0 and Duration_breakdown(calc-1,j) lt card(h))
 972                                           +(card(h))$(sum((hbar,i)$(Ij(i,j) and ord(hbar)-1 le pi(i)),Breakdown(calc,i,j,hbar)) eq 1);
 973  *display Breakdown,duration_breakdown;
 974   
 975           UnitBroken(j,n)=0;
 976           UnitBroken(j,n)$(ord(n)-1 lt Duration_breakdown(calc,j))=1;
 977   
 978           Zhat(i,j,n,hbar)=0;
 979           Zhat(i,j,n,hbar)$(ord(n)-1 eq 0 and Breakdown(calc,i,j,hbar) eq 1)=1;
 980   
 981  );
 982   
 983   
 984   
 985  *Disturbance associated with delay in tasks, hbar indicates the running status of the task
 986  *Due to nature of lifting, there is already a 1 time unit lag, hence we limit hbar from 0 to pi(i)
 987  *so that recordstates is accessed only upto pi(i)-1. Record state being pi(i) means that the task
 988  *was already over in the last horizon
 989  if(0 eq 1,
 990  *          Delay(calc,i,j,hbar)$(Ij(i,j) and ord(hbar)-1 le pi(i))=(Delay(calc-1,i,j,hbar)-1)$(Delay(calc-1,i,j,hbar) ge 1)
 991  *                                                            +2$(uniform(0,1) ge 0 and (sum(n$(ord(n)-1 eq 0),record_states(calc-1,'W',i,j,n,hbar-1)) gt 0) and Delay(calc-1,i,j,hbar-1) eq 0);
 992            Delay(calc,i,j,hbar)$(Ij(i,j) and ord(hbar)-1 le pi(i))=(Delay(calc-1,i,j,hbar)-1)$(Delay(calc-1,i,j,hbar) ge 1);
 993            Delay(calc,i,j,hbar)$(Ij(i,j) and ord(hbar)-1 le pi(i) and Delay(calc-1,i,j,hbar) eq 0)=2$(uniform(0,1) ge 0.6 and (sum(n$(ord(n)-1 eq 0),record_states(run,calc-1,'W',i,j,n,hbar-1)) gt 0 and Delay(calc-1,i,j,hbar-1) eq 0));
 994  *          Delay(calc,i,j,hbar)$(Ij(i,j) and ord(n)-1 eq 0)=(Delay(calc-1,i,j,hbar)-1)$(Delay(calc-1,i,j,hbar) gt 0)
 995  *          Yhat(i,j,n,hbar)$(Ij(i,j) and ord(n)-1 eq 0)=1$(uniform(0,1) gt 0 and record_states(calc-1,'W',i,j,n,hbar-1) gt 0);
 996   
 997  *display Delay;
 998  *Wipes out previous Yhats
 999            Yhat(i,j,n,hbar)=0;
1000  *Over-rides Delays with Unit breakdown. ie if unit breakdown occurs then there cannot be a delay
1001            Delay(calc,i,j,hbar)=Delay(calc,i,j,hbar)$(sum(n$(ord(n)-1 eq 0),Zhat(i,j,n,hbar)+Zhat(i,j,n,hbar+1)) eq 0);
1002  *          Yhat(i,j,n,hbar)$(Ij(i,j) and ord(n)-1 eq 0)=1$(Delay(calc,i,j,hbar) gt 0);
1003            Yhat(i,j,n,hbar)$(Ij(i,j) and ord(n)-1 lt Delay(calc,i,j,hbar))=1$(Delay(calc,i,j,hbar) gt 0);
1004   
1005  *          Yhat(i,j,n,hbar)$(Ij(i,j) and ord(n)-1 eq 0 and ord(hbar)-1 le pi(i))=1$(uniform(0,1) ge 0 and record_states(calc-1,'W',i,j,n,hbar) gt 0);
1006  *          WbarInfo(i,j,n,hbar)$Yhat(i,j,n,hbar)=1;
1007  *          BbarInfo(i,j,n,hbar)$Yhat(i,j,n,hbar)=record_states(calc-1,'W',i,j,n,hbar);
1008  );
1009   
1010  *display Yhat;
1011  *display WbarInfo;
1012  *display BbarInfo;
1013   
1014   
1015  *Introducing disturbance in material handling(loading/unloading)
1016  *Here we implement only production disturbance because its more likely than consumption disturbance
1017  *Consumption disturbance has the tricky part that if loading was 5 units, and we had just 5 units, the task is already started and we cant
1018  *then add a disturbance on top of it saying 5.5 units was actually consumed because the task has already started.
1019  if(0 eq 1,
1020  *the last two multiplication of (1-z(h+1))(1-z(h)) are when there are only unit breakdown, and when there is unit breakdown in middle of delay respectively
1021  *betaHatProd(i,j,s,n)$(Tbars(i,s) and Ij(i,j) and ord(n)-1 eq 0 and product_states(s))=uniform(-0.1,0)*sum(hbar$(ord(hbar) -1 eq pis_new(i,s)-1),record_states(calc-1,'B',i,j,n,hbar)*(1-Yhat(i,j,n,hbar+1))*(1-Zhat(i,j,n,hbar+1))*(1-Zhat(i,j,n,hbar)))
      ;
GAMS 24.5.6  r55090 Released Nov 27, 2015 WEX-WEI x86 64bit/MS Windows                                                                                                                                                                03/09/16 09:27:54 Page 22
State_Space_Model
C o m p i l a t i o n


1022  *wipes out previous parameter values
1023  betaHatProd(i,j,s,n)=0;
1024  betaHatProd(i,j,s,n)$(Tbars(i,s) and Ij(i,j) and ord(n)-1 eq 0)=uniform(-0.1,0)*sum(hbar$(ord(hbar) -1 eq pis_new(i,s)),BbarInfo(i,j,n,hbar)*(1-Yhat(i,j,n,hbar))*(1-Zhat(i,j,n,hbar))*(1-Zhat(i,j,n,hbar-1)));
1025  *betaHatProd(i,j,s,n)$(Tbars(i,s) and Ij(i,j) and ord(n)-1 eq 0)=uniform(-0.1,0)*sum(hbar$(ord(hbar) -1 eq pis_new(i,s)-1),record_states(calc-1,'B',i,j,n,hbar)*(1-Yhat(i,j,n,hbar+1))*(1-Zhat(i,j,n,hbar)));
1026  *betaHatProd(i,j,s,n)$(Tbars(i,s) and Ij(i,j) and ord(n)-1 eq 0)=uniform(-0.1,0)*sum(hbar$(ord(hbar) -1 eq pis_new(i,s)-1),record_states(calc-1,'B',i,j,n,hbar));
1027  );
1028  *Display betaHatProd;
1029   
1030   
1031  *Correct allocation constraint
1032  *KillDurationCountdown(i,j)$Ij(i,j)=%KillSwitch%$(sum(hbar,T.l(i,j,hbar)) gt 0);
1033  KillOccupy(j,n)=0;
1034  KillDuration(i,j)$Ij(i,j)=KillLength$(0);
1035  *KillDuration(i,j)$Ij(i,j)=(%KillSwitch%+1)$(sum(hbar,T.l(i,j,hbar)) gt 0 and KillDuration(i,j) eq 0);
1036  *KillDuration(i,j)$(Ij(i,j) and KillDuration(i,j) <> 0)=KillDuration(i,j)-1;
1037  KillCountdown(j)=sum((i,hbar)$Ij(i,j),T.l(i,j,hbar)*KillDuration(i,j))  +(KillCountdown(j)-1)$(KillCountdown(j) gt 0);
1038  KillOccupy(j,n)$(ord(n)-1 lt KillCountdown(j)-1)=1;
1039  if(0 eq 0,
1040     T.fx(i,j,hbar)=0;
1041  );
1042  *Display Breakdown,Duration_breakdown,UnitBroken,Zhat,KillOccupy;
1043  ***************SAMPLING DISTURBANCES/UNCERTAINTIES******************************
1044   
1045  ***************UTILITIES********************************************************
1046  Uutmax(u,n)=sum(h$((ord(h)-1) eq (ord(n)-1+ord(calc)-1)),Uutmax_full(u,h));
1047  Unitunavailable(j,n)=sum(h$((ord(h)-1) eq (ord(n)-1+ord(calc)-1)),Unitunavailable_full(j,h));
1048  Cut(u,n)=sum(h$((ord(h)-1) eq (ord(n)-1+ord(calc)-1)),Cut_full(u,h));
1049  *Correct Cutfull calculation, all the relation of taking hours to time points
1050  *This correction is needed in model file
1051  ***************UTILITIES********************************************************
1052  *Display Dst;
1053   
1054  *abort$(sameas(calc,"calc25")) "stopped for debugging";
1055  *Solve optimization horizon
1056   
1057  Option IntVarUp=0;
1058  *******************FIND OPEN LOOP SCHEDULE**************************************
1059  MAX_PROFIT_2.optcr = optcr_value$(reschedule_flag)+1$(NOT reschedule_flag);
1060  MAX_PROFIT_2.reslim = timelimit;
1061  MAX_PROFIT_2.holdFixed=1;
1062  solve MAX_PROFIT_2 using MIP maximizing obj_variable;
1063   
1064  modelStat(calc,run)=MAX_PROFIT_2.ModelStat;
1065  *Watch out what should be denominator, Relaxed or Best found solution
1066  *Cplex uses division by best found integer solution
1067  Est_modelGap1(calc,run)=abs((MAX_PROFIT_2.objEst-MAX_PROFIT_2.objVal)/(MAX_PROFIT_2.objVal+1E-10));
1068  Est_modelGap2(calc,run)=abs((MAX_PROFIT_2.objEst-MAX_PROFIT_2.objVal)/(MAX_PROFIT_2.objEst+1E-10));
1069  Suboptimal_objective=MAX_PROFIT_2.objVal;
1070   
1071  ETSolve(calc,run)=MAX_PROFIT_2.etSolve;
1072  ETSolver(calc,run)=MAX_PROFIT_2.etSolver;
1073  iterUsd(calc,run)=MAX_PROFIT_2.iterUsd;
1074  nodUsd(calc,run)=MAX_PROFIT_2.nodUsd;
GAMS 24.5.6  r55090 Released Nov 27, 2015 WEX-WEI x86 64bit/MS Windows                                                                                                                                                                03/09/16 09:27:54 Page 23
State_Space_Model
C o m p i l a t i o n


1075  resUsd(calc,run)=MAX_PROFIT_2.resUsd;
1076  numDVar(calc,run)=MAX_PROFIT_2.numDVar;
1077  numEqu(calc,run)=MAX_PROFIT_2.numEqu;
1078  numInfes(calc,run)=MAX_PROFIT_2.numInfes;
1079  numNZ(calc,run)=MAX_PROFIT_2.numNZ;
1080  numVar(calc,run)=MAX_PROFIT_2.numVar;
1081  solveStat(calc,run)=MAX_PROFIT_2.solveStat;
1082   
1083  *Recording optimized variables for each optimization horizon
1084  record_states_raw(run,calc,'B',i,j,n,hbar)$(ord(hbar)-1 le pi(i) and Ij(i,j))= Bbar.l(i,j,n,hbar);
1085  record_states_raw(run,calc,'W',i,j,n,hbar)$(ord(hbar)-1 le pi(i) and Ij(i,j))= Wbar.l(i,j,n,hbar);
1086  record_states(run,calc,'B',i,j,n,hbar)$(ord(hbar)-1 le pi(i) and Ij(i,j))= round(Bbar.l(i,j,n,hbar),2)$(Bbar.l(i,j,n,hbar) ge vminij(i,j)+Small_number and Bbar.l(i,j,n,hbar) le vmaxij(i,j)-Small_number) + round(Bbar.l(i,j,n,hbar))$(NOT (Bbar.l(i,j,n
      ,hbar) ge vminij(i,j)+Small_number and Bbar.l(i,j,n,hbar) le vmaxij(i,j)-Small_number));
1087  record_states(run,calc,'W',i,j,n,hbar)$(ord(hbar)-1 le pi(i) and Ij(i,j))= round(Wbar.l(i,j,n,hbar));
1088  record_T(run,calc,i,j,hbar)$(ord(hbar)-1 le pi(i) and Ij(i,j))= T.l(i,j,hbar);
1089  record_inventory(run,calc,s,n)=round(Sst.l(s,n),3);
1090  record_backlog(run,calc,s,n)=round(Backlog.l(s,n),3);
1091  record_inventory_raw(run,calc,s,n)=Sst.l(s,n);
1092  record_backlog_raw(run,calc,s,n)=Backlog.l(s,n);
1093  record_yieldloss(run,calc,i,j,s,n)=betaHatProd(i,j,s,n);
1094  record_objective(run,calc)=obj_variable.l;
1095  record_utility(run,calc,u,n)=Uut.l(u,n);
1096  record_inventoryTerminal(run,calc,s)=SstTerminal.l(s);
1097  record_backlogTerminal(run,calc,s)=BacklogTerminal.l(s);
1098  record_shipment_raw(run,calc,s,n)=Ship.l(s,n);
1099  record_shipment(run,calc,s,n)=round(Ship.l(s,n),2);
1100  record_shipment_sales_raw(run,calc,s,n)=Ship_sales.l(s,n);
1101  record_shipment_sales(run,calc,s,n)=round(Ship_sales.l(s,n),2);
1102  record_Rst_raw(run,calc,s,n)=Rst.l(s,n);
1103  record_Rst(run,calc,s,n)=round(Rst.l(s,n),2);
1104  record_demands(run,calc,s,n)=Dst(s,n);
1105  record_Demands_realization(run,s,h)=Dst_Full_Realization(s,h,run);
1106   
1107  record_WbarInfo(run,calc,i,j,n,hbar)=WbarInfo(i,j,n,hbar);
1108  record_BbarInfo(run,calc,i,j,n,hbar)=BbarInfo(i,j,n,hbar);
1109   
1110  BOStat_OL(calc,run) =  1$(sum((s,n),record_backlog(run,calc,s,n)+record_backlogTerminal(run,calc,s)) > 0);
1111  BOStat_CL(calc,run) =  1$(sum((s,n)$(ord(n)-1 eq 0),record_backlog(run,calc,s,n)) > 0);
1112   
1113  *display ship.l;
1114  Optimal_Objective=Suboptimal_Objective;
1115  ***********************FIND OPTIMAL OBJECTIVE IF OPTCR <>0*****************
1116  IF(MAX_PROFIT_2.optcr <> 0 AND reschedule_flag eq 1,
      put screen;
      put 'Now solving optimal open loop';
      putclose;
1122  MAX_PROFIT_2.optcr=0;
1123  solve MAX_PROFIT_2 using MIP maximizing obj_variable;
1124  Optimal_Objective=MAX_PROFIT_2.objVal;
1125  True_modelGap(calc,run)=(Suboptimal_objective-Optimal_Objective)/(Optimal_objective+1E-10);
1126  );
1127   
1128  ***********************FIND OPTIMAL OBJECTIVE IF OPTCR <>0*****************
GAMS 24.5.6  r55090 Released Nov 27, 2015 WEX-WEI x86 64bit/MS Windows                                                                                                                                                                03/09/16 09:27:54 Page 24
State_Space_Model
C o m p i l a t i o n


1129   
1130  ******WARNING: ALL VARIABLE LEVEL VALUES ARE THOSE OF OPTCR=0 NOW**********
1131   
1132  IF (reschedule_flag eq 1,
1133  ***********************SOLVE RMIP TO GET INTEGRALITY GAP*****************
1134  solve MAX_PROFIT_2 using RMIP maximizing obj_variable;
1135  record_relaxed_objective(run,calc)=obj_variable.l;
1136  IntegralityGap(calc,run)=record_relaxed_objective(run,calc)/(Optimal_Objective+1E-10);
1137  record_relaxed_states(run,calc,'B',i,j,n,hbar)$(ord(hbar)-1 le pi(i) and Ij(i,j))= Bbar.l(i,j,n,hbar);
1138  record_relaxed_states(run,calc,'W',i,j,n,hbar)$(ord(hbar)-1 le pi(i) and Ij(i,j))= Wbar.l(i,j,n,hbar);
1139  record_relaxed_shipment(run,calc,s,n)=Ship.l(s,n);
1140  record_relaxed_shipment_sales(run,calc,s,n)=Ship_sales.l(s,n);
1141  record_relaxed_backlog(run,calc,s,n)=Backlog.l(s,n);
1142  );
1143  ***********************SOLVE RMIP TO GET INTEGRALITY GAP*****************
1144   
1145  ******WARNING: ALL VARIABLE LEVEL VALUES ARE THOSE OF RMIP NOW**********
1146   
1147  );
1148  **END OF CALC LOOP HERE
1149   
1150  *END OF SOLUTION FILE
1151   
1152   
1153   
1154  loop((n,calc)$(ord(n)-1 eq 0),
1155           ClosedLoopINV(run,s,h)$(ord(h) eq ord(calc))=record_inventory(run,calc,s,n);
1156           ClosedLoopBO(run,s,h)$(ord(h) eq ord(calc))=record_backlog(run,calc,s,n);
1157           ClosedLoopShip(run,s,h)$(ord(h) eq ord(calc))=record_shipment(run,calc,s,n);
1158           ClosedLoopShip_sales(run,s,h)$(ord(h) eq ord(calc))=record_shipment_sales(run,calc,s,n);
1159           ClosedLoopStart(run,h)$(ord(calc) eq ord(h))=sum((i,j,hbar)$(Ij(i,j) AND ord(hbar)-1 eq 0),record_states(run,calc,'W',i,j,n,hbar));
1160  *         ClosedLoopStart(run,h)$(ord(calc) eq ord(h))=0;
1161  );
1162  *         runcost_Inv(run)=1E1*sum((s,h)$closed_loop(h),Cst_new(s)*Sinv(s,h));
1163  *         runcost_BO(run)=1E2*sum((s,h)$closed_loop(h),Cst_new(s)*BO(s,h));
1164           runcost_Inv(run)=1E1*sum((s,h)$closed_loop(h),Cst_new(s)*ClosedLoopINV(run,s,h));
1165           runcost_BO(run)=1E2*sum((s,h)$closed_loop(h),Cst_new(s)*ClosedLoopBO(run,s,h));
1166           runcost_W(run)=sum(h$closed_loop(h),ClosedLoopStart(run,h));
1167  *total profit from all shipments (demand+sales)
1168   
1169           runcost(run)=runcost_Inv(run)+runcost_BO(run)+runcost_W(run);
1170   
1171           sales_profit(run)=sum( (s,h)$(product_states(s) and closed_loop(h) and (ord(h)-1 ne 0) ),
1172                                   Cst_new(s)*(ClosedLoopShip(run,s,h)+ClosedLoopShip_sales(run,s,h) ));
1173  *         sales_profit(run)=sum( (s,h)$(product_states(s) and closed_loop(h) and (ord(h)-1 ne %Closed_Loop_Upper_delta%) ),Cst_new(s)*ClosedLoopShip_sales(run,s,h));
1174           Cost_EndInventory(run)=sum((s,h)$(product_states(s) and ord(h)-1 eq 0),Cst_new(s)*ClosedLoopINV(run,s,h));
1175  *         runcost_W(run)=0;
1176  *         runprofit(run)=sum((s,h)$(product_states(s) and closed_loop(h)),Cst_new(s)*ClosedLoopShip(run,s,h))+runcost_W(run);
1177  *Runprofit includes subtraction of BO even at last point because BO are written like inventory
1178  *BO at 168 means just before 168th point. Ship at 168 means at 168 not before or after.
1179  *Our runprofit is only for 167 points of closed loop and 168th point as correction. So we are essentially wasting the last decision
1180  *that is the open loop that was computed at 168.
1181           runprofit(run)=sales_profit(run)+Cost_EndInventory(run)
GAMS 24.5.6  r55090 Released Nov 27, 2015 WEX-WEI x86 64bit/MS Windows                                                                                                                                                                03/09/16 09:27:54 Page 25
State_Space_Model
C o m p i l a t i o n


1182                           -(runcost_W(run)-sum(h$(ord(h)-1 eq 0),ClosedLoopStart(run,h)))
1183                           -runcost_BO(run);
1184   
1185  *         runprofit(run)=runcost_Inv(run)-runcost_BO(run)
1186  *                        +1E1*sum((s,h)$(product_states(s) and closed_loop(h)),Cst_new(s)*ClosedLoopShip(run,s,h));
1187   
1188  *Does not include cost of Terminal BO and inventory but thats okay because they are irrelevant when some extra horizon is allowed for getting complete closed loop rolling horizon solution
1189  ************[Start]Information to get very crude estimate for running time left**************
1190  timeLeft=MAX_PROFIT_2.etSolve*(card(run)-ord(run))*card(calc);
      put screen;
      put 'Time for run ' P1.etSolve;
      put ' Estimated Time Left ' timeLeft;
      putclose;
1197  *************[End]Information to get very crude estimate for running time left***************
1198   
      *************Stopping Criterion**************
      N_run=ord(run);
      mean_runcost(run)=sum(run_p$(ord(run_p) le N_run),runcost(run_p))/N_run;
      std_dev_runcost(run)$(ord(run) gt 1)= sqrt(       sum(run_p$(ord(run_p) le N_run),     ( abs(  runcost(run_p)-mean_runcost(run) )**2)) /(N_run-1)    );
      delta_std_dev_runcost(run)$(ord(run) gt 2)=std_dev_runcost(run)/std_dev_runcost(run-1)  - 1;
      max_delta_std_dev_runcost(run)= sqrt( 1 + (1.96**2-1)/N_run ) -1;
      *icdfnorm(0.95,0,1);
      *************Stopping Criterion**************
1209  );
1210  ********************[End] runs loop ***************************************
1211   
1212  *******************GANTT CHART PARAMETERS*************************************
1213  PARAMETERS BS(i,j,h),start(i,j,h),Sinv(s,h),end(i,j,h),BO(s,h);
1214  IF (0 eq 0,
1215           loop((run,calc)$(ord(run) eq 1),
1216             BS(i,j,h)$(ord(h) eq ord(calc))=sum((hbar,n)$(ord(hbar)-1 eq 0 and ord(n)-1 eq 0),record_states(run,calc,'B',i,j,n,hbar));
1217  *start(i,j,h)$(ord(h)eq ord(calc))=round(sum((hbar,n)$(ord(hbar)-1 eq 0 and ord(n)-1 eq 0),record_states(calc,'W',i,j,n,hbar)));
1218             start(i,j,h)$(ord(h)eq ord(calc))=sum((hbar,n)$(ord(hbar)-1 eq 0 and ord(n)-1 eq 0),record_states(run,calc,'W',i,j,n,hbar));
1219             Sinv(s,h)$(ord(h) eq ord(calc))=sum(n$(ord(n)-1 eq 0),record_inventory(run,calc,s,n));
1220             BO(s,h)$(ord(h) eq ord(calc))=sum(n$(ord(n)-1 eq 0),record_backlog(run,calc,s,n));
1221           );
1222  ELSE
1223  *Write OPEN loop static gantt chart %GanttChart_OPENLOOP% eq 1
1224           loop((run,calc)$(ord(run) eq 1 and ord(calc) eq 1),
1225             BS(i,j,h)$(Ij(i,j))=sum((hbar,n)$(ord(hbar)-1 eq 0 and (ord(n) eq ord(h))),record_states(run,calc,'B',i,j,n,hbar));
1226             start(i,j,h)$(Ij(i,j))=sum((hbar,n)$(ord(hbar)-1 eq 0 and (ord(n) eq ord(h))),record_states(run,calc,'W',i,j,n,hbar));
1227             Sinv(s,h)=sum(n$(ord(n) eq ord(h)),record_inventory(run,calc,s,n));
1228             BO(s,h)=sum(n$(ord(n) eq ord(h)),record_backlog(run,calc,s,n));
1229           );
1230  );
1231  *Have ending account for task delays
1232  end(i,j,h) = start(i,j,h-pi_new(i))$(BS(i,j,h-pi_new(i))>0);
1233  *******************GANTT CHART PARAMETERS*************************************
1234   
1235  *******************EXPORT ALL RESULTS IN GDX FILE*****************************
1236  SUCCESS=1;
1237  EXECUTE_UNLOAD 'Z_FlatN2_MH168_RF1_OPT1_DF3_DV1_DL3_DU1_S1_MC1_Profit.gdx';
1238  *******************EXPORT ALL RESULTS IN GDX FILE*****************************
GAMS 24.5.6  r55090 Released Nov 27, 2015 WEX-WEI x86 64bit/MS Windows                                                                                                                                                                03/09/16 09:27:54 Page 26
State_Space_Model
C o m p i l a t i o n


1239   
1240  *********Generate EXCEL SHEEL FOR GANTT CHARTING (Requires windows)***********
1241  if(1 eq 1,
1242  ************************************************
1243  ********Closed-Loop GanttChartGeneration********
1244  ************************************************
1245  *Name of the excel file where the data will be exported
1246  *$setglobal file %Results_FileName%_Gantt
1247  *i = set of tasks
1248  *j = set of units
1249  *h = set of time points
1250  *BS = batch size of task i starting in unit j at time t (must be indexed ijt)
1251  *start = binary variable that is 1 if task i starts in unit j at time t (must be indexed ijt)
1252  *Sinv = inventory level of material s at time t (must be indexed st)
1253  *BO= backorder of state s at time t
1254  *end =  binary variable that is 1 if task i ends in unit j at time t (must be indexed ijt)
1255   
1256  *EXECUTE_UNLOAD '%Results_FileName%_Gantt.gdx' BS i j h  Sinv start end;
1257   
1258  *The first word of each line gives the type: set = set, var = variable, par = parameter. This may need to be changed depending on your model
1259  *The location of the output or the sheet names must not be changed
1269   
1270  *display BS,start,end,Sinv,BO;
1271  EXECUTE 'gdxxrw Input=Z_FlatN2_MH168_RF1_OPT1_DF3_DV1_DL3_DU1_S1_MC1_Profit.gdx Output=Z_FlatN2_MH168_RF1_OPT1_DF3_DV1_DL3_DU1_S1_MC1_Profit_Gantt @GANTT_write.txt'
1272  );
1273  *********Generate EXCEL SHEEL FOR GANTT CHARTING (Requires windows)***********
1274   
1275  *END OF MASTER FILE
1276   
1277   
1278   
1279   
1280   
1281   
1282  *Watch out for overflow of solution for rolling horizon...ie the spilling over of
1283  *rolling horizon beyond real horizon to get last implemented closed loop solution
1284   
1285   
1286  *$set console
1287  *$if %system.filesys% == UNIX  $set console /dev/tty
1288  *$if %system.filesys% == DOS $set console con
1289  *$if %system.filesys% == MS95  $set console con
1290  *$if %system.filesys% == MSNT  $set console con
1291  *$if "%console%." == "." abort "filesys not recognized";
1292  *file screen / '%console%' /;
1293  *file log /''/
1294   
1295   
1296   
1297   
1298   
1299   
1300   
GAMS 24.5.6  r55090 Released Nov 27, 2015 WEX-WEI x86 64bit/MS Windows                                                                                                                                                                03/09/16 09:27:54 Page 27
State_Space_Model
C o m p i l a t i o n


1301   
GAMS 24.5.6  r55090 Released Nov 27, 2015 WEX-WEI x86 64bit/MS Windows                                                                                                                                                                03/09/16 09:27:54 Page 28
State_Space_Model
Include File Summary


   SEQ   GLOBAL TYPE      PARENT   LOCAL  FILENAME

     1        1 INPUT          0       0  C:\Users\dhruv\Box Sync\Work\Codes_OnlineMethods\GAMS_Greedy\Z_FlatN2_MH168_RF1_OPT1_DF3_DV1_DL3_DU1_S1_MC1_Profit.gms
     2       20 INCLUDE        1      20  .C:\Users\dhruv\Box Sync\Work\Codes_OnlineMethods\GAMS_Greedy\ConfigurationFile.gms
     3       89 INCLUDE        2      69  ..C:\Users\dhruv\Box Sync\Work\Codes_OnlineMethods\GAMS_Greedy\MasterFile.gms
     4      106 INCLUDE        3      17  ...C:\Users\dhruv\Box Sync\Work\Codes_OnlineMethods\GAMS_Greedy\NetworkN2.gms
     5      214 INCLUDE        3      18  ...C:\Users\dhruv\Box Sync\Work\Codes_OnlineMethods\GAMS_Greedy\Model9.gms
     6      864 INCLUDE        3     146  ...C:\Users\dhruv\Box Sync\Work\Codes_OnlineMethods\GAMS_Greedy\ModelSolution9.gms


COMPILATION TIME     =        0.000 SECONDS      3 MB  24.5.6 r55090 WEX-WEI
GAMS 24.5.6  r55090 Released Nov 27, 2015 WEX-WEI x86 64bit/MS Windows                                                                                                                                                                03/09/16 09:27:54 Page 29
State_Space_Model
Model Statistics    SOLVE MAX_PROFIT_2 Using MIP From line 1062


LOOPS                                  run   run1
                                      calc   calc0


MODEL STATISTICS

BLOCKS OF EQUATIONS          14     SINGLE EQUATIONS        5,678
BLOCKS OF VARIABLES           9     SINGLE VARIABLES        5,615
NON ZERO ELEMENTS        14,710     DISCRETE VARIABLES      1,813


GENERATION TIME      =        0.249 SECONDS      6 MB  24.5.6 r55090 WEX-WEI


EXECUTION TIME       =        0.327 SECONDS      6 MB  24.5.6 r55090 WEX-WEI
