GAMS 24.5.6  r55090 Released Nov 27, 2015 WEX-WEI x86 64bit/MS Windows 04/10/16 14:27:53 Page 1
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
C o m p i l a t i o n


   3  SCALAR re_freq                    /1/;
   4  PARAMETER demand_cycletime        /4/;
   5  PARAMETER demand_variation        /0/;
   6  PARAMETER demand_magnitude        /2.50/;
   7  PARAMETER lambda_Demand           /0.00/;
   8  SCALAR surprise                   /0.00/;
   9  SCALAR optcr_value                /0/;
  10  PARAMETER SEED_VALUE              /1716/;
INCLUDE    C:\Users\dhruv\Box Sync\Work\Codes\GAMS_Code_Paper1\ConfigurationFile
           .gms
GAMS 24.5.6  r55090 Released Nov 27, 2015 WEX-WEI x86 64bit/MS Windows 04/10/16 14:27:53 Page 2
CONFIGURATION_FILE
C o m p i l a t i o n


  22   
  23  *$SETGLOBAL OPTIMIZATION_DIRECTION  maximizing
  24  *$SETGLOBAL MODEL_NAME MAX_PROFIT
  25  *$SETGLOBAL InitialInventoryFlag 1
  26   
  27  *$SETGLOBAL OPTIMIZATION_DIRECTION  minimizing
  28  *$SETGLOBAL MODEL_NAME MIN_COST
  29  *$SETGLOBAL InitialInventoryFlag 0
  30  *******HORIZON********
  31  *$SETGLOBAL H 192
  33  *$SETGLOBAL MH 20
  34  *SCALAR re_freq /1/;
  35  *Used in chopping off initial transient in closed loop cost evaluation
  36  *$SETGLOBAL Transient_H 48
  37  *$SETGLOBAL Transient_H 0
  38  *We do Closed_Loop_Upper # of calc and record closed loop solution only ti
      ll there
  39  *$SETGLOBAL Closed_Loop_Upper 168
  40  *$SETGLOBAL Closed_Loop_Upper 192
  41  *******HORIZON********
  42   
  43  *******NETWORK AND MODEL********
  44  *$SETGLOBAL NetworkNumber 1
  47  *******NETWORK AND MODEL********
  48   
  49  *******DEMAND LOAD********
  50  *PARAMETER demand_cycletime /12/;
  51  *PARAMETER demand_variation /3/;
  52  *PARAMETER demand_magnitude NOMINAL LOAD /25/;
  53  *******DEMAND LOAD********
  54   
  55  ******DISTURBANCES********************
  56  *$SETGLOBAL Demand_Disturbance_flag 0
  60  *Parameters for demand uncertainty
  61  *What fraction ahead of rolling Horizon does demand forecast changes'
  62  *SCALAR surprise /0.34/;
  63  *Magnitude of Uncertainties
  64  *PARAMETER lambda_Demand /0.2/;
  65  *Yet to replace these names in ModelSolution9 file
  66  *and these values are hardcoded right now (look into code again)
  67  PARAMETER lambda_TaskDelay /0.2/;
  68  PARAMETER lambda_UnitBreakdown /0.2/;
  69  PARAMETER bringing_unit_back /2/;
  70  PARAMETER lambda_Handling /0.2/;
  71  ******DISTURBANCES********************
  72   
  73  *******OPTIMIZATION OPTIONS****
  74  *SCALAR   optcr_value /0/;
  75  SCALAR   timelimit /600/;
  76  *******OPTIMIZATION OPTIONS****
  77   
  78  *******EVALUATION********
  79  *$SETGLOBAL N_runs 1
  80  *******EVALUATION********
  81   
  82  *******REPORTING********
  85  *$SETGLOBAL Results_FileName Config_Results
  86  *******REPORTING********
  87   
  88  *Run the closed loop and generate results
INCLUDE    C:\Users\dhruv\Box Sync\Work\Codes\GAMS_Code_Paper1\MasterFile.gms
  90  *Change this to name of the instance
GAMS 24.5.6  r55090 Released Nov 27, 2015 WEX-WEI x86 64bit/MS Windows 04/10/16 14:27:53 Page 3
MasterFile
C o m p i l a t i o n


  96  *$OFFLISTING
  97   
  98  execseed=SEED_VALUE;
  99  *parameter cc /0/;
 100   
 102  SCALAR KillLength /2/;
 103   
 104  SET run /run1*run1/;
 105   
INCLUDE    C:\Users\dhruv\Box Sync\Work\Codes\GAMS_Code_Paper1\NetworkN2.gms
 107  Sets     i tasks  /T1*T3/
 108           s states /M1*M4/
 109           j units  /U1*U2/
 110           u utilities /manpower/
 111   
 112  *         Ki(j,i) set of equipments(units) suitable for task i
 113  *         /(Reactor1).(TA,TB),Heater.Heating/
 114           Ij(i,j) set of equipments(units) suitable for task i
 115           /T1.U1,(T2,T3).U2/
 116   
 117           FIS(s) States with Finite Intermediate Storage /M2/
 118           product_states(s) Product States/M3*M4/
 119           feed_states(s) Feed States/M1/
 120   
 121           UtilInt Intervals for utility /Int1/
 122           UnitInt Intervals for unit-unavailability /Int1/
 123   
 124           Attributes/magnitude, starttime, price/
 125  ;
 126   
 127  Table UtilData(UtilInt,u,Attributes)
 128               manpower.starttime            manpower.magnitude      manpowe
      r.price
 129  Int1                    0                         10                     0
 130  ;
 131   
 132  *Availability of unit  0=available, 1=not available
 133  Table UnitData(UnitInt,j,Attributes)
 134                U1.magnitude         U1.starttime
 135  Int1              0                     0
 136  ;
 137   
 138  Parameters rho(i,s) proportion of input of task i from states s
 139             /T1.M1 1,(T2,T3).M2 1/
 140             rhobar(i,s) proportion of ouput of task i to state s
 141             /T1.M2 1, T2.M3 1, T3.M4 1/
 142   
 143             pis(i,s) processing time for output of task i into state s
 144             /T1.M2 2,T2.M3 2, T3.M4 3/
 145             pi(i) maximum processing time in task i for any stage produced 
      by it
 146   
 147             alpha(u,i) fixed utility demand by task i throughout its run
 148             /manpower.(T1*T2) 0/
 149             beta(u,i) "variable utility demand by task i throughout its run
      (te/hr)"
 150             /manpower.(T1*T2) 0/
 151   
 152             vmaxij(i,j)  Maximum capacity of unit j when used for task i
 153             /T1.U1 20, (T2,T3).U2 10/
 154             vminij(i,j)  Minimum capacity of unit j when used for task i
 155             /T1.U1 10, (T2,T3).U2 5/
 156             Cs(s) maximum storage capacity for stage s  /(M1*M4) 99999/
 157             Cst(s) unit price of s/M1 1, M2 5, M3 10, M4 10/
 158  ;
 159  *pis(i,s)=5;
 160  pi(i)=smax(s,pis(i,s));
 161   
      ******DEMAND INFORMATION*****************************
      *Each order for all products
      set         o orders /o1*o%H%/;
      parameter deliveries_time(o);
      deliveries_time(o)=demand_cycletime*ord(o);
      deliveries_time(o)=deliveries_time(o)+UniformInt(-demand_variation,demand_
      variation);
      parameter deliveries(o,s);
      deliveries(o,s)$(product_states(s))=demand_magnitude;
      ******DEMAND INFORMATION*****************************
 173   
 174  *END OF INSTANCE FILE
 175   
 176   
 177   
 178   
 179   
 180   
 181   
 182   
 183   
 184   
 185   
 186   
 187   
 188   
 189   
 190   
      Table deliveries(o,s)
              SA      SB
      o1      5       5
      o2      5       5
      o3      5       5
      o4      5       5
      o5      5       5
      o6      5       5
      o7      5       5
      o8      5       5;
 203   
 204   
      For debugging/testing utility formulas
      Table UtilData(UtilInt,u,Attributes)
                   manpower.starttime            manpower.magnitude      manpowe
      r.price
      Int1                    0                         1                     1
      Int2                    1.5                       0                     0
      Int3                    3.5                       1                     1
      Int4                    6.1                       0                     0;
INCLUDE    C:\Users\dhruv\Box Sync\Work\Codes\GAMS_Code_Paper1\Model9.gms
GAMS 24.5.6  r55090 Released Nov 27, 2015 WEX-WEI x86 64bit/MS Windows 04/10/16 14:27:53 Page 4
State_Space_Model
C o m p i l a t i o n


 216  OPTIONS limrow = 0, limcol = 0, solprint = off;
 217  *OPTIONS limrow = 1000, limcol = 1000, solprint = on;
 218  *No upper limit on inventory (equation not enforced)
 219   
 220  *used for rounding W,B in recordstates in modelsolution file
 221  PARAMETER Small_number /1E-2/;
 222   
 223  *Now generating time grid using delta
 226  *$EvalGlobal calculations (%horizon%-%window%)
 230   
 231  set h time(multiples of delta) /h0*h216/
 232      n time window   /n0*n8/
 233      calc #of windows /calc0*calc8/
 234   
 235      closed_loop(h) horizon points for which we calculate closed loop cost
 236   
 237      Sbari(s,i)  materials produced by task i
 238      Si(s,i)     materials consumed by task i
 239      Tbars(i,s)    Tasks producing material s
 240      Ts(i,s) Tasks consuming material s;
 241   
 242  Sbari(s,i)=1$(rhobar(i,s) gt 0);
 243  Si(s,i)=1$(rho(i,s) gt 0);
 244  *Ij(i,j)=Ki(j,i);
 245  Tbars(i,s)=Sbari(s,i);
 246  Ts(i,s)=Si(s,i);
 247   
 248  closed_loop(h)=0;
 249  closed_loop(h)$(ord(h)-1 ge 0 and ord(h)-1 le 8)=1;
 250   
 251   
 252  alias(i,ip)
 253  alias(j,jp)
 254  alias(s,sp)
 255  alias(n,np)
 256  alias(h,hbar);
 257   
 258  set     UnitUnavailable_full(j,h)
 259  UnitUnavailable(j,n);
 260   
 261  parameter Uutmax_full(u,h),Cut_full(u,h) utility price;
 262   
 263  parameters Dst(s,n),Uutmax(u,n),Cut(u,n);
 264   
 265   
 266  parameter pis_new(i,s),pi_new(i);
 267  *tau_new(j,k,kp);
 268  pis_new(i,s)=ceil(pis(i,s)/1);
 269  pi_new(i)=ceil(pi(i)/1);
 270   
 271  parameter alpha_new(u,i),beta_new(u,i),Cst_new(s);
 272   
 273  alpha_new(u,i)=alpha(u,i);
 274   
 275  beta_new(u,i)=beta(u,i);
 276   
 277  Cst_new(s)=Cst(s);
 278   
 279   
 280   
 281   
 282  *UTILITY CALCULATIONS NEED TO BE CORRECTED
 283  *RIGHT NOW THERE IS BUG THAT IF THERE IS MORE THAN ONE CHANGE
 284  *WITHIN AN INTERVAL THEN THE CODE TAKES FIRST CHANGE ONLY
 285  *AND IGNORES THE SECOND CHANGE
 286  loop(UtilInt,
 287  *Maximum available utility
 288  Uutmax_full(u,h)$(ord(UtilInt) eq 1 and
 289                   ord(h) ge 1 and
 290                   ord(h)-1 lt (floor(UtilData(UtilInt+1,u,"starttime")/1)$(
      UtilData(UtilInt,u,"magnitude") gt UtilData(UtilInt+1,u,"magnitude"))+
 291                                ceil(UtilData(UtilInt+1,u,"starttime")/1)$(U
      tilData(UtilInt,u,"magnitude") le UtilData(UtilInt+1,u,"magnitude")) ))
 292                  =  UtilData(UtilInt,u,"magnitude");
 293   
 294   
 295   
 296   
 297  Uutmax_full(u,h)$((ord(UtilInt) gt 1 and ord(UtilInt) lt card(UtilInt)) an
      d
 298                   ord(h)-1 ge (floor(UtilData(UtilInt,u,"starttime")/1)$(Ut
      ilData(UtilInt-1,u,"magnitude") gt UtilData(UtilInt,u,"magnitude"))+
 299                                ceil(UtilData(UtilInt,u,"starttime")/1)$(Uti
      lData(UtilInt-1,u,"magnitude") le UtilData(UtilInt,u,"magnitude")) ) and
 300                   ord(h)-1 lt (floor(UtilData(UtilInt+1,u,"starttime")/1)$(
      UtilData(UtilInt,u,"magnitude") gt UtilData(UtilInt+1,u,"magnitude"))+
 301                                ceil(UtilData(UtilInt+1,u,"starttime")/1)$(U
      tilData(UtilInt,u,"magnitude") le UtilData(UtilInt+1,u,"magnitude")) ))
 302                  =  UtilData(UtilInt,u,"magnitude");
 303   
 304   
 305   
 306  Uutmax_full(u,h)$(ord(UtilInt) eq card(UtilInt) and
 307                   ord(h)-1 ge (floor(UtilData(UtilInt,u,"starttime")/1)$(Ut
      ilData(UtilInt-1,u,"magnitude") gt UtilData(UtilInt,u,"magnitude"))+
 308                                ceil(UtilData(UtilInt,u,"starttime")/1)$(Uti
      lData(UtilInt-1,u,"magnitude") le UtilData(UtilInt,u,"magnitude")) ) and
 309                   ord(h) le card(h))
 310                  =  UtilData(UtilInt,u,"magnitude");
 311   
 312   
 313  *Utility Price
 314  Cut_full(u,h)$(ord(UtilInt) eq 1 and
 315            ord(h)-1 lt (floor(UtilData(UtilInt+1,u,"starttime")/1))   )
 316            =  UtilData(UtilInt,u,"price");
 317   
 318  Cut_full(u,h)$(ord(UtilInt) gt 1 and ord(UtilInt) lt card(UtilInt) and
 319            ord(h)-1 gt (floor(UtilData(UtilInt,u,"starttime")/1)) and
 320            ord(h)-1 lt (floor(UtilData(UtilInt+1,u,"starttime")/1))   )
 321            =  UtilData(UtilInt,u,"price");
 322   
 323  Cut_full(u,h)$(ord(UtilInt) eq card(UtilInt) and
 324            ord(h)-1 gt floor(UtilData(UtilInt,u,"starttime")/1) and
 325            ord(h) le card(h)   )
 326            =  UtilData(UtilInt,u,"price");
 327   
 328  Cut_full(u,h)$(ord(UtilInt) gt 1 and
 329           ord(h)-1 eq floor(UtilData(UtilInt,u,"starttime")/1))
 330           =(   UtilData(UtilInt-1,u,"price")*(UtilData(UtilInt,u,"starttime
      ")-(ord(h)-1)* 1 )
 331                +UtilData(UtilInt,u,"price")*(ord(h)*1-UtilData(UtilInt,u,"s
      tarttime"))   )/1;
 332  *Bug in cost calculation: what if there are 3 cost levels within one time 
      grid?
 333  )
 334   
 335   
 336  *UnitUnavailabality(note the difference in inequalities as opposed to Util
      ity....1=>unit not available so more magnitude is bad)
 337  loop(UnitInt,
 338  Unitunavailable_full(j,h)$(ord(UnitInt) eq 1 and
 339                   ord(h)-1 ge 0 and
 340                   ord(h)-1 lt (floor(UnitData(UnitInt+1,j,"starttime")/1)$(
      UnitData(UnitInt,j,"magnitude") lt UnitData(UnitInt+1,j,"magnitude"))+
 341                                ceil(UnitData(UnitInt+1,j,"starttime")/1)$(U
      nitData(UnitInt,j,"magnitude") ge UnitData(UnitInt+1,j,"magnitude")) ))
 342                  =  UnitData(UnitInt,j,"magnitude");
 343   
 344   
 345   
 346   
 347  Unitunavailable_full(j,h)$((ord(UnitInt) gt 1 and ord(UnitInt) lt card(Uni
      tInt)) and
 348                   ord(h)-1 ge (floor(UnitData(UnitInt,j,"starttime")/1)$(Un
      itData(UnitInt-1,j,"magnitude") lt UnitData(UnitInt,j,"magnitude"))+
 349                                ceil(UnitData(UnitInt,j,"starttime")/1)$(Uni
      tData(UnitInt-1,j,"magnitude") ge UnitData(UnitInt,j,"magnitude")) ) and
 350                   ord(h)-1 lt (floor(UnitData(UnitInt+1,j,"starttime")/1)$(
      UnitData(UnitInt,j,"magnitude") lt UnitData(UnitInt+1,j,"magnitude"))+
 351                                ceil(UnitData(UnitInt+1,j,"starttime")/1)$(U
      nitData(UnitInt,j,"magnitude") ge UnitData(UnitInt+1,j,"magnitude")) ))
 352                  =  UnitData(UnitInt,j,"magnitude");
 353   
 354   
 355   
 356  Unitunavailable_full(j,h)$(ord(UnitInt) eq card(UnitInt) and
 357                   ord(h)-1 ge (floor(UnitData(UnitInt,j,"starttime")/1)$(Un
      itData(UnitInt-1,j,"magnitude") lt UnitData(UnitInt,j,"magnitude"))+
 358                                ceil(UnitData(UnitInt,j,"starttime")/1)$(Uni
      tData(UnitInt-1,j,"magnitude") ge UnitData(UnitInt,j,"magnitude")) ) and
 359                   ord(h) le card(h))
 360                  =  UnitData(UnitInt,j,"magnitude");
 361  )
 362   
 363   
 364   
 365  *display UnitUnavailable_full,Uutmax_full,Cut_full,Sbari,Si,rhobar,rho,Tba
      rs,Ts,calc;
 366   
 367  *Ijk,tauChangeMax
 368   
 369   
 370   
 371  *Disturbance parameter for loading/unloading of materials
 372  parameters betaHatProd(i,j,s,n),betaHatCons(i,j,s,n);
 373  betaHatProd(i,j,s,n)=0;
 374  betaHatCons(i,j,s,n)=0;
 375   
 376   
 377  *Disturbance parameter for task delays
 378  parameters
 379  Yhat(i,j,n,hbar)
 380  Delay(calc,i,j,hbar)
 381  Zhat(i,j,n,hbar)
 382  Breakdown(calc,i,j,hbar)
 383  Duration_breakdown(calc,j)
 384  UnitBroken(j,n)
 385  WbarInfo(i,j,n,hbar)
 386  BbarInfo(i,j,n,hbar)
 387  KillDuration(i,j)
 388  KillDurationCountdown(i,j)
 389  KillOccupy(j,n)
 390  KillCountdown(j);
 391   
 392  *Initializing parameters
 393  Yhat(i,j,n,hbar)=0;
 394  Delay(calc,i,j,hbar)=0;
 395  Zhat(i,j,n,hbar)=0;
 396  Breakdown(calc,i,j,hbar)=0;
 397  Duration_breakdown(calc,j)=0;
 398  UnitBroken(j,n)=0;
 399  WbarInfo(i,j,n,hbar)=0;
 400  BbarInfo(i,j,n,hbar)=0;
 401  KillDuration(i,j)=0;
 402  KillDurationCountdown(i,j)=0;
 403  KillOccupy(j,n)=0;
 404  KillCountdown(j)=0;
 405   
 406  *hbar are the time points for lifting of variables
 407  *binary variables W(i,j,n),Wbar(i,j,n,hbar),T(i,j,hbar) Kill_Variable;
 408  binary variables Wbar(i,j,n,hbar),T(i,j,hbar) Kill_Variable;
 409  positive variable Bbar(i,j,n,hbar),Sst(s,n),Backlog(s,n),Ship(s,n),Ship_sa
      les(s,n),Uut(u,n),Rst(s,n),SstTerminal(s),BacklogTerminal(s);
 410  variables obj_variable;
 411  integer variable NB(i,j) number of batches;
 412  *Assigning values to variables that might not participate in optimization
 413  Uut.l(u,n)=0;
 414  Ship_sales.l(s,n)=0;
 415   
 416  Equations
 417  numberOfBatches,
 418  Allocation,
 419  UnitCapacityMax,UnitCapacityMin,
 420  InventoryLimit,
 421  InventoryBalance,
 422  EndingInventory,
 423  BacklogBalance,
 424  EndingBacklog,
 425  UtilityLimit,
 426  UtilityBalance,
 427  objective_MIN_COST,
 428  objective_MAX_PROFIT,
 429  objective_MAX_PROFIT_Greedy
 430  UnitUnavailabality,
 431  *CorrectHolding(i,j,n),
 432  LiftingW,
 433  *LiftingW0,
 434  LiftingB,
 435  *LiftingB0,
 436  Carryover_W,Carryover_B,
 437  InventoryBalance_MAX_PROFIT,
 438  EndingInventory_MAX_PROFIT
 439  Ship_constraint(s,n)
 440  NoShip(s,n);
 441  *SHIPMENT;
 442  *NoTaskRunningAtEndOfHorizon;
 443   
 444  numberOfBatches(i,j)$Ij(i,j).. NB(i,j)=E=sum((n,hbar)$(ord(hbar)-1 eq 0),W
      bar(i,j,n,hbar));
 445   
 446  *scalar ord_calc /0/;
 447  SCALAR fixed_decisions /0/;
 448  SCALAR reschedule_flag /0/;
 449  *re_freq-1-mod(ord_calc-1+re_freq-1,re_freq)  is zero for calc0
 450  Carryover_W(i,j,n,hbar)$(ord(n)-1 le fixed_decisions and ord(hbar)-1 ge 1 
      and ord(hbar)-1 le pi(i) and Ij(i,j))..Wbar(i,j,n,hbar)=E=WbarInfo(i,j,n,h
      bar)*(1-T(i,j,hbar))*(1-Zhat(i,j,n,hbar));
 451  Carryover_B(i,j,n,hbar)$(ord(n)-1 le fixed_decisions and ord(hbar)-1 ge 1 
      and ord(hbar)-1 le pi(i) and Ij(i,j))..Bbar(i,j,n,hbar)=E=BbarInfo(i,j,n,h
      bar)*(1-T(i,j,hbar))*(1-Zhat(i,j,n,hbar));
 452   
 453  *LiftingW(i,j,n,hbar)$((ord(hbar)-1 ge 1) and (ord(hbar)-1 le pi(i)) and (
      ord(n) lt card(n)) and Ij(i,j))..
 454  *         Wbar(i,j,n+1,hbar)=E=Wbar(i,j,n,hbar-1)+Yhat(i,j,n,hbar)-Yhat(i,
      j,n,hbar-1)-Zhat(i,j,n,hbar-1);
 455  *LiftingB(i,j,n,hbar)$((ord(hbar)-1 ge 1) and (ord(hbar)-1 le pi(i)) and (
      ord(n) lt card(n)) and Ij(i,j))..
 456  *         Bbar(i,j,n+1,hbar)=E=Bbar(i,j,n,hbar-1)+Bbar(i,j,n,hbar)*Yhat(i,
      j,n,hbar)-Bbar(i,j,n,hbar-1)*Yhat(i,j,n,hbar-1)
 457   
 458  LiftingW(i,j,n,hbar)$((ord(hbar)-1 ge 1) and (ord(hbar)-1 le pi(i)) and (o
      rd(n) lt card(n)) and Ij(i,j))..
 459           Wbar(i,j,n+1,hbar)=E=Wbar(i,j,n,hbar-1)+Yhat(i,j,n,hbar)-Yhat(i,j
      ,n,hbar-1);
 460   
 461  LiftingB(i,j,n,hbar)$((ord(hbar)-1 ge 1) and (ord(hbar)-1 le pi(i)) and (o
      rd(n) lt card(n)) and Ij(i,j))..
 462           Bbar(i,j,n+1,hbar)=E=Bbar(i,j,n,hbar-1)+Bbar(i,j,n,hbar)*Yhat(i,j
      ,n,hbar)-Bbar(i,j,n,hbar-1)*Yhat(i,j,n,hbar-1);
 463  Allocation(j,n).. sum((i,hbar)$(Ij(i,j) and (ord(hbar) -1 le (pi_new(i)-1)
      ) ), Wbar(i,j,n,hbar))=L=1-sum((i,hbar)$(Ij(i,j) and (ord(hbar) -1 eq pi_n
      ew(i)) ) , Yhat(i,j,n,hbar))-UnitBroken(j,n)
 464                        -sum((i,hbar)$(Ij(i,j) and ord(hbar)-1 ge 1 and ord(
      hbar)-1 le pi(i)),T(i,j,hbar)$(ord(n)-1 lt KillDuration(i,j)))-KillOccupy(
      j,n);
 465  *ord(np)-1=0 => Wbar0 which is also included in the above sum, so we dont 
      have to explicitly sum over W now since W0 is also there
 466   
 467  UnitCapacityMax(i,j,n,hbar)$(Ij(i,j) and ord(hbar)-1 eq 0).. Bbar(i,j,n,hb
      ar)=L=Wbar(i,j,n,hbar)*vmaxij(i,j);
 468   
 469  UnitCapacityMin(i,j,n,hbar)$(Ij(i,j) and ord(hbar)-1 eq 0).. Bbar(i,j,n,hb
      ar)=G=Wbar(i,j,n,hbar)*vminij(i,j);
 470   
 471  InventoryLimit(s,n)$(FIS(s)).. Sst(s,n)=L=Cs(s);
 472   
 473  *Watch out for brackets in betahatCons and betaHatProd. One has multiplica
      tion with rho other does not
 474  InventoryBalance(s,n)$(ord(n) lt card(n)).. Sst(s,n+1)=E=Sst(s,n)+sum((i,j
      ,hbar)$(Tbars(i,s) and Ij(i,j) and (ord(hbar) -1 eq pis_new(i,s))),rhobar(
      i,s)*(Bbar(i,j,n,hbar)*(1-Yhat(i,j,n,hbar)-Zhat(i,j,n,hbar))+betaHatProd(i
      ,j,s,n)))
 475                           -sum((i,j,hbar)$(Ts(i,s) and Ij(i,j) and ord(hbar
      ) eq 1),rho(i,s)*Bbar(i,j,n,hbar)+betaHatCons(i,j,s,n)) -Ship(s,n)$(produc
      t_states(s))+Rst(s,n)$(feed_states(s));
 476  EndingInventory(s,n)$(ord(n) eq card(n)).. SstTerminal(s)=E=Sst(s,n)+sum((
      i,j,hbar)$(Tbars(i,s) and Ij(i,j) and (ord(hbar) -1 eq pis_new(i,s))),rhob
      ar(i,s)*(Bbar(i,j,n,hbar)*(1-Yhat(i,j,n,hbar)-Zhat(i,j,n,hbar))+betaHatPro
      d(i,j,s,n)))
 477                           -sum((i,j,hbar)$(Ts(i,s) and Ij(i,j)and ord(hbar)
       eq 1),rho(i,s)*Bbar(i,j,n,hbar)+betaHatCons(i,j,s,n)) -Ship(s,n)$(product
      _states(s))+Rst(s,n)$(feed_states(s));
 478   
 479  ********
 480  *Inventory at point 2 means, inventory level infinitesimal time just befor
      e point 2, ie 2-, need to define extra ending inventory variable SstTermin
      al(s)
 481  *Deliveries are point functions like B, W while inventory is interval func
      tion
 482  *Kondili has convention that inventory at point 2 is 2+, so has to define 
      extra initial inventory parameter Sst0(s)
 483   
 484   
 485  ***********Backlogs******
 486  BacklogBalance(s,n)$(product_states(s) and ord(n) lt card(n)).. Backlog(s,
      n+1)=E=Backlog(s,n)-Ship(s,n)+Dst(s,n);
 487  EndingBacklog(s,n)$(product_states(s) and ord(n) eq card(n)).. BacklogTerm
      inal(s)=E=Backlog(s,n)-Ship(s,n)+Dst(s,n);
 488   
 489  ***********UtilityBalance******
 490  UtilityLimit(u,n).. Uut(u,n)=L=Uutmax(u,n);
 491  UtilityBalance(u,n).. Uut(u,n)=E=sum((i,j,hbar)$(Ij(i,j) and (ord(hbar)-1 
      le pi_new(i)-1)),alpha_new(u,i)*Wbar(i,j,n,hbar)+beta_new(u,i)*Bbar(i,j,n,
      hbar)  );
 492   
 493  UnitUnavailabality(i,j,n)$(UnitUnavailable(j,n) and Ij(i,j)).. sum((hbar)$
      (ord(hbar)-1 le pi_new(i)-1),Wbar(i,j,n,hbar))=E=0;
 494   
 495  *Utility cost: sum((u,n),Cut(u,n)*Uut(u,n))
 496  *objective_MIN_COST.. obj_variable  =E= 1E1*sum(s,Cst_new(s)*SstTerminal(s
      )) +1E1*sum((s,n),Cst_new(s)*Sst(s,n))
 497  *                                 +1E2*sum((s,n)$(product_states(s)),Cst_n
      ew(s)*Backlog(s,n))+1E2*sum(s$(product_states(s)),Cst_new(s)*BacklogTermin
      al(s))
 498  *                                 +sum((i,j,hbar)$Ij(i,j),T(i,j,hbar));
 499  objective_MIN_COST.. obj_variable  =E= 1E1*sum(s,Cst_new(s)*SstTerminal(s)
      ) + 1E1*sum((s,n),Cst_new(s)*Sst(s,n))
 500                                   +1E2*sum((s,n)$(product_states(s)),Cst_ne
      w(s)*Backlog(s,n))
 501                                   +1E2*sum(s$(product_states(s)),Cst_new(s)
      *BacklogTerminal(s))
 502                                   +sum((i,j,n,hbar)$(Ij(i,j) AND ord(hbar)-
      1 eq 0),Wbar(i,j,n,hbar));
 503   
 504   
 505  *objective_MAX_PROFIT.. obj_variable =E= 1E1*sum(s$(product_states(s)),Cst
      _new(s)*SstTerminal(s))+1E1*sum((s,n)$(product_states(s)),Cst_new(s)*Ship(
      s,n))
 506  *                                       -1E2*sum((s,n)$(product_states(s))
      ,Cst_new(s)*Backlog(s,n))-1E2*sum(s$(product_states(s)),Cst_new(s)*Backlog
      Terminal(s) );
 507   
 508  *objective_MAX_PROFIT.. obj_variable =E= 1E1*sum((s,n)$(product_states(s))
      ,Cst_new(s)*Sst(s,n))+1E1*sum(s$(product_states(s)),Cst_new(s)*SstTerminal
      (s))
 509  *                                       -1E2*sum((s,n)$(product_states(s))
      ,Cst_new(s)*Backlog(s,n))-1E2*sum(s$(product_states(s)),Cst_new(s)*Backlog
      Terminal(s))
 510  *                                       +1E1*sum((s,n)$(product_states(s))
      ,Cst_new(s)*Ship(s,n));
 511   
 512  *objective_MAX_PROFIT.. obj_variable =E= sum((s,n)$(product_states(s)),rou
      nd(2-ord(n)/card(n),2)*Cst_new(s)*Ship(s,n))-sum((i,j,n,hbar)$(Ij(i,j) AND
       ord(hbar)-1 eq 0),Wbar(i,j,n,hbar));
 513   
 514  *objective_MAX_PROFIT.. obj_variable =E= sum((s,n)$(product_states(s)),Cst
      _new(s)*(Ship_sales(s,n)))
 515  *objective_MAX_PROFIT.. obj_variable =E= sum((s,n)$(product_states(s)),Cst
      _new(s)*(Ship_sales(s,n)+Ship(s,n)))
 516  objective_MAX_PROFIT.. obj_variable =E= sum((s,n)$(product_states(s)),Cst_
      new(s)*(Ship_sales(s,n)))
 517                                           -sum((i,j,n,hbar)$(Ij(i,j) AND or
      d(hbar)-1 eq 0),Wbar(i,j,n,hbar))
 518                                           -1E2*sum((s,n)$(product_states(s)
      ),Cst_new(s)*Backlog(s,n))
 519                                           -1E2*sum(s$(product_states(s)),Cs
      t_new(s)*BacklogTerminal(s));
 520   
 521  objective_MAX_PROFIT_Greedy.. obj_variable =E= sum((s,n)$(product_states(s
      )),round(2-(ord(n)/card(n)),2)*Cst_new(s)*(Ship(s,n)+Ship_sales(s,n)))
 522                                           -sum((i,j,n,hbar)$(Ij(i,j) AND or
      d(hbar)-1 eq 0),Wbar(i,j,n,hbar))
 523                                           -1E2*sum((s,n)$(product_states(s)
      ),Cst_new(s)*Backlog(s,n))
 524                                           -1E2*sum(s$(product_states(s)),Cs
      t_new(s)*BacklogTerminal(s));
 525   
 526  *objective_MAX_PROFIT.. obj_variable =E= sum((s,n)$(product_states(s)),rou
      nd(2-ord(n)/card(n),2)*Cst_new(s)*Ship(s,n));
 527   
 528  *SHIPMENT(s,n).. Ship(s,n)=L=Dst(s,n)  ;
 529  InventoryBalance_MAX_PROFIT(s,n)$(ord(n) lt card(n)).. Sst(s,n+1)=E=Sst(s,
      n)
 530                           +sum((i,j,hbar)$(Tbars(i,s) and Ij(i,j) and (ord(
      hbar) -1 eq pis_new(i,s))),rhobar(i,s)*Bbar(i,j,n,hbar))
 531                           -sum((i,j,hbar)$(Ts(i,s) and Ij(i,j) and ord(hbar
      ) eq 1),rho(i,s)*Bbar(i,j,n,hbar))
 532                           -Ship_sales(s,n)$(product_states(s))-Ship(s,n)$(p
      roduct_states(s))+Rst(s,n)$(feed_states(s));
 533   
 534  EndingInventory_MAX_PROFIT(s,n)$(ord(n) eq card(n)).. SstTerminal(s)=E=Sst
      (s,n)
 535                           +sum((i,j,hbar)$(Tbars(i,s) and Ij(i,j) and (ord(
      hbar) -1 eq pis_new(i,s))),rhobar(i,s)*Bbar(i,j,n,hbar))
 536                           -sum((i,j,hbar)$(Ts(i,s) and Ij(i,j)and ord(hbar)
       eq 1),rho(i,s)*Bbar(i,j,n,hbar))
 537                           -Ship(s,n)$(product_states(s))-Ship_sales(s,n)$(p
      roduct_states(s))+Rst(s,n)$(feed_states(s));
 538   
 539  *Ship_constraint(s,n)$(ord(n) gt 1 AND ord(n) lt card(n) ).. Ship(s,n)=E=0
      ;
 540  *Ship_constraint(s,n)$(Dst(s,n) eq 0).. Ship_sales(s,n)=E=0;
 541  Ship_constraint(s,n)$(NOT Dst(s,n) gt 0).. Ship_sales(s,n)=E=0;
 542   
 543  *NoTaskRunningAtEndOfHorizon(i,j,n)$(ord(n) eq card(n) and Ij(i,j))..   su
      m(hbar$(ord(hbar)-1 le pi_new(i)-1),Wbar(i,j,n,hbar))=E=0;
 544  NoShip(s,n)$(ord(n) lt card(n)/2 and sameas(s,'M4')).. Ship_sales(s,n)=E=0
      ;
 545  *NoShip(s,n)$(ord(n) lt card(n)/2).. Ship_sales(s,n)=E=0;
 546   
 547  *****************
 548  *DISTURBANCE VARIABLES
 549  *Build feature rich instances and do rigorous testing
 550  *****************
 551   
 552  SET attributes_states /W,B/;
 553  PARAMETERS
 554  record_states_raw(run,calc,attributes_states,i,j,n,hbar),
 555  record_states(run,calc,attributes_states,i,j,n,hbar),
 556  record_objective(run,calc),
 557  record_utility(run,calc,u,n),
 558  record_inventory(run,calc,s,n),
 559  record_inventory_raw(run,calc,s,n),
 560  record_backlog(run,calc,s,n),
 561  record_backlog_raw(run,calc,s,n),
 562  record_inventoryTerminal(run,calc,s),
 563  record_backlogTerminal(run,calc,s)
 564  record_T(run,calc,i,j,hbar)
 565  record_shipment(run,calc,s,n)
 566  record_shipment_sales(run,calc,s,n)
 567  record_shipment_sales_raw(run,calc,s,n)
 568  record_Rst(run,calc,s,n)
 569  record_shipment_raw(run,calc,s,n)
 570  record_Rst_raw(run,calc,s,n)
 571  record_yieldloss(run,calc,i,j,s,n)
 572  record_demands(run,calc,s,n)
 573  record_WbarInfo(run,calc,i,j,n,hbar)
 574  record_BbarInfo(run,calc,i,j,n,hbar)
 575  record_Demands_realization(run,s,h)
 576  record_fixed_decision(calc)
 577  record_reschedule_flag(calc,run)
 578  record_relaxed_objective(run,calc) Objective from solving RMIP
 579  record_relaxed_states(run,calc,attributes_states,i,j,n,hbar) states from s
      olving RMIP
 580  record_relaxed_shipment(run,calc,s,n)
 581  record_relaxed_shipment_sales(run,calc,s,n)
 582  record_relaxed_backlog(run,calc,s,n);
 583   
 584  record_states_raw(run,calc,attributes_states,i,j,n,hbar)=0;
 585  record_states(run,calc,'B',i,j,n,hbar)=0;
 586  record_states(run,calc,'W',i,j,n,hbar)=0;
 587  record_inventory(run,calc,s,n)=0;
 588  record_inventory_raw(run,calc,s,n)=0;
 589  record_backlog(run,calc,s,n)=0;
 590  record_backlog_raw(run,calc,s,n)=0;
 591  record_T(run,calc,i,j,hbar)=0;
 592  record_shipment(run,calc,s,n)=0 ;
 593  record_Rst(run,calc,s,n)=0;
 594  record_shipment_raw(run,calc,s,n)=0;
 595  record_shipment_sales_raw(run,calc,s,n)=0;
 596  record_shipment_sales(run,calc,s,n)=0;
 597  record_Rst_raw(run,calc,s,n)=0;
 598  record_yieldloss(run,calc,i,j,s,n)=0;
 599  record_demands(run,calc,s,n)=0;
 600  record_WbarInfo(run,calc,i,j,n,hbar)=0;
 601  record_BbarInfo(run,calc,i,j,n,hbar)=0;
 602  record_Demands_realization(run,s,h)=0;
 603  record_fixed_decision(calc)=0;
 604  record_reschedule_flag(calc,run)=0;
 605  record_relaxed_objective(run,calc)=0;
 606  record_relaxed_states(run,calc,attributes_states,i,j,n,hbar)=0;
 607  record_relaxed_shipment(run,calc,s,n)=0;
 608  record_relaxed_shipment_sales(run,calc,s,n)=0;
 609  record_relaxed_backlog(run,calc,s,n)=0;
 610   
 611  *Initial conditions for first optimization horizon
 612  PARAMETERS InitialBbar(i,j,n,hbar),InitialWbar(i,j,n,hbar),InitialInventor
      y(s),InitialBacklog(s);
 613  InitialBbar(i,j,n,hbar)=0;
 614  InitialWbar(i,j,n,hbar)=0;
 615  InitialInventory(s)=0;
 616  InitialBacklog(s)=0;
 617   
 618  *if (%InitialInventoryFlag% eq 1,
 619  *Start with half day of inventory
 620  *InitialInventory(s)$product_states(s)=12*demand_magnitude/demand_cycletim
      e;
 621  *);
 622  InitialInventory(s)$product_states(s)=0*demand_magnitude/demand_cycletime;
 623   
 624   
 625  *MODEL P1 /all/;
 626  MODEL MIN_COST /
 627  numberOfBatches,
 628  Allocation,
 629  UnitCapacityMax,
 630  UnitCapacityMin,
 631  *InventoryLimit,
 632  InventoryBalance,
 633  EndingInventory,
 634  BacklogBalance,
 635  EndingBacklog,
 636  *UtilityLimit,
 637  *UtilityBalance,
 638  *UnitUnavailabality,
 639  LiftingW,
 640  LiftingB,
 641  Carryover_W,
 642  Carryover_B,
 643  objective_MIN_COST/;
 644   
 645  MODEL MAX_PROFIT_1 /
 646  numberOfBatches,
 647  Allocation,
 648  UnitCapacityMax,
 649  UnitCapacityMin,
 650  Carryover_B
 651  InventoryBalance_MAX_PROFIT,
 652  LiftingW,
 653  BacklogBalance
 654  LiftingB,
 655  Carryover_W,
 656  objective_MAX_PROFIT
 657  Ship_constraint
 658  EndingInventory_MAX_PROFIT,
 659  EndingBacklog/;
 660   
 661  MODEL MAX_PROFIT_2 /
 662  numberOfBatches,
 663  Allocation,
 664  UnitCapacityMax,
 665  UnitCapacityMin,
 666  InventoryBalance_MAX_PROFIT,
 667  EndingInventory_MAX_PROFIT,
 668  BacklogBalance,
 669  EndingBacklog,
 670  LiftingW,
 671  LiftingB,
 672  Carryover_W,
 673  Carryover_B,
 674  objective_MAX_PROFIT
 675  Ship_constraint/;
 676   
 677  MODEL MAX_PROFIT_GREEDY /
 678  numberOfBatches,
 679  Allocation,
 680  UnitCapacityMax,
 681  UnitCapacityMin,
 682  InventoryBalance_MAX_PROFIT,
 683  EndingInventory_MAX_PROFIT,
 684  BacklogBalance,
 685  EndingBacklog,
 686  LiftingW,
 687  LiftingB,
 688  Carryover_W,
 689  Carryover_B,
 690  *objective_MAX_PROFIT
 691  objective_MAX_PROFIT_Greedy
 692  Ship_constraint/;
 693  *NoShip/;
 694   
 695  MODEL MAX_PROFIT_NOSHIP /
 696  numberOfBatches,
 697  Allocation,
 698  UnitCapacityMax,
 699  UnitCapacityMin,
 700  InventoryBalance_MAX_PROFIT,
 701  EndingInventory_MAX_PROFIT,
 702  BacklogBalance,
 703  EndingBacklog,
 704  LiftingW,
 705  LiftingB,
 706  Carryover_W,
 707  Carryover_B,
 708  objective_MAX_PROFIT
 709  *objective_MAX_PROFIT_Greedy
 710  Ship_constraint
 711  NoShip/;
 712   
 713  MODEL MAX_PROFIT_GREEDY_NOSHIP /
 714  numberOfBatches,
 715  Allocation,
 716  UnitCapacityMax,
 717  UnitCapacityMin,
 718  InventoryBalance_MAX_PROFIT,
 719  EndingInventory_MAX_PROFIT,
 720  BacklogBalance,
 721  EndingBacklog,
 722  LiftingW,
 723  LiftingB,
 724  Carryover_W,
 725  Carryover_B,
 726  *objective_MAX_PROFIT
 727  objective_MAX_PROFIT_Greedy
 728  Ship_constraint
 729  NoShip/;
 730   
 731  *SHIPMENT/;
 732   
 733   
 734  T.l(i,j,hbar)=0;
 735  *Parameters for Gantt Charting in Excel
 736  *END OF MODEL FILE
 737   
 738   
 739   
 740   
 741  PARAMETER runcost(run) cost of implemented closed loop
 742           runcost_Inv(run) Inventory cost,runcost_BO(run) Backlog cost, run
      cost_W(run) start_cost_of_tasks
 743           runprofit(run) closed loop profit in MAX_profit
 744           sales_profit(run);
 745   
 746           runcost_Inv(run)=0;runcost_BO(run)=0; runcost_W(run)=0;runcost(ru
      n)=0; runprofit(run)=0;sales_profit(run)=0;
 747   
 748  PARAMETER modelStat(calc,run)     Should be 1 for successful optimization
 749            BOStat_OL(calc,run)     If 1 means open loop had non zero back o
      rder
 750            BOStat_CL(calc,run)     If 1 means closed loop had non zero back
       order
 751            IntegralityGap(calc,run)
 752            Est_modelGap1(calc,run)  Estimated optimality gap by CPLEX (obj.
      val in denominator)
 753            Est_modelGap2(calc,run)  Estimated optimality gap by CPLEX (obj.
      Est in denominator)
 754            True_modelGap(calc,run) True optimality gap obtained by solving 
      to optcr=0
 755            ETSolve(calc,run)
 756            ETSolver(calc,run)
 757            iterUsd(calc,run)
 758            nodUsd(calc,run)
 759            resUsd(calc,run)
 760            numDVar(calc,run)
 761            numEqu(calc,run)
 762            numInfes(calc,run)
 763            numNZ(calc,run)
 764            numVar(calc,run)
 765            solveStat(calc,run)
 766            Suboptimal_objective /0/
 767            Optimal_Objective /0/
 768            TimeToSolveOptimal(calc,run);
 769   
      ********************DEMAND SAMPLING TO KEEP IT STANDARDIZED FOR ALL APPROA
      CHES(NOMINAL, ROBUST, STOCHASTIC)************************
      ******DEMAND INFORMATION*****************************
      *Each order for all products
      SET         o orders /o1*o%H%/;
      PARAMETER deliveries_time(o,run);
      deliveries_time(o,run)=demand_cycletime*ord(o);
      PARAMETER deliveries(o,s);
      deliveries(o,s)$(product_states(s))=demand_magnitude;
      ******DEMAND INFORMATION*****************************
       
      PARAMETER Dst_full(s,h);
      Dst_full(s,h)=sum(o,deliveries(o,s)$(ord(h)-1 eq floor(deliveries_time(o)/
      %delta%)));
       
      PARAMETER Dst_full_realization(s,h,run);
      Dst_full_realization(s,h,run)=Dst_full(s,h);
       
      *IF(%Demand_Disturbance_flag% eq 1,
               LOOP(run,
                  deliveries_time(o,run)=deliveries_time(o,run)+UniformInt(-dema
      nd_variation,demand_variation);
                  Dst_full_realization(s,h,run)=(Dst_full(s,h)+Dst_full(s,h)*uni
      formInt(-lambda_Demand,lambda_Demand)  )$(Dst_full(s,h) gt 0);
               );
      *);
      ********************DEMAND SAMPLING TO KEEP IT STANDARDIZED FOR ALL APPROA
      CHES(NOMINAL, ROBUST, STOCHASTIC)************************
 795  ********************DEMAND SAMPLING TO KEEP IT STANDARDIZED FOR ALL APPROA
      CHES(NOMINAL, ROBUST, STOCHASTIC)************************
 796  ******DEMAND INFORMATION*****************************
 797  *Each order for all products
 798  SET         o orders /o1*o216/;
 799  PARAMETER deliveries_time(o,run);
 800  deliveries_time(o,run)=demand_cycletime*ord(o);
 801  PARAMETER deliveries(o,s);
 802  deliveries(o,s)$(product_states(s))=demand_magnitude;
 803  ******DEMAND INFORMATION*****************************
 804   
 805  PARAMETER Dst_full_realization(s,h,run),Dst_full(s,h);
 806   
 807  *IF(%Demand_Disturbance_flag% eq 1,
 808  LOOP(run,
 809    deliveries_time(o,run)=deliveries_time(o,run)+UniformInt(-demand_variati
      on,demand_variation);
 810    Dst_full_realization(s,h,run)=sum(o,deliveries(o,s)$(ord(h)-1 eq floor(d
      eliveries_time(o,run)/1)));
 811    Dst_full_realization(s,h,run)=(Dst_full_realization(s,h,run)+Dst_full_re
      alization(s,h,run)/100*uniformInt(-lambda_Demand*100,lambda_Demand*100)  )
      $(Dst_full_realization(s,h,run) gt 0);
 812  );
 813  *);
 814  ********************DEMAND SAMPLING TO KEEP IT STANDARDIZED FOR ALL APPROA
      CHES(NOMINAL, ROBUST, STOCHASTIC)************************
 815   
 816   
 817  PARAMETER ClosedLoopINV(run,s,h),ClosedLoopBO(run,s,h),ClosedLoopShip(run,
      s,h),ClosedLoopShip_sales(run,s,h),
 818            ClosedLoopStart(run,h),Cost_EndInventory(run),ClosedLoopExecutio
      ns(run,i);
 819  ClosedLoopINV(run,s,h)=0;
 820  ClosedLoopBO(run,s,h)=0;
 821  ClosedLoopShip(run,s,h)=0;
 822  ClosedLoopShip_sales(run,s,h)=0;
 823  ClosedLoopStart(run,h)=0;
 824  Cost_EndInventory(run)=0;
 825  ClosedLoopExecutions(run,i)=0;
 826  *This parameter switches to 1 at end of this file
 827  *indicating a succesful run(sweep of code) throughout
 828  PARAMETER SUCCESS /0/;
 829   
 830   
 831  PARAMETER timeLeft /0/;
 832  PARAMETER endingSeed /0/;
 833  *PARAMETER sample /0/;
 834   
 835  ********************STOPPING CRITERION*************
      PARAMETER mean_runcost(run), std_dev_runcost(run), delta_std_dev_runcost(r
      un), max_delta_std_dev_runcost(run), N_run count of runs;
      mean_runcost(run)=0;
      std_dev_runcost(run)=0;
      delta_std_dev_runcost(run)=0;
      max_delta_std_dev_runcost(run)=0;
      N_run=0;
      ALIAS(run,run_p);
      ********************STOPPING CRITERION*************
 846   
 847  ********************[Start] Evaluations Runs *****************************
      **********
 848  loop(run,
      put screen;
      put 'I am on run ' run.tl;
      putclose;
      put log;
      put 'I am on run ' run.tl;
      putclose;
 857   
 858  *We need to reset Dst_full(s,h) with each run to nominal values
 859  *and then as MH goes forward, Dst_full slowly takes the value of Dst_full_
      realization
 860  *for that particular run, after which here we need to refresh it to nomina
      l values
 861  Dst_full(s,h)=sum(o,deliveries(o,s)$(ord(h)-1 eq floor(deliveries_time(o,r
      un)/1)));
 862   
 863  if(0 eq 1,
 864  abort$1 "Look into robust case demand generation in MasterFile and make su
      re its correct";
 865           Dst_full(s,h)=Dst_full(s,h)*(1+ lambda_Demand);
 866  );
 867  *this time sample is equal to 1, so we are in evaluation mode
INCLUDE    C:\Users\dhruv\Box Sync\Work\Codes\GAMS_Code_Paper1\ModelSolution9.gm
           s
 869  loop(calc,
 870  *Caution: Watch out W equations in case changeovers are involved with rega
      rds to lifting(pi(i)+tauC)
 871  *fixed_decisions=re_freq-1-mod(ord(calc)-1+re_freq-1,re_freq);
 872  *abort$1 "stopped for debugging";
 873  *abort$(ord(calc)-1 eq 1) "stopped for debugging";
 874   
 875  *********VARIABLE RESCHEDULING FREQUENCY********
 876  *resetting old parameter values
 877  WbarInfo(i,j,n,hbar)=0;
 878  BbarInfo(i,j,n,hbar)=0;
 879   
 880  *DEMAND SAMPLING
 881  *Picking realized demand upto surprise factor within MH from demand_sample
       generated for this run
 882          Dst_full(s,h)$(ord(h)-1 le (ord(calc)-1 + ceil(card(n)*(1-surprise
      ))) )=Dst_full_realization(s,h,run);
 883  *Now allocating demands to the rolling horizon calculation
 884          Dst(s,n)=sum(h$((ord(h)-1) eq (ord(n)-1+ord(calc)-1)),Dst_full(s,h
      ));
 885   
 886   
      * EVENT BASED RESCHEDULING (HAS BUG: when moving horizon is shorter than r
      escheduling freq, more decisions
      *are wrongly fixed)
      if (re_freq=0,
      *Reschedule flag is 1 for first optimization
              reschedule_flag=0;
      *Now see if we should reschedule or not depending on whether new demand ca
      me or not
              reschedule_flag=1$(sum((s,n)$(ord(n) eq card(n)),Dst(s,n)) > 0);
      *Also do find schedule for the very first optimization
              reschedule_flag$(ord(calc)-1 eq 0)=1;
      *Now decide the fixed decisions (W,B) depending on rescheduling_flag
              if (reschedule_flag=1,
      *Complete freedom to start new tasks (subject to old tasks not already run
      ning)
                      fixed_decisions=0;
              else
      *Forced to follow previous fixed (planned) decisions
                      fixed_decisions=card(n)-1;
              );
      else
 907          fixed_decisions=re_freq-1 - mod(ord(calc)-1+(re_freq-1),re_freq);
 908          reschedule_flag=0;
 909          reschedule_flag$(fixed_decisions=0)=1;
 910  *);
 911  record_fixed_decision(calc)=fixed_decisions;
 912  record_reschedule_flag(calc,run)=reschedule_flag;
 913   
 914  *Unfix fixed variables
 915  Ship.lo(s,n)=0;Ship.up(s,n)=Inf;
 916  Rst.lo(s,n)=0;Rst.up(s,n)=Inf;
 917  Ship_sales.lo(s,n)=0;Ship_sales.up(s,n)=Inf;
 918  *Uut.lo(u,n)=0; Uut.up(u,n)=Inf;
 919  *Fix Input states
 920  WbarInfo(i,j,n,hbar)$(ord(n)-1 le fixed_decisions and ord(hbar)-1 le pi(i)
       and Ij(i,j))=record_states(run,calc-1,'W',i,j,n,hbar-1)+InitialWbar(i,j,n
      ,hbar)$(ord(calc)-1 eq 0)+Yhat(i,j,n,hbar)-Yhat(i,j,n,hbar-1);
 921  BbarInfo(i,j,n,hbar)$(ord(n)-1 le fixed_decisions and ord(hbar)-1 le pi(i)
       and Ij(i,j))=record_states(run,calc-1,'B',i,j,n,hbar-1)+InitialBbar(i,j,n
      ,hbar)$(ord(calc)-1 eq 0)+record_states(run,calc-1,'B',i,j,n,hbar)*Yhat(i,
      j,n,hbar)-record_states(run,calc-1,'B',i,j,n,hbar-1)*Yhat(i,j,n,hbar-1);
 922  Ship.fx(s,n)$(ord(n)-1 le fixed_decisions-1)=record_shipment(run,calc-1,s,
      n+1);
 923  Rst.fx(s,n)$(ord(n)-1 le fixed_decisions-1)=record_Rst(run,calc-1,s,n+1);
 924  Ship_sales.fx(s,n)$(ord(n)-1 le fixed_decisions-1)=record_shipment_sales(r
      un,calc-1,s,n+1);
 925  T.fx(i,j,hbar)=0;
 926  *********VARIABLE RESCHEDULING FREQUENCY********
 927   
 928  *Since inventory and backlog depend on the inputs, as long as we have corr
      ectly carried over the inventory we are good
 929  Sst.fx(s,n)$(ord(n)-1 le 0)=record_inventory(run,calc-1,s,n+1)+InitialInve
      ntory(s)$(ord(calc)-1 eq 0);
 930  Backlog.fx(s,n)$(ord(n)-1 le 0)=record_backlog(run,calc-1,s,n+1)+InitialBa
      cklog(s)$(ord(calc)-1 eq 0);
 931  *Uut.fx(u,n)$(ord(n)-1 le 0)=record_utility(run,calc-1,u,n+1);
 932   
 933   
 934  *Fix backlogs to zero if corresponding flag is 0
 935  if(1 eq 0,
 936  Backlog.fx(s,n)=0;
 937  BacklogTerminal.fx(s)=0;
 938  );
 939  *Dst(s,n)$(product_states(s) AND ord(n) eq 1) = 1;
 940  *Ship_sales.fx(s,n)$(ord(n)-1 eq 0 AND sameas(s,'M4')) = 8.05;
 941  *Ship_sales.fx(s,n)$(ord(n) lt card(n)) = 0;
 942   
 943  *cc=execseed;
 944  ***************SAMPLING DISTURBANCES/UNCERTAINTIES************************
      ******
 945  *Introducing disturbance in demand by modifying Dst_full(s,h) only if Dist
      urbance flag is 1(on)
 946  *if(%Demand_Disturbance_Flag% eq 1,
 947  *);
 948   
 949  **UNCOMMENT HERE TO HERE  (commented for event based rescheduling)
 950  **        Dst_full(s,h)$(ord(h)-1 le (ord(calc)-1 + ceil(card(n)*(1-surpri
      se))) )=Dst_full_realization(s,h,run);
 951  *Now allocating demands to the rolling horizon calculation
 952  *        Dst(s,n)=sum(h$((ord(h)-1) eq (ord(n)-1+ord(calc)-1)),Dst_full(s,
      h));
 953  **UNCOMMENT HERE TO HERE
 954  *Display Dst_full;
 955   
 956   
 957  *UnitBreakdown disturbance
 958  *First breakdown unit for whole horizon and then sample after 1 time step
 959  *when it is coming back
 960  UnitBroken(j,n)=0;
 961  Zhat(i,j,n,hbar)=0;
 962  if(0 eq 1 and ord(calc)-1 ge 2,
 963           Breakdown(calc,i,j,hbar)$(Ij(i,j) and ord(hbar)-1 le pi(i) and De
      lay(calc-1,i,j,hbar-1) eq 0)=1$(uniform(0,1) gt 0.9 and Duration_breakdown
      (calc-1,j) eq 0 and (sum(n$(ord(n)-1 eq 0),record_states(run,calc-1,'W',i,
      j,n,hbar-1)) gt 0));
 964   
 965  *If there is a delay ongoing then sample this breakdown
 966           Breakdown(calc,i,j,hbar)$(Ij(i,j) and ord(hbar)-1 le pi(i) and De
      lay(calc-1,i,j,hbar) gt 0)=1$(uniform(0,1) gt 0.9 and Duration_breakdown(c
      alc-1,j) eq 0 and (sum(n$(ord(n)-1 eq 0),record_states(run,calc-1,'W',i,j,
      n,hbar)) gt 0));
 967   
 968  *Assume on breakdown that the unit by default is not available the whole r
      emaining horizon and then
 969  *resample after one time step when it is due to come back[here half of rol
      ling horizon length]
 970   
 971  *         Duration_breakdown(calc,j)=floor(uniform(0,card(n)/2))$(sum((hba
      r,i)$(Ij(i,j) and ord(hbar)-1 le pi(i)),Breakdown(calc-1,i,j,hbar)) eq 1 a
      nd Duration_breakdown(calc-1,j) eq (card(h)))
 972  *                                         +(Duration_breakdown(calc-1,j)-1
      )$(Duration_breakdown(calc-1,j) gt 0 and Duration_breakdown(calc-1,j) lt c
      ard(h))
 973  *                                         +card(h)$(sum((hbar,i)$(Ij(i,j) 
      and ord(hbar)-1 le pi(i)),Breakdown(calc,i,j,hbar)) eq 1);
 974           Duration_breakdown(calc,j)=2$(sum((hbar,i)$(Ij(i,j) and ord(hbar)
      -1 le pi(i)),Breakdown(calc-1,i,j,hbar)) eq 1 and Duration_breakdown(calc-
      1,j) eq (card(h)))
 975                                           +(Duration_breakdown(calc-1,j)-1)
      $(Duration_breakdown(calc-1,j) gt 0 and Duration_breakdown(calc-1,j) lt ca
      rd(h))
 976                                           +(card(h))$(sum((hbar,i)$(Ij(i,j)
       and ord(hbar)-1 le pi(i)),Breakdown(calc,i,j,hbar)) eq 1);
 977  *display Breakdown,duration_breakdown;
 978   
 979           UnitBroken(j,n)=0;
 980           UnitBroken(j,n)$(ord(n)-1 lt Duration_breakdown(calc,j))=1;
 981   
 982           Zhat(i,j,n,hbar)=0;
 983           Zhat(i,j,n,hbar)$(ord(n)-1 eq 0 and Breakdown(calc,i,j,hbar) eq 1
      )=1;
 984   
 985  );
 986   
 987   
 988   
 989  *Disturbance associated with delay in tasks, hbar indicates the running st
      atus of the task
 990  *Due to nature of lifting, there is already a 1 time unit lag, hence we li
      mit hbar from 0 to pi(i)
 991  *so that recordstates is accessed only upto pi(i)-1. Record state being pi
      (i) means that the task
 992  *was already over in the last horizon
 993  if(0 eq 1,
 994  *          Delay(calc,i,j,hbar)$(Ij(i,j) and ord(hbar)-1 le pi(i))=(Delay(
      calc-1,i,j,hbar)-1)$(Delay(calc-1,i,j,hbar) ge 1)
 995  *                                                            +2$(uniform(0
      ,1) ge 0 and (sum(n$(ord(n)-1 eq 0),record_states(calc-1,'W',i,j,n,hbar-1)
      ) gt 0) and Delay(calc-1,i,j,hbar-1) eq 0);
 996            Delay(calc,i,j,hbar)$(Ij(i,j) and ord(hbar)-1 le pi(i))=(Delay(c
      alc-1,i,j,hbar)-1)$(Delay(calc-1,i,j,hbar) ge 1);
 997            Delay(calc,i,j,hbar)$(Ij(i,j) and ord(hbar)-1 le pi(i) and Delay
      (calc-1,i,j,hbar) eq 0)=2$(uniform(0,1) ge 0.6 and (sum(n$(ord(n)-1 eq 0),
      record_states(run,calc-1,'W',i,j,n,hbar-1)) gt 0 and Delay(calc-1,i,j,hbar
      -1) eq 0));
 998  *          Delay(calc,i,j,hbar)$(Ij(i,j) and ord(n)-1 eq 0)=(Delay(calc-1,
      i,j,hbar)-1)$(Delay(calc-1,i,j,hbar) gt 0)
 999  *          Yhat(i,j,n,hbar)$(Ij(i,j) and ord(n)-1 eq 0)=1$(uniform(0,1) gt
       0 and record_states(calc-1,'W',i,j,n,hbar-1) gt 0);
1000   
1001  *display Delay;
1002  *Wipes out previous Yhats
1003            Yhat(i,j,n,hbar)=0;
1004  *Over-rides Delays with Unit breakdown. ie if unit breakdown occurs then t
      here cannot be a delay
1005            Delay(calc,i,j,hbar)=Delay(calc,i,j,hbar)$(sum(n$(ord(n)-1 eq 0)
      ,Zhat(i,j,n,hbar)+Zhat(i,j,n,hbar+1)) eq 0);
1006  *          Yhat(i,j,n,hbar)$(Ij(i,j) and ord(n)-1 eq 0)=1$(Delay(calc,i,j,
      hbar) gt 0);
1007            Yhat(i,j,n,hbar)$(Ij(i,j) and ord(n)-1 lt Delay(calc,i,j,hbar))=
      1$(Delay(calc,i,j,hbar) gt 0);
1008   
1009  *          Yhat(i,j,n,hbar)$(Ij(i,j) and ord(n)-1 eq 0 and ord(hbar)-1 le 
      pi(i))=1$(uniform(0,1) ge 0 and record_states(calc-1,'W',i,j,n,hbar) gt 0)
      ;
1010  *          WbarInfo(i,j,n,hbar)$Yhat(i,j,n,hbar)=1;
1011  *          BbarInfo(i,j,n,hbar)$Yhat(i,j,n,hbar)=record_states(calc-1,'W',
      i,j,n,hbar);
1012  );
1013   
1014  *display Yhat;
1015  *display WbarInfo;
1016  *display BbarInfo;
1017   
1018   
1019  *Introducing disturbance in material handling(loading/unloading)
1020  *Here we implement only production disturbance because its more likely tha
      n consumption disturbance
1021  *Consumption disturbance has the tricky part that if loading was 5 units, 
      and we had just 5 units, the task is already started and we cant
1022  *then add a disturbance on top of it saying 5.5 units was actually consume
      d because the task has already started.
1023  if(0 eq 1,
1024  *the last two multiplication of (1-z(h+1))(1-z(h)) are when there are only
       unit breakdown, and when there is unit breakdown in middle of delay respe
      ctively
1025  *betaHatProd(i,j,s,n)$(Tbars(i,s) and Ij(i,j) and ord(n)-1 eq 0 and produc
      t_states(s))=uniform(-0.1,0)*sum(hbar$(ord(hbar) -1 eq pis_new(i,s)-1),rec
      ord_states(calc-1,'B',i,j,n,hbar)*(1-Yhat(i,j,n,hbar+1))*(1-Zhat(i,j,n,hba
      r+1))*(1-Zhat(i,j,n,hbar)));
1026  *wipes out previous parameter values
1027  betaHatProd(i,j,s,n)=0;
1028  betaHatProd(i,j,s,n)$(Tbars(i,s) and Ij(i,j) and ord(n)-1 eq 0)=uniform(-0
      .1,0)*sum(hbar$(ord(hbar) -1 eq pis_new(i,s)),BbarInfo(i,j,n,hbar)*(1-Yhat
      (i,j,n,hbar))*(1-Zhat(i,j,n,hbar))*(1-Zhat(i,j,n,hbar-1)));
1029  *betaHatProd(i,j,s,n)$(Tbars(i,s) and Ij(i,j) and ord(n)-1 eq 0)=uniform(-
      0.1,0)*sum(hbar$(ord(hbar) -1 eq pis_new(i,s)-1),record_states(calc-1,'B',
      i,j,n,hbar)*(1-Yhat(i,j,n,hbar+1))*(1-Zhat(i,j,n,hbar)));
1030  *betaHatProd(i,j,s,n)$(Tbars(i,s) and Ij(i,j) and ord(n)-1 eq 0)=uniform(-
      0.1,0)*sum(hbar$(ord(hbar) -1 eq pis_new(i,s)-1),record_states(calc-1,'B',
      i,j,n,hbar));
1031  );
1032  *Display betaHatProd;
1033   
1034   
1035  *Correct allocation constraint
1036  *KillDurationCountdown(i,j)$Ij(i,j)=%KillSwitch%$(sum(hbar,T.l(i,j,hbar)) 
      gt 0);
1037  KillOccupy(j,n)=0;
1038  KillDuration(i,j)$Ij(i,j)=KillLength$(0);
1039  *KillDuration(i,j)$Ij(i,j)=(%KillSwitch%+1)$(sum(hbar,T.l(i,j,hbar)) gt 0 
      and KillDuration(i,j) eq 0);
1040  *KillDuration(i,j)$(Ij(i,j) and KillDuration(i,j) <> 0)=KillDuration(i,j)-
      1;
1041  KillCountdown(j)=sum((i,hbar)$Ij(i,j),T.l(i,j,hbar)*KillDuration(i,j))  +(
      KillCountdown(j)-1)$(KillCountdown(j) gt 0);
1042  KillOccupy(j,n)$(ord(n)-1 lt KillCountdown(j)-1)=1;
1043  if(0 eq 0,
1044     T.fx(i,j,hbar)=0;
1045  );
1046  *Display Breakdown,Duration_breakdown,UnitBroken,Zhat,KillOccupy;
1047  ***************SAMPLING DISTURBANCES/UNCERTAINTIES************************
      ******
1048   
1049  ***************UTILITIES**************************************************
      ******
1050  Uutmax(u,n)=sum(h$((ord(h)-1) eq (ord(n)-1+ord(calc)-1)),Uutmax_full(u,h))
      ;
1051  Unitunavailable(j,n)=sum(h$((ord(h)-1) eq (ord(n)-1+ord(calc)-1)),Unitunav
      ailable_full(j,h));
1052  Cut(u,n)=sum(h$((ord(h)-1) eq (ord(n)-1+ord(calc)-1)),Cut_full(u,h));
1053  *Correct Cutfull calculation, all the relation of taking hours to time poi
      nts
1054  *This correction is needed in model file
1055  ***************UTILITIES**************************************************
      ******
1056  *Display Dst;
1057   
1058  *abort$(sameas(calc,"calc25")) "stopped for debugging";
1059  *Solve optimization horizon
1060   
1061  Option IntVarUp=0;
1062  *******************FIND OPEN LOOP SCHEDULE********************************
      ******
1063  MIN_COST.optcr = optcr_value$(reschedule_flag)+1$(NOT reschedule_flag);
1064  MIN_COST.reslim = timelimit;
1065  MIN_COST.holdFixed=1;
1066  solve MIN_COST using MIP MINIMIZING obj_variable;
1067   
1068  modelStat(calc,run)=MIN_COST.ModelStat;
1069  *Watch out what should be denominator, Relaxed or Best found solution
1070  *Cplex uses division by best found integer solution
1071  Est_modelGap1(calc,run)=abs((MIN_COST.objEst-MIN_COST.objVal)/(MIN_COST.ob
      jVal+1E-10));
1072  Est_modelGap2(calc,run)=abs((MIN_COST.objEst-MIN_COST.objVal)/(MIN_COST.ob
      jEst+1E-10));
1073  Suboptimal_objective=MIN_COST.objVal;
1074   
1075  ETSolve(calc,run)=MIN_COST.etSolve;
1076  ETSolver(calc,run)=MIN_COST.etSolver;
1077  iterUsd(calc,run)=MIN_COST.iterUsd;
1078  nodUsd(calc,run)=MIN_COST.nodUsd;
1079  resUsd(calc,run)=MIN_COST.resUsd;
1080  numDVar(calc,run)=MIN_COST.numDVar;
1081  numEqu(calc,run)=MIN_COST.numEqu;
1082  numInfes(calc,run)=MIN_COST.numInfes;
1083  numNZ(calc,run)=MIN_COST.numNZ;
1084  numVar(calc,run)=MIN_COST.numVar;
1085  solveStat(calc,run)=MIN_COST.solveStat;
1086   
1087  *Recording optimized variables for each optimization horizon
1088  record_states_raw(run,calc,'B',i,j,n,hbar)$(ord(hbar)-1 le pi(i) and Ij(i,
      j))= Bbar.l(i,j,n,hbar);
1089  record_states_raw(run,calc,'W',i,j,n,hbar)$(ord(hbar)-1 le pi(i) and Ij(i,
      j))= Wbar.l(i,j,n,hbar);
1090  record_states(run,calc,'B',i,j,n,hbar)$(ord(hbar)-1 le pi(i) and Ij(i,j))=
       round(Bbar.l(i,j,n,hbar),2)$(Bbar.l(i,j,n,hbar) ge vminij(i,j)+Small_numb
      er and Bbar.l(i,j,n,hbar) le vmaxij(i,j)-Small_number) + round(Bbar.l(i,j,
      n,hbar))$(NOT (Bbar.l(i,j,n,hbar) ge vminij(i,j)+Small_number and Bbar.l(i
      ,j,n,hbar) le vmaxij(i,j)-Small_number));
1091  record_states(run,calc,'W',i,j,n,hbar)$(ord(hbar)-1 le pi(i) and Ij(i,j))=
       round(Wbar.l(i,j,n,hbar));
1092  record_T(run,calc,i,j,hbar)$(ord(hbar)-1 le pi(i) and Ij(i,j))= T.l(i,j,hb
      ar);
1093  record_inventory(run,calc,s,n)=round(Sst.l(s,n),3);
1094  record_backlog(run,calc,s,n)=round(Backlog.l(s,n),3);
1095  record_inventory_raw(run,calc,s,n)=Sst.l(s,n);
1096  record_backlog_raw(run,calc,s,n)=Backlog.l(s,n);
1097  record_yieldloss(run,calc,i,j,s,n)=betaHatProd(i,j,s,n);
1098  record_objective(run,calc)=obj_variable.l;
1099  record_utility(run,calc,u,n)=Uut.l(u,n);
1100  record_inventoryTerminal(run,calc,s)=SstTerminal.l(s);
1101  record_backlogTerminal(run,calc,s)=BacklogTerminal.l(s);
1102  record_shipment_raw(run,calc,s,n)=Ship.l(s,n);
1103  record_shipment(run,calc,s,n)=round(Ship.l(s,n),2);
1104  record_shipment_sales_raw(run,calc,s,n)=Ship_sales.l(s,n);
1105  record_shipment_sales(run,calc,s,n)=round(Ship_sales.l(s,n),2);
1106  record_Rst_raw(run,calc,s,n)=Rst.l(s,n);
1107  record_Rst(run,calc,s,n)=round(Rst.l(s,n),2);
1108  record_demands(run,calc,s,n)=Dst(s,n);
1109  record_Demands_realization(run,s,h)=Dst_Full_Realization(s,h,run);
1110   
1111  record_WbarInfo(run,calc,i,j,n,hbar)=WbarInfo(i,j,n,hbar);
1112  record_BbarInfo(run,calc,i,j,n,hbar)=BbarInfo(i,j,n,hbar);
1113   
1114  BOStat_OL(calc,run) =  1$(sum((s,n),record_backlog(run,calc,s,n)+record_ba
      cklogTerminal(run,calc,s)) > 0);
1115  BOStat_CL(calc,run) =  1$(sum((s,n)$(ord(n)-1 eq 0),record_backlog(run,cal
      c,s,n)) > 0);
1116   
1117  *display ship.l;
1118  Optimal_Objective=Suboptimal_Objective;
1119  ***********************FIND OPTIMAL OBJECTIVE IF OPTCR <>0****************
      *
1120  IF(MIN_COST.optcr <> 0 AND reschedule_flag eq 1,
      put screen;
      put 'Now solving optimal open loop';
      putclose;
1126  MIN_COST.optcr=0;
1127  solve MIN_COST using MIP MINIMIZING obj_variable;
1128  Optimal_Objective=MIN_COST.objVal;
1129  True_modelGap(calc,run)=(Suboptimal_objective-Optimal_Objective)/(Optimal_
      objective+1E-10);
1130  TimeToSolveOptimal(calc,run)=MIN_COST.resUsd;
1131  );
1132   
1133  ***********************FIND OPTIMAL OBJECTIVE IF OPTCR <>0****************
      *
1134   
1135  ******WARNING: ALL VARIABLE LEVEL VALUES ARE THOSE OF OPTCR=0 NOW*********
      *
1136   
1137  IF (reschedule_flag eq 1,
1138  ***********************SOLVE RMIP TO GET INTEGRALITY GAP*****************
1139  solve MIN_COST using RMIP MINIMIZING obj_variable;
1140  record_relaxed_objective(run,calc)=obj_variable.l;
1141  IntegralityGap(calc,run)=record_relaxed_objective(run,calc)/(Optimal_Objec
      tive+1E-10);
1142  record_relaxed_states(run,calc,'B',i,j,n,hbar)$(ord(hbar)-1 le pi(i) and I
      j(i,j))= Bbar.l(i,j,n,hbar);
1143  record_relaxed_states(run,calc,'W',i,j,n,hbar)$(ord(hbar)-1 le pi(i) and I
      j(i,j))= Wbar.l(i,j,n,hbar);
1144  record_relaxed_shipment(run,calc,s,n)=Ship.l(s,n);
1145  record_relaxed_shipment_sales(run,calc,s,n)=Ship_sales.l(s,n);
1146  record_relaxed_backlog(run,calc,s,n)=Backlog.l(s,n);
1147  );
1148  ***********************SOLVE RMIP TO GET INTEGRALITY GAP*****************
1149   
1150  ******WARNING: ALL VARIABLE LEVEL VALUES ARE THOSE OF RMIP NOW**********
1151   
1152  );
1153  **END OF CALC LOOP HERE
1154   
1155  *END OF SOLUTION FILE
1156   
1157   
1158   
1159  loop((n,calc)$(ord(n)-1 eq 0),
1160           ClosedLoopINV(run,s,h)$(ord(h) eq ord(calc))=record_inventory(run
      ,calc,s,n);
1161           ClosedLoopBO(run,s,h)$(ord(h) eq ord(calc))=record_backlog(run,ca
      lc,s,n);
1162           ClosedLoopShip(run,s,h)$(ord(h) eq ord(calc))=record_shipment(run
      ,calc,s,n);
1163           ClosedLoopShip_sales(run,s,h)$(ord(h) eq ord(calc))=record_shipme
      nt_sales(run,calc,s,n);
1164           ClosedLoopStart(run,h)$(ord(calc) eq ord(h))=sum((i,j,hbar)$(Ij(i
      ,j) AND ord(hbar)-1 eq 0),record_states(run,calc,'W',i,j,n,hbar));
1165  *         ClosedLoopStart(run,h)$(ord(calc) eq ord(h))=0;
1166  );
1167           ClosedLoopExecutions(run,i)=sum((calc,j,n,hbar)$(Ij(i,j) AND ord(
      hbar)-1 eq 0
1168                                           AND ord(n)-1 eq 0 AND ord(calc)-1
       le 8-1),
1169                                           record_states(run,calc,'W',i,j,n,
      hbar));
1170   
1171  *         runcost_Inv(run)=1E1*sum((s,h)$closed_loop(h),Cst_new(s)*Sinv(s,
      h));
1172  *         runcost_BO(run)=1E2*sum((s,h)$closed_loop(h),Cst_new(s)*BO(s,h))
      ;
1173           runcost_Inv(run)=1E1*sum((s,h)$closed_loop(h),Cst_new(s)*ClosedLo
      opINV(run,s,h));
1174           runcost_BO(run)=1E2*sum((s,h)$closed_loop(h),Cst_new(s)*ClosedLoo
      pBO(run,s,h));
1175           runcost_W(run)=sum((h)$closed_loop(h),ClosedLoopStart(run,h));
1176  *total profit from all shipments (demand+sales)
1177   
1178           runcost(run)=runcost_Inv(run)+runcost_BO(run)+runcost_W(run);
1179   
1180  *         sales_profit(run)=sum( (s,h)$(product_states(s) and closed_loop(
      h) and (ord(h)-1 ne %Closed_Loop_Upper_delta%) ),
1181  *                                 Cst_new(s)*(ClosedLoopShip(run,s,h)+Clos
      edLoopShip_sales(run,s,h) ));
1182           sales_profit(run)=sum( (s,h)$(product_states(s) and closed_loop(h
      ) and (ord(h)-1 ne 8) ),
1183                                   Cst_new(s)*(ClosedLoopShip_sales(run,s,h)
       ));
1184  *         sales_profit(run)=sum( (s,h)$(product_states(s) and closed_loop(
      h) and (ord(h)-1 ne %Closed_Loop_Upper_delta%) ),Cst_new(s)*ClosedLoopShip
      _sales(run,s,h));
1185           Cost_EndInventory(run)=sum((s,h)$(product_states(s) and ord(h)-1 
      eq 8),Cst_new(s)*ClosedLoopINV(run,s,h));
1186  *         runcost_W(run)=0;
1187  *         runprofit(run)=sum((s,h)$(product_states(s) and closed_loop(h)),
      Cst_new(s)*ClosedLoopShip(run,s,h))+runcost_W(run);
1188  *Runprofit includes subtraction of BO even at last point because BO are wr
      itten like inventory
1189  *BO at 168 means just before 168th point. Ship at 168 means at 168 not bef
      ore or after.
1190  *Our runprofit is only for 167 points of closed loop and 168th point as co
      rrection. So we are essentially wasting the last decision
1191  *that is the open loop that was computed at 168.
1192           runprofit(run)=sales_profit(run)+Cost_EndInventory(run)
1193                           -(runcost_W(run)-sum((h)$(ord(h)-1 eq 8),ClosedLo
      opStart(run,h)))
1194                           -runcost_BO(run);
1195   
1196  *         runprofit(run)=runcost_Inv(run)-runcost_BO(run)
1197  *                        +1E1*sum((s,h)$(product_states(s) and closed_loop
      (h)),Cst_new(s)*ClosedLoopShip(run,s,h));
1198   
1199  *Does not include cost of Terminal BO and inventory but thats okay because
       they are irrelevant when some extra horizon is allowed for getting comple
      te closed loop rolling horizon solution
1200  ************[Start]Information to get very crude estimate for running time
       left**************
1201  timeLeft=MIN_COST.etSolve*(card(run)-ord(run))*card(calc);
      put screen;
      put 'Time for run ' P1.etSolve;
      put ' Estimated Time Left ' timeLeft;
      putclose;
1208  *************[End]Information to get very crude estimate for running time 
      left***************
1209   
      *************Stopping Criterion**************
      N_run=ord(run);
      mean_runcost(run)=sum(run_p$(ord(run_p) le N_run),runcost(run_p))/N_run;
      std_dev_runcost(run)$(ord(run) gt 1)= sqrt(       sum(run_p$(ord(run_p) le
       N_run),     ( abs(  runcost(run_p)-mean_runcost(run) )**2)) /(N_run-1)   
       );
      delta_std_dev_runcost(run)$(ord(run) gt 2)=std_dev_runcost(run)/std_dev_ru
      ncost(run-1)  - 1;
      max_delta_std_dev_runcost(run)= sqrt( 1 + (1.96**2-1)/N_run ) -1;
      *icdfnorm(0.95,0,1);
      *************Stopping Criterion**************
1220  );
1221  ********************[End] runs loop **************************************
      *
1222   
1223  *******************GANTT CHART PARAMETERS*********************************
      ****
1224  PARAMETERS BS(i,j,h),start(i,j,h),Sinv(s,h),end(i,j,h),BO(s,h);
1225  IF (0 eq 0,
1226           loop((run,calc)$(ord(run) eq 1),
1227             BS(i,j,h)$(ord(h) eq ord(calc))=sum((hbar,n)$(ord(hbar)-1 eq 0 
      and ord(n)-1 eq 0),record_states(run,calc,'B',i,j,n,hbar));
1228  *start(i,j,h)$(ord(h)eq ord(calc))=round(sum((hbar,n)$(ord(hbar)-1 eq 0 an
      d ord(n)-1 eq 0),record_states(calc,'W',i,j,n,hbar)));
1229             start(i,j,h)$(ord(h)eq ord(calc))=sum((hbar,n)$(ord(hbar)-1 eq 
      0 and ord(n)-1 eq 0),record_states(run,calc,'W',i,j,n,hbar));
1230             Sinv(s,h)$(ord(h) eq ord(calc))=sum(n$(ord(n)-1 eq 0),record_in
      ventory(run,calc,s,n));
1231             BO(s,h)$(ord(h) eq ord(calc))=sum(n$(ord(n)-1 eq 0),record_back
      log(run,calc,s,n));
1232           );
1233  ELSE
1234  *Write OPEN loop static gantt chart %GanttChart_OPENLOOP% eq 1
1235           loop((run,calc)$(ord(run) eq 1 and ord(calc) eq 1),
1236             BS(i,j,h)$(Ij(i,j))=sum((hbar,n)$(ord(hbar)-1 eq 0 and (ord(n) 
      eq ord(h))),record_states(run,calc,'B',i,j,n,hbar));
1237             start(i,j,h)$(Ij(i,j))=sum((hbar,n)$(ord(hbar)-1 eq 0 and (ord(
      n) eq ord(h))),record_states(run,calc,'W',i,j,n,hbar));
1238             Sinv(s,h)=sum(n$(ord(n) eq ord(h)),record_inventory(run,calc,s,
      n));
1239             BO(s,h)=sum(n$(ord(n) eq ord(h)),record_backlog(run,calc,s,n));
1240           );
1241  );
1242  *Have ending account for task delays
1243  end(i,j,h) = start(i,j,h-pi_new(i))$(BS(i,j,h-pi_new(i))>0);
1244  *******************GANTT CHART PARAMETERS*********************************
      ****
1245   
1246  *******************EXPORT ALL RESULTS IN GDX FILE*************************
      ****
1247  SUCCESS=1;
1248  EXECUTE_UNLOAD 'Z_N2_MH12_RF1_OPT1_DF4_DV1_DL25_DU1_S1_MC1_Cost.gdx';
1249  *******************EXPORT ALL RESULTS IN GDX FILE*************************
      ****
1250   
1251  *********Generate EXCEL SHEEL FOR GANTT CHARTING (Requires windows)*******
      ****
1252  if(0 eq 1,
1253  ************************************************
1254  ********Closed-Loop GanttChartGeneration********
1255  ************************************************
1256  *Name of the excel file where the data will be exported
1257  *$setglobal file %Results_FileName%_Gantt
1258  *i = set of tasks
1259  *j = set of units
1260  *h = set of time points
1261  *BS = batch size of task i starting in unit j at time t (must be indexed i
      jt)
1262  *start = binary variable that is 1 if task i starts in unit j at time t (m
      ust be indexed ijt)
1263  *Sinv = inventory level of material s at time t (must be indexed st)
1264  *BO= backorder of state s at time t
1265  *end =  binary variable that is 1 if task i ends in unit j at time t (must
       be indexed ijt)
1266   
1267  *EXECUTE_UNLOAD '%Results_FileName%_Gantt.gdx' BS i j h  Sinv start end;
1268   
1269  *The first word of each line gives the type: set = set, var = variable, pa
      r = parameter. This may need to be changed depending on your model
1270  *The location of the output or the sheet names must not be changed
1280   
1281  *display BS,start,end,Sinv,BO;
1282  EXECUTE 'gdxxrw Input=Z_N2_MH12_RF1_OPT1_DF4_DV1_DL25_DU1_S1_MC1_Cost.gdx 
      Output=Z_N2_MH12_RF1_OPT1_DF4_DV1_DL25_DU1_S1_MC1_Cost_Gantt @GANTT_write.
      txt'
1283  );
1284  *********Generate EXCEL SHEEL FOR GANTT CHARTING (Requires windows)*******
      ****
1285   
1286  *END OF MASTER FILE
1287   
1288   
1289   
1290   
1291   
1292   
1293  *Watch out for overflow of solution for rolling horizon...ie the spilling 
      over of
1294  *rolling horizon beyond real horizon to get last implemented closed loop s
      olution
1295   
1296   
1297  *$set console
1298  *$if %system.filesys% == UNIX  $set console /dev/tty
1299  *$if %system.filesys% == DOS $set console con
1300  *$if %system.filesys% == MS95  $set console con
1301  *$if %system.filesys% == MSNT  $set console con
1302  *$if "%console%." == "." abort "filesys not recognized";
1303  *file screen / '%console%' /;
1304  *file log /''/
1305   
1306   
1307   
1308   
1309   
1310   
1311   
1312   
GAMS 24.5.6  r55090 Released Nov 27, 2015 WEX-WEI x86 64bit/MS Windows 04/10/16 14:27:53 Page 5
State_Space_Model
Include File Summary


   SEQ   GLOBAL TYPE      PARENT   LOCAL  FILENAME

     1        1 INPUT          0       0  C:\Users\dhruv\Box Sync\Work\Codes\GAM
                                          S_Code_Paper1\Z_N2_MH12_RF1_OPT1_DF4_D
                                          V1_DL2.5_DU1_S1_MC1_Cost.gms
     2       20 INCLUDE        1      20  .C:\Users\dhruv\Box Sync\Work\Codes\GA
                                           MS_Code_Paper1\ConfigurationFile.gms
     3       89 INCLUDE        2      69  ..C:\Users\dhruv\Box Sync\Work\Codes\G
                                            AMS_Code_Paper1\MasterFile.gms
     4      106 INCLUDE        3      17  ...C:\Users\dhruv\Box Sync\Work\Codes\
                                             GAMS_Code_Paper1\NetworkN2.gms
     5      214 INCLUDE        3      18  ...C:\Users\dhruv\Box Sync\Work\Codes\
                                             GAMS_Code_Paper1\Model9.gms
     6      868 INCLUDE        3     149  ...C:\Users\dhruv\Box Sync\Work\Codes\
                                             GAMS_Code_Paper1\ModelSolution9.gms


COMPILATION TIME     =        0.016 SECONDS      3 MB  24.5.6 r55090 WEX-WEI
GAMS 24.5.6  r55090 Released Nov 27, 2015 WEX-WEI x86 64bit/MS Windows 04/10/16 14:27:53 Page 6
State_Space_Model
Model Statistics    SOLVE MIN_COST Using MIP From line 1066


LOOPS                                  run   run1
                                      calc   calc0


MODEL STATISTICS

BLOCKS OF EQUATIONS          13     SINGLE EQUATIONS          256
BLOCKS OF VARIABLES          10     SINGLE VARIABLES          265
NON ZERO ELEMENTS           722     DISCRETE VARIABLES         93


GENERATION TIME      =        0.047 SECONDS      4 MB  24.5.6 r55090 WEX-WEI


EXECUTION TIME       =        0.109 SECONDS      4 MB  24.5.6 r55090 WEX-WEI
               L O O P S                run run1
                                       calc calc0

GAMS 24.5.6  r55090 Released Nov 27, 2015 WEX-WEI x86 64bit/MS Windows 04/10/16 14:27:53 Page 7
State_Space_Model
Solution Report     SOLVE MIN_COST Using MIP From line 1066


               S O L V E      S U M M A R Y

     MODEL   MIN_COST            OBJECTIVE  obj_variable
     TYPE    MIP                 DIRECTION  MINIMIZE
     SOLVER  CPLEX               FROM LINE  1066

**** SOLVER STATUS     1 Normal Completion         
**** MODEL STATUS      1 Optimal                   
**** OBJECTIVE VALUE             9253.0000

 RESOURCE USAGE, LIMIT          0.078       600.000
 ITERATION COUNT, LIMIT        53    2000000000

IBM ILOG CPLEX   24.5.6 r55090 Released Nov 27, 2015 WEI x86 64bit/MS Windows 
--- GAMS/Cplex licensed for continuous and discrete problems.
Cplex 12.6.2.0

Space for names approximately 0.01 Mb
Use option 'names no' to turn use of names off
MIP status(101): integer optimal solution
Cplex Time: 0.08sec (det. 2.21 ticks)
Fixing integer variables, and solving final LP...
Fixed MIP status(1): optimal
Cplex Time: 0.00sec (det. 0.21 ticks)
Proven optimal solution.

MIP Solution:         9253.000000    (51 iterations, 0 nodes)
Final Solve:          9253.000000    (2 iterations)

Best possible:        9253.000000
Absolute gap:            0.000000
Relative gap:            0.000000



**** REPORT SUMMARY :        0     NONOPT
                             0 INFEASIBLE
                             0  UNBOUNDED
GAMS 24.5.6  r55090 Released Nov 27, 2015 WEX-WEI x86 64bit/MS Windows 04/10/16 14:27:53 Page 8
State_Space_Model
Model Statistics    SOLVE MIN_COST Using RMIP From line 1139


LOOPS                                  run   run1
                                      calc   calc0


MODEL STATISTICS

BLOCKS OF EQUATIONS          13     SINGLE EQUATIONS          256
BLOCKS OF VARIABLES          10     SINGLE VARIABLES          265
NON ZERO ELEMENTS           722     DISCRETE VARIABLES         93


GENERATION TIME      =        0.031 SECONDS      3 MB  24.5.6 r55090 WEX-WEI


EXECUTION TIME       =        0.031 SECONDS      3 MB  24.5.6 r55090 WEX-WEI
               L O O P S                run run1
                                       calc calc0

GAMS 24.5.6  r55090 Released Nov 27, 2015 WEX-WEI x86 64bit/MS Windows 04/10/16 14:27:53 Page 9
State_Space_Model
Solution Report     SOLVE MIN_COST Using RMIP From line 1139


               S O L V E      S U M M A R Y

     MODEL   MIN_COST            OBJECTIVE  obj_variable
     TYPE    RMIP                DIRECTION  MINIMIZE
     SOLVER  CPLEX               FROM LINE  1139

**** SOLVER STATUS     1 Normal Completion         
**** MODEL STATUS      1 Optimal                   
**** OBJECTIVE VALUE             2501.5000

 RESOURCE USAGE, LIMIT          0.032       600.000
 ITERATION COUNT, LIMIT        40    2000000000

IBM ILOG CPLEX   24.5.6 r55090 Released Nov 27, 2015 WEI x86 64bit/MS Windows 
Cplex 12.6.2.0

Space for names approximately 0.01 Mb
Use option 'names no' to turn use of names off
LP status(1): optimal
Cplex Time: 0.02sec (det. 0.54 ticks)
Optimal solution found.
Objective :        2501.500000



**** REPORT SUMMARY :        0     NONOPT
                             0 INFEASIBLE
                             0  UNBOUNDED
GAMS 24.5.6  r55090 Released Nov 27, 2015 WEX-WEI x86 64bit/MS Windows 04/10/16 14:27:53 Page 10
State_Space_Model
Model Statistics    SOLVE MIN_COST Using MIP From line 1066


LOOPS                                  run   run1
                                      calc   calc1


MODEL STATISTICS

BLOCKS OF EQUATIONS          13     SINGLE EQUATIONS          256
BLOCKS OF VARIABLES          10     SINGLE VARIABLES          265
NON ZERO ELEMENTS           722     DISCRETE VARIABLES         93


GENERATION TIME      =        0.016 SECONDS      3 MB  24.5.6 r55090 WEX-WEI


EXECUTION TIME       =        0.016 SECONDS      3 MB  24.5.6 r55090 WEX-WEI
               L O O P S                run run1
                                       calc calc1

GAMS 24.5.6  r55090 Released Nov 27, 2015 WEX-WEI x86 64bit/MS Windows 04/10/16 14:27:53 Page 11
State_Space_Model
Solution Report     SOLVE MIN_COST Using MIP From line 1066


               S O L V E      S U M M A R Y

     MODEL   MIN_COST            OBJECTIVE  obj_variable
     TYPE    MIP                 DIRECTION  MINIMIZE
     SOLVER  CPLEX               FROM LINE  1066

**** SOLVER STATUS     1 Normal Completion         
**** MODEL STATUS      1 Optimal                   
**** OBJECTIVE VALUE             9252.0000

 RESOURCE USAGE, LIMIT          0.046       600.000
 ITERATION COUNT, LIMIT        52    2000000000

IBM ILOG CPLEX   24.5.6 r55090 Released Nov 27, 2015 WEI x86 64bit/MS Windows 
--- GAMS/Cplex licensed for continuous and discrete problems.
Cplex 12.6.2.0

Space for names approximately 0.01 Mb
Use option 'names no' to turn use of names off
MIP status(101): integer optimal solution
Cplex Time: 0.05sec (det. 2.31 ticks)
Fixing integer variables, and solving final LP...
Fixed MIP status(1): optimal
Cplex Time: 0.00sec (det. 0.21 ticks)
Proven optimal solution.

MIP Solution:         9252.000000    (50 iterations, 0 nodes)
Final Solve:          9252.000000    (2 iterations)

Best possible:        9252.000000
Absolute gap:            0.000000
Relative gap:            0.000000



**** REPORT SUMMARY :        0     NONOPT
                             0 INFEASIBLE
                             0  UNBOUNDED
GAMS 24.5.6  r55090 Released Nov 27, 2015 WEX-WEI x86 64bit/MS Windows 04/10/16 14:27:53 Page 12
State_Space_Model
Model Statistics    SOLVE MIN_COST Using RMIP From line 1139


LOOPS                                  run   run1
                                      calc   calc1


MODEL STATISTICS

BLOCKS OF EQUATIONS          13     SINGLE EQUATIONS          256
BLOCKS OF VARIABLES          10     SINGLE VARIABLES          265
NON ZERO ELEMENTS           722     DISCRETE VARIABLES         93


GENERATION TIME      =        0.016 SECONDS      3 MB  24.5.6 r55090 WEX-WEI


EXECUTION TIME       =        0.016 SECONDS      3 MB  24.5.6 r55090 WEX-WEI
               L O O P S                run run1
                                       calc calc1

GAMS 24.5.6  r55090 Released Nov 27, 2015 WEX-WEI x86 64bit/MS Windows 04/10/16 14:27:53 Page 13
State_Space_Model
Solution Report     SOLVE MIN_COST Using RMIP From line 1139


               S O L V E      S U M M A R Y

     MODEL   MIN_COST            OBJECTIVE  obj_variable
     TYPE    RMIP                DIRECTION  MINIMIZE
     SOLVER  CPLEX               FROM LINE  1139

**** SOLVER STATUS     1 Normal Completion         
**** MODEL STATUS      1 Optimal                   
**** OBJECTIVE VALUE             3376.0000

 RESOURCE USAGE, LIMIT          0.016       600.000
 ITERATION COUNT, LIMIT        44    2000000000

IBM ILOG CPLEX   24.5.6 r55090 Released Nov 27, 2015 WEI x86 64bit/MS Windows 
Cplex 12.6.2.0

Space for names approximately 0.01 Mb
Use option 'names no' to turn use of names off
LP status(1): optimal
Cplex Time: 0.02sec (det. 0.56 ticks)
Optimal solution found.
Objective :        3376.000000



**** REPORT SUMMARY :        0     NONOPT
                             0 INFEASIBLE
                             0  UNBOUNDED
GAMS 24.5.6  r55090 Released Nov 27, 2015 WEX-WEI x86 64bit/MS Windows 04/10/16 14:27:53 Page 14
State_Space_Model
Model Statistics    SOLVE MIN_COST Using MIP From line 1066


LOOPS                                  run   run1
                                      calc   calc2


MODEL STATISTICS

BLOCKS OF EQUATIONS          13     SINGLE EQUATIONS          256
BLOCKS OF VARIABLES          10     SINGLE VARIABLES          265
NON ZERO ELEMENTS           722     DISCRETE VARIABLES         93


GENERATION TIME      =        0.015 SECONDS      3 MB  24.5.6 r55090 WEX-WEI


EXECUTION TIME       =        0.031 SECONDS      3 MB  24.5.6 r55090 WEX-WEI
               L O O P S                run run1
                                       calc calc2

GAMS 24.5.6  r55090 Released Nov 27, 2015 WEX-WEI x86 64bit/MS Windows 04/10/16 14:27:53 Page 15
State_Space_Model
Solution Report     SOLVE MIN_COST Using MIP From line 1066


               S O L V E      S U M M A R Y

     MODEL   MIN_COST            OBJECTIVE  obj_variable
     TYPE    MIP                 DIRECTION  MINIMIZE
     SOLVER  CPLEX               FROM LINE  1066

**** SOLVER STATUS     1 Normal Completion         
**** MODEL STATUS      1 Optimal                   
**** OBJECTIVE VALUE             9252.0000

 RESOURCE USAGE, LIMIT          0.078       600.000
 ITERATION COUNT, LIMIT        54    2000000000

IBM ILOG CPLEX   24.5.6 r55090 Released Nov 27, 2015 WEI x86 64bit/MS Windows 
--- GAMS/Cplex licensed for continuous and discrete problems.
Cplex 12.6.2.0

Space for names approximately 0.01 Mb
Use option 'names no' to turn use of names off
MIP status(101): integer optimal solution
Cplex Time: 0.06sec (det. 2.61 ticks)
Fixing integer variables, and solving final LP...
Fixed MIP status(1): optimal
Cplex Time: 0.02sec (det. 0.21 ticks)
Proven optimal solution.

MIP Solution:         9252.000000    (52 iterations, 0 nodes)
Final Solve:          9252.000000    (2 iterations)

Best possible:        9252.000000
Absolute gap:            0.000000
Relative gap:            0.000000



**** REPORT SUMMARY :        0     NONOPT
                             0 INFEASIBLE
                             0  UNBOUNDED
GAMS 24.5.6  r55090 Released Nov 27, 2015 WEX-WEI x86 64bit/MS Windows 04/10/16 14:27:53 Page 16
State_Space_Model
Model Statistics    SOLVE MIN_COST Using RMIP From line 1139


LOOPS                                  run   run1
                                      calc   calc2


MODEL STATISTICS

BLOCKS OF EQUATIONS          13     SINGLE EQUATIONS          256
BLOCKS OF VARIABLES          10     SINGLE VARIABLES          265
NON ZERO ELEMENTS           722     DISCRETE VARIABLES         93


GENERATION TIME      =        0.031 SECONDS      3 MB  24.5.6 r55090 WEX-WEI


EXECUTION TIME       =        0.031 SECONDS      3 MB  24.5.6 r55090 WEX-WEI
               L O O P S                run run1
                                       calc calc2

GAMS 24.5.6  r55090 Released Nov 27, 2015 WEX-WEI x86 64bit/MS Windows 04/10/16 14:27:53 Page 17
State_Space_Model
Solution Report     SOLVE MIN_COST Using RMIP From line 1139


               S O L V E      S U M M A R Y

     MODEL   MIN_COST            OBJECTIVE  obj_variable
     TYPE    RMIP                DIRECTION  MINIMIZE
     SOLVER  CPLEX               FROM LINE  1139

**** SOLVER STATUS     1 Normal Completion         
**** MODEL STATUS      1 Optimal                   
**** OBJECTIVE VALUE             3376.0000

 RESOURCE USAGE, LIMIT          0.016       600.000
 ITERATION COUNT, LIMIT        51    2000000000

IBM ILOG CPLEX   24.5.6 r55090 Released Nov 27, 2015 WEI x86 64bit/MS Windows 
Cplex 12.6.2.0

Space for names approximately 0.01 Mb
Use option 'names no' to turn use of names off
LP status(1): optimal
Cplex Time: 0.02sec (det. 0.60 ticks)
Optimal solution found.
Objective :        3376.000000



**** REPORT SUMMARY :        0     NONOPT
                             0 INFEASIBLE
                             0  UNBOUNDED
GAMS 24.5.6  r55090 Released Nov 27, 2015 WEX-WEI x86 64bit/MS Windows 04/10/16 14:27:53 Page 18
State_Space_Model
Model Statistics    SOLVE MIN_COST Using MIP From line 1066


LOOPS                                  run   run1
                                      calc   calc3


MODEL STATISTICS

BLOCKS OF EQUATIONS          13     SINGLE EQUATIONS          256
BLOCKS OF VARIABLES          10     SINGLE VARIABLES          265
NON ZERO ELEMENTS           722     DISCRETE VARIABLES         93


GENERATION TIME      =        0.016 SECONDS      3 MB  24.5.6 r55090 WEX-WEI


EXECUTION TIME       =        0.016 SECONDS      3 MB  24.5.6 r55090 WEX-WEI
               L O O P S                run run1
                                       calc calc3

GAMS 24.5.6  r55090 Released Nov 27, 2015 WEX-WEI x86 64bit/MS Windows 04/10/16 14:27:53 Page 19
State_Space_Model
Solution Report     SOLVE MIN_COST Using MIP From line 1066


               S O L V E      S U M M A R Y

     MODEL   MIN_COST            OBJECTIVE  obj_variable
     TYPE    MIP                 DIRECTION  MINIMIZE
     SOLVER  CPLEX               FROM LINE  1066

**** SOLVER STATUS     1 Normal Completion         
**** MODEL STATUS      1 Optimal                   
**** OBJECTIVE VALUE             9251.0000

 RESOURCE USAGE, LIMIT          0.062       600.000
 ITERATION COUNT, LIMIT         9    2000000000

IBM ILOG CPLEX   24.5.6 r55090 Released Nov 27, 2015 WEI x86 64bit/MS Windows 
--- GAMS/Cplex licensed for continuous and discrete problems.
Cplex 12.6.2.0

Space for names approximately 0.01 Mb
Use option 'names no' to turn use of names off
MIP status(101): integer optimal solution
Cplex Time: 0.06sec (det. 1.45 ticks)
Fixing integer variables, and solving final LP...
Fixed MIP status(1): optimal
Cplex Time: 0.00sec (det. 0.21 ticks)
Proven optimal solution.

MIP Solution:         9251.000000    (7 iterations, 0 nodes)
Final Solve:          9251.000000    (2 iterations)

Best possible:        9251.000000
Absolute gap:            0.000000
Relative gap:            0.000000



**** REPORT SUMMARY :        0     NONOPT
                             0 INFEASIBLE
                             0  UNBOUNDED
GAMS 24.5.6  r55090 Released Nov 27, 2015 WEX-WEI x86 64bit/MS Windows 04/10/16 14:27:53 Page 20
State_Space_Model
Model Statistics    SOLVE MIN_COST Using RMIP From line 1139


LOOPS                                  run   run1
                                      calc   calc3


MODEL STATISTICS

BLOCKS OF EQUATIONS          13     SINGLE EQUATIONS          256
BLOCKS OF VARIABLES          10     SINGLE VARIABLES          265
NON ZERO ELEMENTS           722     DISCRETE VARIABLES         93


GENERATION TIME      =        0.031 SECONDS      3 MB  24.5.6 r55090 WEX-WEI


EXECUTION TIME       =        0.031 SECONDS      3 MB  24.5.6 r55090 WEX-WEI
               L O O P S                run run1
                                       calc calc3

GAMS 24.5.6  r55090 Released Nov 27, 2015 WEX-WEI x86 64bit/MS Windows 04/10/16 14:27:53 Page 21
State_Space_Model
Solution Report     SOLVE MIN_COST Using RMIP From line 1139


               S O L V E      S U M M A R Y

     MODEL   MIN_COST            OBJECTIVE  obj_variable
     TYPE    RMIP                DIRECTION  MINIMIZE
     SOLVER  CPLEX               FROM LINE  1139

**** SOLVER STATUS     1 Normal Completion         
**** MODEL STATUS      1 Optimal                   
**** OBJECTIVE VALUE             9125.5000

 RESOURCE USAGE, LIMIT          0.000       600.000
 ITERATION COUNT, LIMIT        41    2000000000

IBM ILOG CPLEX   24.5.6 r55090 Released Nov 27, 2015 WEI x86 64bit/MS Windows 
Cplex 12.6.2.0

Space for names approximately 0.01 Mb
Use option 'names no' to turn use of names off
LP status(1): optimal
Cplex Time: 0.00sec (det. 0.56 ticks)
Optimal solution found.
Objective :        9125.500000



**** REPORT SUMMARY :        0     NONOPT
                             0 INFEASIBLE
                             0  UNBOUNDED
GAMS 24.5.6  r55090 Released Nov 27, 2015 WEX-WEI x86 64bit/MS Windows 04/10/16 14:27:53 Page 22
State_Space_Model
Model Statistics    SOLVE MIN_COST Using MIP From line 1066


LOOPS                                  run   run1
                                      calc   calc4


MODEL STATISTICS

BLOCKS OF EQUATIONS          13     SINGLE EQUATIONS          256
BLOCKS OF VARIABLES          10     SINGLE VARIABLES          265
NON ZERO ELEMENTS           722     DISCRETE VARIABLES         93


GENERATION TIME      =        0.031 SECONDS      3 MB  24.5.6 r55090 WEX-WEI


EXECUTION TIME       =        0.031 SECONDS      3 MB  24.5.6 r55090 WEX-WEI
               L O O P S                run run1
                                       calc calc4

GAMS 24.5.6  r55090 Released Nov 27, 2015 WEX-WEI x86 64bit/MS Windows 04/10/16 14:27:53 Page 23
State_Space_Model
Solution Report     SOLVE MIN_COST Using MIP From line 1066


               S O L V E      S U M M A R Y

     MODEL   MIN_COST            OBJECTIVE  obj_variable
     TYPE    MIP                 DIRECTION  MINIMIZE
     SOLVER  CPLEX               FROM LINE  1066

**** SOLVER STATUS     1 Normal Completion         
**** MODEL STATUS      1 Optimal                   
**** OBJECTIVE VALUE            11254.0000

 RESOURCE USAGE, LIMIT          0.078       600.000
 ITERATION COUNT, LIMIT        86    2000000000

IBM ILOG CPLEX   24.5.6 r55090 Released Nov 27, 2015 WEI x86 64bit/MS Windows 
--- GAMS/Cplex licensed for continuous and discrete problems.
Cplex 12.6.2.0

Space for names approximately 0.01 Mb
Use option 'names no' to turn use of names off
MIP status(101): integer optimal solution
Cplex Time: 0.05sec (det. 4.46 ticks)
Fixing integer variables, and solving final LP...
Fixed MIP status(1): optimal
Cplex Time: 0.00sec (det. 0.22 ticks)
Proven optimal solution.

MIP Solution:        11254.000000    (81 iterations, 5 nodes)
Final Solve:         11254.000000    (5 iterations)

Best possible:       11254.000000
Absolute gap:            0.000000
Relative gap:            0.000000



**** REPORT SUMMARY :        0     NONOPT
                             0 INFEASIBLE
                             0  UNBOUNDED
GAMS 24.5.6  r55090 Released Nov 27, 2015 WEX-WEI x86 64bit/MS Windows 04/10/16 14:27:53 Page 24
State_Space_Model
Model Statistics    SOLVE MIN_COST Using RMIP From line 1139


LOOPS                                  run   run1
                                      calc   calc4


MODEL STATISTICS

BLOCKS OF EQUATIONS          13     SINGLE EQUATIONS          256
BLOCKS OF VARIABLES          10     SINGLE VARIABLES          265
NON ZERO ELEMENTS           722     DISCRETE VARIABLES         93


GENERATION TIME      =        0.140 SECONDS      3 MB  24.5.6 r55090 WEX-WEI


EXECUTION TIME       =        0.140 SECONDS      3 MB  24.5.6 r55090 WEX-WEI
               L O O P S                run run1
                                       calc calc4

GAMS 24.5.6  r55090 Released Nov 27, 2015 WEX-WEI x86 64bit/MS Windows 04/10/16 14:27:53 Page 25
State_Space_Model
Solution Report     SOLVE MIN_COST Using RMIP From line 1139


               S O L V E      S U M M A R Y

     MODEL   MIN_COST            OBJECTIVE  obj_variable
     TYPE    RMIP                DIRECTION  MINIMIZE
     SOLVER  CPLEX               FROM LINE  1139

**** SOLVER STATUS     1 Normal Completion         
**** MODEL STATUS      1 Optimal                   
**** OBJECTIVE VALUE             8876.2500

 RESOURCE USAGE, LIMIT          0.015       600.000
 ITERATION COUNT, LIMIT        50    2000000000

IBM ILOG CPLEX   24.5.6 r55090 Released Nov 27, 2015 WEI x86 64bit/MS Windows 
Cplex 12.6.2.0

Space for names approximately 0.01 Mb
Use option 'names no' to turn use of names off
LP status(1): optimal
Cplex Time: 0.00sec (det. 0.59 ticks)
Optimal solution found.
Objective :        8876.250000



**** REPORT SUMMARY :        0     NONOPT
                             0 INFEASIBLE
                             0  UNBOUNDED
GAMS 24.5.6  r55090 Released Nov 27, 2015 WEX-WEI x86 64bit/MS Windows 04/10/16 14:27:53 Page 26
State_Space_Model
Model Statistics    SOLVE MIN_COST Using MIP From line 1066


LOOPS                                  run   run1
                                      calc   calc5


MODEL STATISTICS

BLOCKS OF EQUATIONS          13     SINGLE EQUATIONS          256
BLOCKS OF VARIABLES          10     SINGLE VARIABLES          265
NON ZERO ELEMENTS           722     DISCRETE VARIABLES         93


GENERATION TIME      =        0.016 SECONDS      3 MB  24.5.6 r55090 WEX-WEI


EXECUTION TIME       =        0.031 SECONDS      3 MB  24.5.6 r55090 WEX-WEI
               L O O P S                run run1
                                       calc calc5

GAMS 24.5.6  r55090 Released Nov 27, 2015 WEX-WEI x86 64bit/MS Windows 04/10/16 14:27:53 Page 27
State_Space_Model
Solution Report     SOLVE MIN_COST Using MIP From line 1066


               S O L V E      S U M M A R Y

     MODEL   MIN_COST            OBJECTIVE  obj_variable
     TYPE    MIP                 DIRECTION  MINIMIZE
     SOLVER  CPLEX               FROM LINE  1066

**** SOLVER STATUS     1 Normal Completion         
**** MODEL STATUS      1 Optimal                   
**** OBJECTIVE VALUE            11503.0000

 RESOURCE USAGE, LIMIT          0.109       600.000
 ITERATION COUNT, LIMIT        72    2000000000

IBM ILOG CPLEX   24.5.6 r55090 Released Nov 27, 2015 WEI x86 64bit/MS Windows 
--- GAMS/Cplex licensed for continuous and discrete problems.
Cplex 12.6.2.0

Space for names approximately 0.01 Mb
Use option 'names no' to turn use of names off
MIP status(101): integer optimal solution
Cplex Time: 0.11sec (det. 3.45 ticks)
Fixing integer variables, and solving final LP...
Fixed MIP status(1): optimal
Cplex Time: 0.00sec (det. 0.22 ticks)
Proven optimal solution.

MIP Solution:        11503.000000    (68 iterations, 0 nodes)
Final Solve:         11503.000000    (4 iterations)

Best possible:       11503.000000
Absolute gap:            0.000000
Relative gap:            0.000000



**** REPORT SUMMARY :        0     NONOPT
                             0 INFEASIBLE
                             0  UNBOUNDED
GAMS 24.5.6  r55090 Released Nov 27, 2015 WEX-WEI x86 64bit/MS Windows 04/10/16 14:27:53 Page 28
State_Space_Model
Model Statistics    SOLVE MIN_COST Using RMIP From line 1139


LOOPS                                  run   run1
                                      calc   calc5


MODEL STATISTICS

BLOCKS OF EQUATIONS          13     SINGLE EQUATIONS          256
BLOCKS OF VARIABLES          10     SINGLE VARIABLES          265
NON ZERO ELEMENTS           722     DISCRETE VARIABLES         93


GENERATION TIME      =        0.015 SECONDS      3 MB  24.5.6 r55090 WEX-WEI


EXECUTION TIME       =        0.031 SECONDS      3 MB  24.5.6 r55090 WEX-WEI
               L O O P S                run run1
                                       calc calc5

GAMS 24.5.6  r55090 Released Nov 27, 2015 WEX-WEI x86 64bit/MS Windows 04/10/16 14:27:53 Page 29
State_Space_Model
Solution Report     SOLVE MIN_COST Using RMIP From line 1139


               S O L V E      S U M M A R Y

     MODEL   MIN_COST            OBJECTIVE  obj_variable
     TYPE    RMIP                DIRECTION  MINIMIZE
     SOLVER  CPLEX               FROM LINE  1139

**** SOLVER STATUS     1 Normal Completion         
**** MODEL STATUS      1 Optimal                   
**** OBJECTIVE VALUE             8750.7500

 RESOURCE USAGE, LIMIT          0.016       600.000
 ITERATION COUNT, LIMIT        40    2000000000

IBM ILOG CPLEX   24.5.6 r55090 Released Nov 27, 2015 WEI x86 64bit/MS Windows 
Cplex 12.6.2.0

Space for names approximately 0.01 Mb
Use option 'names no' to turn use of names off
LP status(1): optimal
Cplex Time: 0.02sec (det. 0.54 ticks)
Optimal solution found.
Objective :        8750.750000



**** REPORT SUMMARY :        0     NONOPT
                             0 INFEASIBLE
                             0  UNBOUNDED
GAMS 24.5.6  r55090 Released Nov 27, 2015 WEX-WEI x86 64bit/MS Windows 04/10/16 14:27:53 Page 30
State_Space_Model
Model Statistics    SOLVE MIN_COST Using MIP From line 1066


LOOPS                                  run   run1
                                      calc   calc6


MODEL STATISTICS

BLOCKS OF EQUATIONS          13     SINGLE EQUATIONS          256
BLOCKS OF VARIABLES          10     SINGLE VARIABLES          265
NON ZERO ELEMENTS           722     DISCRETE VARIABLES         93


GENERATION TIME      =        0.015 SECONDS      3 MB  24.5.6 r55090 WEX-WEI


EXECUTION TIME       =        0.031 SECONDS      3 MB  24.5.6 r55090 WEX-WEI
               L O O P S                run run1
                                       calc calc6

GAMS 24.5.6  r55090 Released Nov 27, 2015 WEX-WEI x86 64bit/MS Windows 04/10/16 14:27:53 Page 31
State_Space_Model
Solution Report     SOLVE MIN_COST Using MIP From line 1066


               S O L V E      S U M M A R Y

     MODEL   MIN_COST            OBJECTIVE  obj_variable
     TYPE    MIP                 DIRECTION  MINIMIZE
     SOLVER  CPLEX               FROM LINE  1066

**** SOLVER STATUS     1 Normal Completion         
**** MODEL STATUS      1 Optimal                   
**** OBJECTIVE VALUE             9252.0000

 RESOURCE USAGE, LIMIT          0.062       600.000
 ITERATION COUNT, LIMIT        65    2000000000

IBM ILOG CPLEX   24.5.6 r55090 Released Nov 27, 2015 WEI x86 64bit/MS Windows 
--- GAMS/Cplex licensed for continuous and discrete problems.
Cplex 12.6.2.0

Space for names approximately 0.01 Mb
Use option 'names no' to turn use of names off
MIP status(101): integer optimal solution
Cplex Time: 0.06sec (det. 2.76 ticks)
Fixing integer variables, and solving final LP...
Fixed MIP status(1): optimal
Cplex Time: 0.00sec (det. 0.22 ticks)
Proven optimal solution.

MIP Solution:         9252.000000    (61 iterations, 0 nodes)
Final Solve:          9252.000000    (4 iterations)

Best possible:        9252.000000
Absolute gap:            0.000000
Relative gap:            0.000000



**** REPORT SUMMARY :        0     NONOPT
                             0 INFEASIBLE
                             0  UNBOUNDED
GAMS 24.5.6  r55090 Released Nov 27, 2015 WEX-WEI x86 64bit/MS Windows 04/10/16 14:27:53 Page 32
State_Space_Model
Model Statistics    SOLVE MIN_COST Using RMIP From line 1139


LOOPS                                  run   run1
                                      calc   calc6


MODEL STATISTICS

BLOCKS OF EQUATIONS          13     SINGLE EQUATIONS          256
BLOCKS OF VARIABLES          10     SINGLE VARIABLES          265
NON ZERO ELEMENTS           722     DISCRETE VARIABLES         93


GENERATION TIME      =        0.015 SECONDS      3 MB  24.5.6 r55090 WEX-WEI


EXECUTION TIME       =        0.015 SECONDS      3 MB  24.5.6 r55090 WEX-WEI
               L O O P S                run run1
                                       calc calc6

GAMS 24.5.6  r55090 Released Nov 27, 2015 WEX-WEI x86 64bit/MS Windows 04/10/16 14:27:53 Page 33
State_Space_Model
Solution Report     SOLVE MIN_COST Using RMIP From line 1139


               S O L V E      S U M M A R Y

     MODEL   MIN_COST            OBJECTIVE  obj_variable
     TYPE    RMIP                DIRECTION  MINIMIZE
     SOLVER  CPLEX               FROM LINE  1139

**** SOLVER STATUS     1 Normal Completion         
**** MODEL STATUS      1 Optimal                   
**** OBJECTIVE VALUE             7876.0000

 RESOURCE USAGE, LIMIT          0.015       600.000
 ITERATION COUNT, LIMIT        45    2000000000

IBM ILOG CPLEX   24.5.6 r55090 Released Nov 27, 2015 WEI x86 64bit/MS Windows 
Cplex 12.6.2.0

Space for names approximately 0.01 Mb
Use option 'names no' to turn use of names off
LP status(1): optimal
Cplex Time: 0.00sec (det. 0.57 ticks)
Optimal solution found.
Objective :        7876.000000



**** REPORT SUMMARY :        0     NONOPT
                             0 INFEASIBLE
                             0  UNBOUNDED
GAMS 24.5.6  r55090 Released Nov 27, 2015 WEX-WEI x86 64bit/MS Windows 04/10/16 14:27:53 Page 34
State_Space_Model
Model Statistics    SOLVE MIN_COST Using MIP From line 1066


LOOPS                                  run   run1
                                      calc   calc7


MODEL STATISTICS

BLOCKS OF EQUATIONS          13     SINGLE EQUATIONS          256
BLOCKS OF VARIABLES          10     SINGLE VARIABLES          265
NON ZERO ELEMENTS           722     DISCRETE VARIABLES         93


GENERATION TIME      =        0.016 SECONDS      3 MB  24.5.6 r55090 WEX-WEI


EXECUTION TIME       =        0.031 SECONDS      3 MB  24.5.6 r55090 WEX-WEI
               L O O P S                run run1
                                       calc calc7

GAMS 24.5.6  r55090 Released Nov 27, 2015 WEX-WEI x86 64bit/MS Windows 04/10/16 14:27:53 Page 35
State_Space_Model
Solution Report     SOLVE MIN_COST Using MIP From line 1066


               S O L V E      S U M M A R Y

     MODEL   MIN_COST            OBJECTIVE  obj_variable
     TYPE    MIP                 DIRECTION  MINIMIZE
     SOLVER  CPLEX               FROM LINE  1066

**** SOLVER STATUS     1 Normal Completion         
**** MODEL STATUS      1 Optimal                   
**** OBJECTIVE VALUE             7002.0000

 RESOURCE USAGE, LIMIT          0.078       600.000
 ITERATION COUNT, LIMIT        71    2000000000

IBM ILOG CPLEX   24.5.6 r55090 Released Nov 27, 2015 WEI x86 64bit/MS Windows 
--- GAMS/Cplex licensed for continuous and discrete problems.
Cplex 12.6.2.0

Space for names approximately 0.01 Mb
Use option 'names no' to turn use of names off
MIP status(101): integer optimal solution
Cplex Time: 0.06sec (det. 3.12 ticks)
Fixing integer variables, and solving final LP...
Fixed MIP status(1): optimal
Cplex Time: 0.00sec (det. 0.22 ticks)
Proven optimal solution.

MIP Solution:         7002.000000    (67 iterations, 0 nodes)
Final Solve:          7002.000000    (4 iterations)

Best possible:        7002.000000
Absolute gap:            0.000000
Relative gap:            0.000000



**** REPORT SUMMARY :        0     NONOPT
                             0 INFEASIBLE
                             0  UNBOUNDED
GAMS 24.5.6  r55090 Released Nov 27, 2015 WEX-WEI x86 64bit/MS Windows 04/10/16 14:27:53 Page 36
State_Space_Model
Model Statistics    SOLVE MIN_COST Using RMIP From line 1139


LOOPS                                  run   run1
                                      calc   calc7


MODEL STATISTICS

BLOCKS OF EQUATIONS          13     SINGLE EQUATIONS          256
BLOCKS OF VARIABLES          10     SINGLE VARIABLES          265
NON ZERO ELEMENTS           722     DISCRETE VARIABLES         93


GENERATION TIME      =        0.016 SECONDS      3 MB  24.5.6 r55090 WEX-WEI


EXECUTION TIME       =        0.016 SECONDS      3 MB  24.5.6 r55090 WEX-WEI
               L O O P S                run run1
                                       calc calc7

GAMS 24.5.6  r55090 Released Nov 27, 2015 WEX-WEI x86 64bit/MS Windows 04/10/16 14:27:53 Page 37
State_Space_Model
Solution Report     SOLVE MIN_COST Using RMIP From line 1139


               S O L V E      S U M M A R Y

     MODEL   MIN_COST            OBJECTIVE  obj_variable
     TYPE    RMIP                DIRECTION  MINIMIZE
     SOLVER  CPLEX               FROM LINE  1139

**** SOLVER STATUS     1 Normal Completion         
**** MODEL STATUS      1 Optimal                   
**** OBJECTIVE VALUE             5376.0000

 RESOURCE USAGE, LIMIT          0.031       600.000
 ITERATION COUNT, LIMIT        50    2000000000

IBM ILOG CPLEX   24.5.6 r55090 Released Nov 27, 2015 WEI x86 64bit/MS Windows 
Cplex 12.6.2.0

Space for names approximately 0.01 Mb
Use option 'names no' to turn use of names off
LP status(1): optimal
Cplex Time: 0.03sec (det. 0.60 ticks)
Optimal solution found.
Objective :        5376.000000



**** REPORT SUMMARY :        0     NONOPT
                             0 INFEASIBLE
                             0  UNBOUNDED
GAMS 24.5.6  r55090 Released Nov 27, 2015 WEX-WEI x86 64bit/MS Windows 04/10/16 14:27:53 Page 38
State_Space_Model
Model Statistics    SOLVE MIN_COST Using MIP From line 1066


LOOPS                                  run   run1
                                      calc   calc8


MODEL STATISTICS

BLOCKS OF EQUATIONS          13     SINGLE EQUATIONS          256
BLOCKS OF VARIABLES          10     SINGLE VARIABLES          265
NON ZERO ELEMENTS           722     DISCRETE VARIABLES         93


GENERATION TIME      =        0.016 SECONDS      3 MB  24.5.6 r55090 WEX-WEI


EXECUTION TIME       =        0.032 SECONDS      3 MB  24.5.6 r55090 WEX-WEI
               L O O P S                run run1
                                       calc calc8

GAMS 24.5.6  r55090 Released Nov 27, 2015 WEX-WEI x86 64bit/MS Windows 04/10/16 14:27:53 Page 39
State_Space_Model
Solution Report     SOLVE MIN_COST Using MIP From line 1066


               S O L V E      S U M M A R Y

     MODEL   MIN_COST            OBJECTIVE  obj_variable
     TYPE    MIP                 DIRECTION  MINIMIZE
     SOLVER  CPLEX               FROM LINE  1066

**** SOLVER STATUS     1 Normal Completion         
**** MODEL STATUS      1 Optimal                   
**** OBJECTIVE VALUE             4251.0000

 RESOURCE USAGE, LIMIT          0.062       600.000
 ITERATION COUNT, LIMIT        23    2000000000

IBM ILOG CPLEX   24.5.6 r55090 Released Nov 27, 2015 WEI x86 64bit/MS Windows 
--- GAMS/Cplex licensed for continuous and discrete problems.
Cplex 12.6.2.0

Space for names approximately 0.01 Mb
Use option 'names no' to turn use of names off
MIP status(101): integer optimal solution
Cplex Time: 0.06sec (det. 1.54 ticks)
Fixing integer variables, and solving final LP...
Fixed MIP status(1): optimal
Cplex Time: 0.00sec (det. 0.22 ticks)
Proven optimal solution.

MIP Solution:         4251.000000    (20 iterations, 0 nodes)
Final Solve:          4251.000000    (3 iterations)

Best possible:        4251.000000
Absolute gap:            0.000000
Relative gap:            0.000000



**** REPORT SUMMARY :        0     NONOPT
                             0 INFEASIBLE
                             0  UNBOUNDED
GAMS 24.5.6  r55090 Released Nov 27, 2015 WEX-WEI x86 64bit/MS Windows 04/10/16 14:27:53 Page 40
State_Space_Model
Model Statistics    SOLVE MIN_COST Using RMIP From line 1139


LOOPS                                  run   run1
                                      calc   calc8


MODEL STATISTICS

BLOCKS OF EQUATIONS          13     SINGLE EQUATIONS          256
BLOCKS OF VARIABLES          10     SINGLE VARIABLES          265
NON ZERO ELEMENTS           722     DISCRETE VARIABLES         93


GENERATION TIME      =        0.031 SECONDS      3 MB  24.5.6 r55090 WEX-WEI


EXECUTION TIME       =        0.031 SECONDS      3 MB  24.5.6 r55090 WEX-WEI
               L O O P S                run run1
                                       calc calc8

GAMS 24.5.6  r55090 Released Nov 27, 2015 WEX-WEI x86 64bit/MS Windows 04/10/16 14:27:53 Page 41
State_Space_Model
Solution Report     SOLVE MIN_COST Using RMIP From line 1139


               S O L V E      S U M M A R Y

     MODEL   MIN_COST            OBJECTIVE  obj_variable
     TYPE    RMIP                DIRECTION  MINIMIZE
     SOLVER  CPLEX               FROM LINE  1139

**** SOLVER STATUS     1 Normal Completion         
**** MODEL STATUS      1 Optimal                   
**** OBJECTIVE VALUE             3750.5000

 RESOURCE USAGE, LIMIT          0.031       600.000
 ITERATION COUNT, LIMIT        52    2000000000

IBM ILOG CPLEX   24.5.6 r55090 Released Nov 27, 2015 WEI x86 64bit/MS Windows 
Cplex 12.6.2.0

Space for names approximately 0.01 Mb
Use option 'names no' to turn use of names off
LP status(1): optimal
Cplex Time: 0.01sec (det. 0.59 ticks)
Optimal solution found.
Objective :        3750.500000



**** REPORT SUMMARY :        0     NONOPT
                             0 INFEASIBLE
                             0  UNBOUNDED
GAMS 24.5.6  r55090 Released Nov 27, 2015 WEX-WEI x86 64bit/MS Windows 04/10/16 14:27:53 Page 42
State_Space_Model
E x e c u t i o n


EXECUTION TIME       =        0.000 SECONDS      3 MB  24.5.6 r55090 WEX-WEI


USER: Department of Chemical & Biological EngineeringG151026:1254AO-GEN
      University of Wisconsin - Madison                          DC4923
      License for teaching and research at degree granting institutions


**** FILE SUMMARY

Input      C:\Users\dhruv\Box Sync\Work\Codes\GAMS_Code_Paper1\Z_N2_MH12_RF1_OPT
           1_DF4_DV1_DL2.5_DU1_S1_MC1_Cost.gms
Output     C:\Users\dhruv\Box Sync\Work\Codes\GAMS_Code_Paper1\Z_N2_MH12_RF1_OPT
           1_DF4_DV1_DL2.5_DU1_S1_MC1_Cost.lst
